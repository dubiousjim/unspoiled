/* syntax walker

   Copyright (c) 2012 by Dubiousjim <dubiousjim@gmail.com>.
   [Add explanation about licensing, or link to
   https://github.com/dubiousjim/unspoiled/blob/master/LICENSE].

   `walker` is a combination of a Reader monad and Writer monad that walks and converts a Pure syntax tree.

    The Reader part consists of a list of symbols and/or
(symbol-->expression)s. This is automatically pruned as walker encounters any
binding constructions that shadow symbols in the list.

    The Writer part consists of a `state` argument that can be whatever you want.

    The Converter function is passed each atomic Pure expression in the tree.
This function is also passed the current Reader and Writer states, and two
boolean values:

    * q is 1 if the current expression is in a quotation context
    * t is 1 if the current expression is in a tail position for the initial
      expression being walked

    The format in which arguments are passed is:

    Converter q t reader_symbols write_state (expression:arguments)

When expression is a head, arguments will be the list of (not-yet-processed)
expressions to which it is applied. Otherwise it will be [].

The Converter should return a value of the form:

    Possibly_New_Writer_State:Possibly_New_Expression:Possibly_Different_Argument_List

You can add or subtract elements to Possibly_Different_Argument_List, and this
list will be walked next. If you want to insert new expressions that *aren't* to be
walked, just return a complex expression for Possibly_New_Expression. Don't add
an argument list to an expression that was not passed to Converter
as a head. (Though as just mentioned, you can return a complex expression for
Possibly_New_Expression.) Also, there is no facility for excising a head,
though you can replace it with the __id__ macro.

When t was 1, the Converter should additionally return
a macro or expression to wrap around the whole tail expression (the head
together with all its arguments), so then the return value has the form:

    Possibly_New_Writer_State:Wrapper:Possibly_New_Expression:Possibly_Different_Argument_List

For example, if one expression in tail position is:

    HEAD1 VAL2 (HEAD2 VAL3) VAL4

Converter will be passed each of these lists: [HEAD1, VAL2, HEAD2 VAL3, VAL4],
[VAL2], [HEAD2, VAL3], [VAL3], and [VAL4], with t set to 1 for [HEAD1,...] and
0 for the rest. If Converter returns Wrapper for HEAD, and HEAD', VAL1',
VAL2', VAL3' for each of the transformed expressions, then the final syntax
tree will contain:

    Wrapper (HEAD' VAL1' VAL2' VAL3')

If you don't want to insert any substantial Wrapper, just return the __id__
macro here.

Converter won't be passed ($$) (||) or (&&) heads; walker handles these
internally.

In Pure syntax, block constructs can occur as heads, as in ((if x then succ
else pred) y). And these applications sometimes occur in tail position.
However, the arms of the block construct are not in such cases passed to
Converter as heads (unless they are heads inside the block), and they aren't
passed as being in tail position either. So for example, if the expression:

    (case a of p1 = b c; p2 = d end) e

is in tail position, Converter will be passed the lists [a], [b, c], [c], [d],
and [e], and the tail position flag will be 0 for all of them.

The final expression in a ($$) (||) or (&&) expression, on the other hand, may
be passed as being a head because of later expressions, and may also be passed
as being in tail position. That is, if the expression:

    (a || b) c

is in tail position, Converter will be passed the lists [a], [b, c], and [c],
and exactly the second will be flagged as in tail position.

Converter will be passed (quoted) lambda constructions, for example if the expression:
, but no other block
syntax or complex expressions. That is, if the expression:

    (\a -> b c) d

is in tail position, Converter will be passed the lists [b, c], [c], ['(\a -> b
c), d], and [d], and exactly the third will be flagged as in tail position. It
is the Converter's responsibility to __eval__ the quoted lambda.

(TODO: Should I just require that Converters be declared quoteargs?)

Converter won't be passed any other block syntax, nor indeed any complex
expressions, as the current expressions to be converted (at the head of its
expression list). When the current expression is a head, later
not-yet-processed values in the expression list may be complex or block
expressions.

At the end, walker will return a value of the form Final_State:Converted_Pure_Expression.

*/

namespace __macro__;
public __id__ __head__ __tail__ __flip__;

def __id__ x = x;
def __head__ (x:xs) = x;
def __tail__ (x:xs) = xs;
def __flip__ head b a = head a b;
def __append__ (v:w:x:y:ys) zs = v:w:x:y:(__append__ ys zs);
def __append__ (w:x:y:ys) zs = w:x:y:(__append__ ys zs);
def __append__ (x:y:ys) zs = x:y:(__append__ ys zs);
def __append__ (y:ys) zs = y:(__append__ ys zs);
def __append__ [] zs = zs;
public walker;

namespace __macro__::walker;
using namespace __macro__;

private prune free;
private process;
private process_if1 process_if2 process_if3;
private process_case unwind_case;
private process_when unwind_when;
private process_with1 process_with2 unwind_with;
private process_tailop;
private process_app unwind_app1 unwind_app2;
private finish_w finish_tailop finish_lambda finish_bare;

#! --quoteargs __macro__::walker
// all the process* macros are call-by-name
#! --quoteargs __macro__::walker::process
#! --quoteargs __macro__::walker::process_if1
#! --quoteargs __macro__::walker::process_if2
#! --quoteargs __macro__::walker::process_if3
#! --quoteargs __macro__::walker::process_case
#! --quoteargs __macro__::walker::process_when
#! --quoteargs __macro__::walker::process_with1
#! --quoteargs __macro__::walker::process_with2
#! --quoteargs __macro__::walker::process_tailop
#! --quoteargs __macro__::walker::process_app

def __macro__::walker converter symbol_list state expression = __tail__ (process converter 0 1 [symbol_list,state,expression]);

def prune s []         = [];
def prune s (s:xs)     = xs;
def prune s ((s-->_):xs) = xs;
def prune s (x:xs)     = x:prune s xs;

/*
    free (F:more) selector applying? PATTERN
    where selector = 0 for interested only in nonheads
                   = 1 for in outer context, interested in outer head and all nonheads
                   = 2 for in outer context, interested only in outer head

    // start with F free
    // free _ 1 0 pat (count both outer head and all nonheads as binding)
    \var1 -> EXPR1 // inside EXPR1, F-{var1} are free
    // end with F free

    // start with set of free symbols F
    case EXPR0 of // inside EXPR0, F are free
        // for each line: free _ 0 0 pat
        head1 var1 -> EXPR1; // inside EXPR1, F-{var1} are free
        head2 var2 -> EXPR2; // inside EXPR2, F-{var2} are free
    end;
    // end with F free

    // start with F free
    EXPR0 when // inside EXPR2, F-{var1,var2} are free
        // free _ 0 0 pat, and carry-through
        head1 var1 <- EXPR1; // inside EXPR1, F are free
        head2 var2 <- EXPR2; // inside EXPR2, F-{var1} are free
    end;
    // end with F free

    // start with F free
    EXPR0 with // inside EXPR2, F-{head1,head2} are free
        // free _ 2 0 pat (only want outer head)
        // then for each line: free 0 0 pat (ignore all heads)
        head1 var1 => EXPR1; // inside EXPR1, F-{head1,head2,var1} are free
        head2 var2 => EXPR2; // inside EXPR2, F-{head1,head2,var2} are free
    end;
    // end with F free

    complete block should always end with originalF:new_state:new_expression:...

*/

def free fs@([]:_) _     _       _            = fs;
def free fs        sel   app (pat __type__ _) |
    free fs        sel@2 app (_ __as__ pat)   = free fs sel app pat;
def free (f:fs)    sel   app (s __as__ pat)   = (free $ prune s f:fs) sel app pat; // sel<2
def free fs        2     _       (u@_ _)      = free fs 2 1 u; // only selecting outer head
def free fs        sel   _       (u@_ v)      = (free $ free fs 0 0 v) sel 1 u;
def free fs        0     1       s            = fs;           // s is an inner head, always ignore
def free (f:fs)    _     _       s            = prune s f:fs; // s is an outer head, or occurs unapplied

def process conv q t (f:state:(__ifelse__ i y n):[])   = process_if1 []   (process conv q t) y n $ process conv q 0 [f, state, i];
// when block constructs are heads, as in ((if x then succ else pred) y), their arms count as not in tail position
// even though the whole application (... y) may be in tail position
def process conv q t (f:state:(__ifelse__ i y n):rest) = process_if1 rest (process conv q 0) y n $ process conv q 0 [f, state, i];
def process_if1 rest pcqt y n [f, state, i]   = process_if2 rest pcqt i n $ pcqt [f, state, y];
def process_if2 rest pcqt i n [f, state, y]   = process_if3 rest pcqt i y $ pcqt [f, state, n];
def process_if3 rest pcqt i y [f, state, n]   = f:state:__ifelse__ i y n:rest; // macro will evaluate

def process conv q t (f:state:(__case__ x clauses):[])           = process_case []   f (process conv q t) [] clauses $ process conv q 0 [f, state, x];
def process conv q t (f:state:(__case__ x clauses):rest)         = process_case rest f (process conv q 0) [] clauses $ process conv q 0 [f, state, x];
def process_case rest f0 pcqt xs ((p-->y):clauses) [_, state, x] = process_case rest f0 pcqt (p:x:xs) clauses $ pcqt $ free [f0, state, y] 0 0 p;
def process_case rest f0 _    xs []                [_, state, x] = f0:state:unwind_case (x:xs) []:rest;
def unwind_case (y:p:xs) clauses                                 = unwind_case xs ((p-->y):clauses);
def unwind_case [x]      clauses                                 = (__case__ x clauses); // macro will evaluate

def process conv q t (f:state:(x __when__ clauses):[])                = process_when []   f (process conv q) t [] clauses [f] [[], state, 'x];
def process conv q t (f:state:(x __when__ clauses):rest)              = process_when rest f (process conv q) 0 [] clauses [f] [[], state, 'x];
def process_when rest f0 pcq t xs ((p-->y):clauses) [f] [_, state, x] = (process_when rest f0 pcq t (p:x:xs) clauses $ free [f] 0 0 p) $ pcq 0 [f, state, y];
def process_when rest f0 pcq t xs []                [f] [_, state, x] = unwind_when rest f0 (pcq t) f state (x:xs) [];
def unwind_when rest f0 pcqt f state (y:p:xs) clauses                 = unwind_when rest f0 pcqt f state xs ((p-->y):clauses);
def unwind_when rest f0 pcqt f state ['x]     clauses                 = finish_w rest f0 (__when__) clauses (pcqt [f, state, x]); // macro will evaluate

def process conv q t (f:state:(x __with__ clauses):[])                  = process_with1 []   f (process conv q) t clauses clauses [f, state, 'x];
def process conv q t (f:state:(x __with__ clauses):rest)                = process_with1 rest f (process conv q) 0 clauses clauses [f, state, 'x];
def process_with1 rest f0 pcq t clauses0 ((p-->y):clauses) fsx          = process_with1 rest f0 pcq t clauses0 clauses $ free fsx 2 0 p;
def process_with1 rest f0 pcq t clauses0 []                fsx@(f:_)    = process_with2 rest f0 pcq t f [] clauses0 fsx;
def process_with2 rest f0 pcq t f1 xs ((p-->y):clauses) [_, state, x]   = process_with2 rest f0 pcq t f1 (p:x:xs) clauses $ pcq 0 $ free [f1, state, y] 0 0 p;
def process_with2 rest f0 pcq t f1 xs []                [_, state, x]   = unwind_with rest f0 (pcq t) f1 state (x:xs) [];
def unwind_with rest f0 pcqt f1 state (y:p:xs) clauses                  = unwind_with rest f0 pcqt f1 state xs ((p-->y):clauses);
def unwind_with rest f0 pcqt f1 state ['x]     clauses                  = finish_w rest f0 (__with__) clauses (pcqt [f1, state, x]); // macro will evaluate

def finish_w rest f0 w clauses [_, state, x] = f0:state:w x clauses:rest;

def process conv q t (f:state:(a $$ b):rest)     = process_tailop ($$) (b) rest (process conv q t) $ process conv q 0 [f, state, a]; // lhs isn't in tail position
def process conv q t (f:state:(a || b):rest)     = process_tailop (||) (b) rest (process conv q t) $ process conv q 0 [f, state, a];
def process conv q t (f:state:(a && b):rest)     = process_tailop (&&) (b) rest (process conv q t) $ process conv q 0 [f, state, a];
def process_tailop op b rest pcqt [f0, state, a] = finish_tailop op a (pcqt (f0:state:b:rest));

def finish_tailop op a (f0:state:b:rest) = f0:state:op a b:rest;

def process conv q t (f:state:(__lambda__ ps x):rest) = finish_lambda rest f (conv q) t ps (process conv q 0 $ free [f, state, x] 1 0 ps);
def finish_lambda rest f0 cq t ps [_, state, x]       = f0:cq t f0 state (('__lambda__ ps x):rest);

// We need to keep the head u in a head position so that we can use the pattern
// (quote ...) to match it literally. Potentially the head might be a macro
// that unintentionally gets triggered when adding the vs list as we do here. I
// suspect that the same threat would in principle confront any other solution.
def process conv q t (f:state:(us@_ v):rest)        = process_app rest conv q t f state (us [v]);
def process_app rest conv q t f state ((us@_ v) vs) = process_app rest conv q t f state (us (v:vs)); // recurse down to head
// we assume user doesn't rebind quote, or expect us to treat any other symbols as quoters
def process_app rest conv q t f state (quote vs)    = unwind_app1 rest f (process conv 1) __id__ t (process conv q t ([]:state:quote:vs));
def process_app rest conv q t f state ((') vs)      = unwind_app1 rest f (process conv 1) __id__ t (process conv q t ([]:state:('):vs));
def process_app rest conv q t f state (u@_ vs)      = unwind_app1 rest f (process conv q) __id__ t (process conv q t (f:state:u:vs));
def unwind_app1 rest f0 pcq _    1         (f:state:wrap:u:v:vs) |
    unwind_app1 rest f0 pcq wrap 0         (f:state:u:v:vs)      = unwind_app2 rest f0 pcq wrap u      vs (pcq 0 [f, state, v]);
def unwind_app2 rest f0 pcq wrap us (v:vs) (f:state:[w])         = unwind_app2 rest f0 pcq wrap (us w) vs (pcq 0 [f, state, v]);
def unwind_app2 rest f0 pcq wrap us []     (_:state:[w])         = f0:state:wrap (us w):rest;

def process conv q 1 (f:state:[v])      = finish_bare f (conv q 1 f state [v]); // non-head in tail position
def finish_bare f (state:wrap:[v])      = [f, state, wrap v];

def process conv q t (f:state:vs)       = f:conv q t f state vs;
