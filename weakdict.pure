/*
  weakdict.pure

    Low-level conventions
    ---------------------
    * original object x gets a sentry box (this can chain a regular sentry)
    * the box contains a refcell r that keeps a list of which weak_ref
      sentries have been associated with x; r also contains an unsafe ptr to x
      (we keep that always at the head of the list)
    * hashtable H keeps an association from x's address --> r
    * clients can use x's address as indices into H; but they shouldn't
      keep hold of these indices (x might get GC'd, and in the
      meantime another object can get registered into the weak_ref system
      using the same address).
    * I considered versioning the hashtable, or keeping hashtable entries
      alive after x had been collected. But on balance, I favor the lightweight
      approach of just making sure the higher-level API (the weakdict collections)
      does the right thing.

    High-level weak-key and weak-value dictionaries are guided by Python's
    implementation of these, and my experience working with Lua's weak tables.

*/



/* ..

Some notes from other files, for my reference...

   Sentries
   ~~~~~~~~

   Sentries are Pure's flavour of object `finalizers`. A sentry is simply an
   object (usually a function) which gets applied to the target expression
   when it is garbage-collected. This is useful to perform automatic cleanup
   actions on objects with internal state, such as files. Pure's sentries are
   *much* more useful than finalizers in other garbage-collected languages,
   since it is guaranteed that they are called as soon as an object "goes out
   of scope", i.e., becomes inaccessible.

   .. function:: sentry f x

      Places a sentry ``f`` at an expression ``x`` and returns the modified
      expression.

   .. function:: clear_sentry x

      Removes the sentry from an expression ``x``.

   .. function:: get_sentry x

      Returns the sentry of an expression ``x`` (if any, fails otherwise).

   As of Pure 0.45, sentries can be placed on any Pure expression. The sentry
   itself can also be any type of object (but usually it's a function).
   Example::

     > using system;
     > sentry (\_->puts "I'm done for!") (1..3);
     [1,2,3]
     > clear ans
     I'm done for!

   Note that setting a finalizer on a global symbol won't usually be of much
   use since such values are cached by the interpreter. (However, the sentry
   *will* be invoked if the symbol gets recompiled because its definition has
   changed. This may be useful for some purposes.)

   In Pure parlance, we call an expression `cooked` if a sentry has been
   attached to it. The following predicate can be used to check for this
   condition. Also, there is a convenience function to create cooked pointers
   which take care of freeing themselves when they are no longer needed.

   .. function:: cookedp x

      Check whether a given object has a sentry set on it.

   .. function:: cooked ptr

      Create a pointer which disposes itself after use. This is just a
      shorthand for ``sentry free``. The given pointer ``ptr`` must be
      :func:`malloc`\ ed to make this work.

   Example::

     > using system;
     > let p = cooked (malloc 1024);
     > cookedp p;
     1
     > get_sentry p;
     free
     > clear p

   Besides their use as finalizers, sentries can also be handy in other
   circumstances, when you need to associate an expression with another,
   "invisible" value. In this case the sentry is usually some kind of data
   structure instead of a function to be executed at finalization time. For
   instance, here's how we can employ sentries to implement hashing of
   function values::

     using dict;
     hashed f x = case get_sentry f of
                    h::hdict = h!x if member h x;
                    _ = y when y = f x; sentry (update h x y) f
                            when h = case get_sentry f of
                                       h::hdict = h; _ = emptyhdict
                                     end;
                            end;
                          end;
                  end;

   E.g., consider the naive recursive definition of the Fibonacci function::

     fib n::int = if n<=1 then 1 else fib (n-1)+fib (n-2);

   A hashed version of the Fibonacci function can be defined as follows::

     let hfib = hashed f with
       f n::int = if n<=1 then 1 else hfib (n-1)+hfib (n-2)
     end;

   This turns the naive definition of the Fibonacci function (which has
   exponential time complexity) into a linear time operation::

     > stats
     > fib 35;
     14930352
     4.53s
     > hfib 35;
     14930352
     0.25s

   Finally, note that there can be only one sentry per expression but,
   building on the operations provided here, it's easy to design a scheme
   where sentries are chained. For instance::

     chain_sentry f x = sentry (h (get_sentry x)) x with
       h g x = g x $$ f x;
     end;

   This invokes the original sentry before the chained one::

     > using system;
     > f _ = puts "sentry#1"; g _ = puts "sentry#2";
     > let p = chain_sentry g $ sentry f $ malloc 10;
     > clear p
     sentry#1
     sentry#2

   You can chain any number of sentries that way. This scheme should work in
   most cases in which sentries are used just as finalizers. However, there
   are other uses, like the "hashed function" example above, where you'd like
   the original sentry to stay intact. This can be achieved by placing the new
   sentry as a sentry on the *original sentry* rather than the expression
   itself::

     attach_sentry f x = sentry (sentry f (get_sentry x)) x;

   This requires that the sentry will actually be garbage-collected when its
   hosting expression gets freed, so it will *not* work if the original sentry
   is a global::

     > let p = attach_sentry g $ sentry f $ malloc 10;
     > clear p
     sentry#1

   However, the attached sentry will work ok if you can ensure that the
   original sentry is a (partial or constructor) application. E.g.::

     > let p = attach_sentry g $ sentry (f$) $ malloc 10;
     > clear p
     sentry#1
     sentry#2


namespace __C;
extern expr* pure_new(expr*);
extern expr* pure_expr_pointer();
extern void pure_free(expr*);
extern expr* pointer_get_expr(void*);
void pointer_put_expr(void*, expr*);
namespace;

public ref unref refp;

ref x = pointer_put_expr r (pure_new x) $$
        sentry unref r when r::pointer = pure_expr_pointer end;

unref r::pointer = pure_free (pointer_get_expr r) $$
                   clear_sentry r if refp r;

put r::pointer x = pure_free (pointer_get_expr r) $$
                   pointer_put_expr r (pure_new x) $$ x if refp r;

get r::pointer = pointer_get_expr r if refp r;

refp r = case r of _::pointer = get_sentry r===unref; _ = 0 end;

*/


using hashtable, trees23;

// we need to overwrite the stdlib definitions of these
public _sentry _clear_sentry _get_sentry _cookedp _cooked;

// global exception
public bad_pointer_value;

namespace weakdict;

// low-level weak_ref machinery
namespace weakdict::__ref__;


public weak_addr weak_get weak_ref;
private H Box lookup; private nonfix notfound nil;


private extern expr* pure_sentry(expr*,expr*); //  = sentry; // IMPURE!
private extern expr* pure_clear_sentry(expr*); // = clear_sentry; // IMPURE!
private extern expr* pure_get_sentry(expr*); // = get_sentry;
private extern bool  pure_has_sentry(expr*); // = cookedp;

// to cooperate with existing sentry framework
// our sentries are a box that can chain a regular sentry
// and the ::_get_sentry etc methods ignore our box

::_sentry f x = if pure_has_sentry x then
    case pure_get_sentry x of
        Box r _ = pure_sentry (Box r f) x;
        _ = pure_sentry f x;
    end else pure_sentry f x;

::_clear_sentry x = if pure_has_sentry x then
    case pure_get_sentry x of
        Box r nil = x;
        Box r _ = pure_sentry (Box r nil) x;
        _ = pure_clear_sentry x;
    end else x;

::_get_sentry x = s if s ~== nil when
    s = if pure_has_sentry x then
        case pure_get_sentry x of
            Box r s = s;
            s = s;
        end else nil;
end;

::_cookedp x = if pure_has_sentry x then
    case pure_get_sentry x of
        Box r nil = 0;
        _ = 1;
    end else 0;

::_cooked p::pointer = ::_sentry free p;


// x is dying
Box r s x = case s of
    nil = handle r x;
    s   = handle r x $$ s x;
end with
    handle r x = () when
                    // do we need to use pure_ref x here...?
                    u:ss = __C::pointer_get_expr r;
                    // remove (xaddr=>r) from H
                    xaddr = get_pointer u;
                    hashtable::delete H xaddr;
                    // run the weak_ref sentries
                    do ($ xaddr) ss;
                    // do we need to use pure_unref x here ...?
               end;
end;

// is there a way to get x's address without allocating a new pointer?
weak_addr x = xaddr when
    u::pointer = __C::pure_expr_pointer;
    __C::pointer_put_expr u x;
    xaddr = get_pointer u;
end;

let H = hashtable::emptyhashtable; // global hashtable of (addr=>weak_ref)s

lookup xaddr = hashtable::getk H xaddr notfound;
/*
    lookup xaddr = hashtable::eachk H f xaddr notfound with
        f (_=>r) = if alive r then r else 0; // 0 means continue
    end;
    alive r = u ~== NULL when u:_ = __C::pointer_get_expr r end;
*/


// lookup x using xaddr
weak_get xaddr = case lookup xaddr of
    notfound = throw (bad_pointer_value xaddr);
    r = x when
            u:_ = __C::pointer_get_expr r;
            x = __C::pointer_get_expr u;
        end;
end;

// register a "new weak_ref" for x (a new sentry)
weak_ref x sen::function = xaddr when
    pure_new x; // lock x from being collected until everything is set up
                // might I use pure_ref instead?
    u::pointer = __C::pure_expr_pointer;
    __C::pointer_put_expr u x;  // unsafe ptr to x (x's refcount not increased)
    xaddr = get_pointer u;
    r = case lookup xaddr of
            notfound = r when
                 // r is a refcell containing the unsafe ptr and a list of sentries
                 r = ref [u, sen];
                 // We add r to hashtable, indexed by xaddr, so we can look it up given x
                 hashtable::insert H (xaddr=>r);
                 // setup x's sentry
                 weak_sentry r x;
            end;
            r = put r (u:sen:ss) $$ r when // add sentry
                u:ss = get r;
            end;
        end;
    pure_free x; // might I use pure_unref instead?
end with
    // set up our sentry box
    weak_sentry r x = () when
        s = if pure_has_sentry x then pure_get_sentry x else nil;
        pure_sentry (Box r s) x;
    end;
end;


namespace weakdict;

// high-level API

using namespace weakdict::__ref__;


// These should be considered private.
public WKDict WVDict WKMDict WVMDict;

// TODO: do we need to define unions of these?
type wkdict  (WKDict _)  | wvdict  (WVDict _)
   | wkmdict (WKMDict _) | wvmdict (WVMDict _);

// type checks
wkdictp  x = typep wkdict  x;
wvdictp  x = typep wvdict  x;
wkmdictp x = typep wkmdict x;
wvmdictp x = typep wvmdict x;

// create an empty dict
emptywkdict  = WKDict trees23::emptytree;
emptywvdict  = WVDict trees23::emptytree;
emptywkmdict = WKMDict trees23::emptytree;
emptywvmdict = WVMDict trees23::emptytree;

// create a dict from a list
wkdict  xys::rlist = foldl insert emptywkdict  xys;
wvdict  xys::rlist = foldl insert emptywvdict  xys;
wkmdict xys::rlist = foldl insert emptywkmdict xys;
wvmdict xys::rlist = foldl insert emptywvmdict xys;

// create a dict from a list of keys and a constant value
mkwkdict  y xs::rlist = wkdict  (zipwith (=>) xs (repeaten (#xs) y));
mkwvdict  y xs::rlist = wvdict  (zipwith (=>) xs (repeaten (#xs) y));
mkwkmdict y xs::rlist = wkmdict (zipwith (=>) xs (repeaten (#xs) y));
mkwvmdict y xs::rlist = wvmdict (zipwith (=>) xs (repeaten (#xs) y));


///////////////////////////////////////////////////////////////

/*
// insert a member
insert (Dict   d) el@(x=>y) = Dict   (avl::insertk   d el);
insert (HDict  d) el@(x=>y) = HDict  (avl::hinsertk  d el);
insert (MDict  d) el@(x=>y) = MDict  (avl::minsertk  d el);
insert (HMDict d) el@(x=>y) = HMDict (avl::mhinsertk d el);
*/

// insert a member
insert (WKDict  d) el@(x=>y) = WKDict  (
insert (WVDict  d) el@(x=>y) = WVDict  (
insert (WKMDict d) el@(x=>y) = WKMDict (
insert (WVMDict d) el@(x=>y) = WVMDict (

// curried version of insert
update d@(WKDict  _) x y | update d@(WVDict  _) x y |
update d@(WKMDict _) x y | update d@(WVMDict _) x y = insert d (x=>y);

/*
// delete a member by key
delete (Dict   d) x = Dict   (avl::deletek   d x);
delete (HDict  d) x = HDict  (avl::hdeletek  d x);
delete (MDict  d) x = MDict  (avl::mdeletek  d x);
delete (HMDict d) x = HMDict (avl::mhdeletek d x);
*/

// delete a member by key
delete (WKDict  d) x = WKDict  (
delete (WVDict  d) x = WVDict  (
delete (WKMDict d) x = WKMDict (
delete (WVMDict d) x = WVMDict (

/*
// delete a member by key=>val
delete_val (Dict   d) el@(x=>y) = Dict   (avl::deletekv   d el);
delete_val (HDict  d) el@(x=>y) = HDict  (avl::hdeletekv  d el);
delete_val (MDict  d) el@(x=>y) = MDict  (avl::mdeletekv  d el);
delete_val (HMDict d) el@(x=>y) = HMDict (avl::mhdeletekv d el);
*/

// delete a member by key=>val
delete_val (WKDict  d) el@(x=>y) = WKDict  (
delete_val (WVDict  d) el@(x=>y) = WVDict  (
delete_val (WKMDict d) el@(x=>y) = WKMDict (
delete_val (WVMDict d) el@(x=>y) = WVMDict (

/*
// delete all instances of a given key
delete_all (Dict   d) x = Dict   (avl::deletek    d x);
delete_all (HDict  d) x = HDict  (avl::hdeletek   d x);
delete_all (MDict  d) x = MDict  (avl::mdeleteka  d x);
delete_all (HMDict d) x = HMDict (avl::mhdeleteka d x);
*/

// delete all instances of a given key
delete_all (WKDict  d) x = WKDict  (
delete_all (WVDict  d) x = WVDict  (
delete_all (WKMDict d) x = WKMDict (
delete_all (WVMDict d) x = WVMDict (

/*
// membership test
member (Dict   d) k = avl::memberk  d k;
member (MDict  d) k = avl::memberk  d k;
member (HDict  d) k = avl::hmemberk d k;
member (HMDict d) k = avl::hmemberk d k;
*/

// membership test
member (WKDict  d) k = WKDict  (
member (WVDict  d) k = WVDict  (
member (WKMDict d) k = WKMDict (
member (WVMDict d) k = WVMDict (

/*
// get a value by key
(Dict   d)!k = avl::getk   d k;
(MDict  d)!k = avl::mgetk  d k;
(HDict  d)!k = avl::hgetk  d k;
(HMDict d)!k = avl::mhgetk d k;
*/

// get a value by key
(WKDict  d)!k = trees23::getk d k;
(WVDict  d)!k = trees23::getk d k;
(WKMDict d)!k = trees23::getk d k;
(WVMDict d)!k = trees23::getk d k;


///////////////////////////////////////////////////////////////


/*
// TODO: do we want to expose these size methods?
// they should be regarded as highly volatile, liable to change even while
// being computed

// check for the empty dict
null d@(WKDict  _) | null d@(WVDict  _) |
null d@(WKMDict _) | null d@(WVMDict _) = trees23::null d;

// dict size
#(WKDict  d) = trees23::hsize d;
#(WVDict  d) = trees23::hsize d;
#(WKMDict d) = trees23::hsize d; // not hmsize?
#(WVMDict d) = trees23::hsize d; // not hmsize?

// TODO: should any of these iteration methods be exposed?

// get the members, keys and values of a dict as a list
members (WKDict  d) = trees23::members d;
members (WVDict  d) = trees23::members d;
members (WKMDict d) = trees23::members d;
members (WVMDict d) = trees23::members d;

keys (WKDict  d) = trees23::keys d;
keys (WVDict  d) = trees23::keys d;
keys (WKMDict d) = trees23::keys d;
keys (WVMDict d) = trees23::keys d;

vals (WKDict  d) = trees23::vals d;
vals (WVDict  d) = trees23::vals d;
vals (WKMDict d) = trees23::vals d;
vals (WVMDict d) = trees23::vals d;

list d::xdict = members d;

// get the first and last member
first (Dict   d) = avl::first  d;
first (MDict  d) = avl::mfirst d;
last  (Dict   d) = avl::last   d;
last  (MDict  d) = avl::mlast  d;
first (HDict  d) = avl::hfirst d;
first (HMDict d) = avl::hfirst d;
last  (HDict  d) = avl::hlast  d;
last  (HMDict d) = avl::hlast  d;

// remove the first and last member
rmfirst (Dict   d) = Dict   (avl::rmfirst  d);
rmlast  (Dict   d) = Dict   (avl::rmlast   d);
rmfirst (MDict  d) = MDict  (avl::mrmfirst d);
rmlast  (MDict  d) = MDict  (avl::mrmlast  d);
rmfirst (HDict  d) = HDict  (avl::hrmfirst d);
rmlast  (HDict  d) = HDict  (avl::hrmlast  d);
rmfirst (HMDict d) = HMDict (avl::hrmfirst d);
rmlast  (HMDict d) = HMDict (avl::hrmlast  d);
*/



/*
// Less crucial methods, also unsure which of these should be exposed

// conversions between the different dictionary types
public members;
dict d@(Dict _) | hdict d@(HDict _) | mdict d@(MDict _) |
  hmdict d@(HMDict _) = d;
dict   d::xdict = dict   (members d);
hdict  d::xdict = hdict  (members d);
mdict  d::xdict = mdict  (members d);
hmdict d::xdict = hmdict (members d);

// comparisons
d1@(Dict _)   == d2@(Dict _)   = cmp (members d1) (members d2) with
  /- This case is optimized so that we only need a single traversal of the
     member lists which can be done in linear time. Also note that keys are
     compared for equality in the sense that two keys are equal if neither is
     less than the other, whereas values are compared for proper equality (==)
     if it is defined, falling back to (===) otherwise. -/
  cmp [] [] = 1;
  cmp (x:xs) [] = 0;
  cmp [] (x:xs) = 0;
  cmp ((xk=>xv):xs) ((yk=>yv):ys) =
    ~(xk<yk || yk<xk) && eq xv yv && cmp xs ys;
  eq u v = case u==v of res::int = res; _ = u===v end;
end;
d1@(MDict _)  == d2@(MDict _)  |
d1@(HDict _)  == d2@(HDict _)  |
d1@(HMDict _) == d2@(HMDict _) = d1 <= d2 && d2 <= d1;

d1@(Dict _)   ~= d2@(Dict _)   |
d1@(MDict _)  ~= d2@(MDict _)  |
d1@(HDict _)  ~= d2@(HDict _)  |
d1@(HMDict _) ~= d2@(HMDict _) = ~(d1 == d2);

d1@(Dict _)   <= d2@(Dict _)   = cmp (members d1) (members d2) with
  /- Again, this case is optimized so that we only need a single traversal of
     the member lists. Also note that the member lists are ordered by key, so
     that we can use a kind of subset check for two ordered sequences which
     can still be done in linear time. -/
  cmp [] [] = 1;
  cmp (x:xs) [] = 0;
  cmp [] (x:xs) = 1;
  cmp xs1@((xk=>xv):xs) ((yk=>yv):ys)
  = 0 if xk<yk;
  = cmp xs1 ys if yk<xk;
  = eq xv yv && cmp xs ys;
  eq u v = case u==v of res::int = res; _ = u===v end;
end;
d1@(MDict _)  <= d2@(MDict _)  |
d1@(HDict _)  <= d2@(HDict _)  |
d1@(HMDict _) <= d2@(HMDict _) = null (d1 - d2);

d1@(Dict _)   >= d2@(Dict _)   = d2 <= d1;
d1@(MDict _)  >= d2@(MDict _)  |
d1@(HDict _)  >= d2@(HDict _)  |
d1@(HMDict _) >= d2@(HMDict _) = null (d2 - d1);

d1@(Dict _)   <  d2@(Dict _)   |
d1@(MDict _)  <  d2@(MDict _)  |
d1@(HDict _)  <  d2@(HDict _)  |
d1@(HMDict _) <  d2@(HMDict _) = d1 <= d2 && ~(d1 >= d2);

d1@(Dict _)   >  d2@(Dict _)   |
d1@(MDict _)  >  d2@(MDict _)  |
d1@(HDict _)  >  d2@(HDict _)  |
d1@(HMDict _) >  d2@(HMDict _) = d1 >= d2 && ~(d1 <= d2);

// sum, difference, intersection
d1@(Dict _)   +  d2@(Dict _)   |
d1@(MDict _)  +  d2@(MDict _)  |
d1@(HDict _)  +  d2@(HDict _)  |
d1@(HMDict _) +  d2@(HMDict _) = foldl insert d1 (members d2);

d1@(Dict _)   -  d2@(Dict _)   |
d1@(MDict _)  -  d2@(MDict _)  |
d1@(HDict _)  -  d2@(HDict _)  |
d1@(HMDict _) -  d2@(HMDict _) = foldl delete_val d1 (members d2);

d1@(Dict _)   *  d2@(Dict _)   |
d1@(MDict _)  *  d2@(MDict _)  |
d1@(HDict _)  *  d2@(HDict _)  |
d1@(HMDict _) *  d2@(HMDict _) = d1 - (d1 - d2);

// automatic coercion rules

m1@(HMDict _) == m2 = m1 == hmdict m2 if xdictp m2;
m1 == m2@(HMDict _) = hmdict m1 == m2 if xdictp m1;
m1@(HDict _) == m2  = case m2 of
                        _@(MDict _) = hmdict m1 == hmdict m2;
                        _@(Dict _)  = m1 == hdict m2;
                      end if xdictp m2;
m1 == m2@(HDict _)  = case m1 of
                        _@(MDict _) = hmdict m1 == hmdict m2;
                        _@(Dict _)  = hdict m1 == m2;
                      end if xdictp m2;
m1@(MDict _) == m2@(Dict _) = m1 == mdict m2;
m1@(Dict _) == m2@(MDict _) = mdict m1 == m2;

m1@(HMDict _) ~= m2 = m1 ~= hmdict m2 if xdictp m2;
m1 ~= m2@(HMDict _) = hmdict m1 ~= m2 if xdictp m1;
m1@(HDict _) ~= m2  = case m2 of
                        _@(MDict _) = hmdict m1 ~= hmdict m2;
                        _@(Dict _)  = m1 ~= hdict m2;
                      end if xdictp m2;
m1 ~= m2@(HDict _)  = case m1 of
                        _@(MDict _) = hmdict m1 ~= hmdict m2;
                        _@(Dict _)  = hdict m1 ~= m2;
                      end if xdictp m2;
m1@(MDict _) ~= m2@(Dict _) = m1 ~= mdict m2;
m1@(Dict _) ~= m2@(MDict _) = mdict m1 ~= m2;

m1@(HMDict _) <= m2 = m1 <= hmdict m2 if xdictp m2;
m1 <= m2@(HMDict _) = hmdict m1 <= m2 if xdictp m1;
m1@(HDict _) <= m2  = case m2 of
                        _@(MDict _) = hmdict m1 <= hmdict m2;
                        _@(Dict _)  = m1 <= hdict m2;
                      end if xdictp m2;
m1 <= m2@(HDict _)  = case m1 of
                        _@(MDict _) = hmdict m1 <= hmdict m2;
                        _@(Dict _)  = hdict m1 <= m2;
                      end if xdictp m2;
m1@(MDict _) <= m2@(Dict _) = m1 <= mdict m2;
m1@(Dict _) <= m2@(MDict _) = mdict m1 <= m2;

m1@(HMDict _) >= m2 = m1 >= hmdict m2 if xdictp m2;
m1 >= m2@(HMDict _) = hmdict m1 >= m2 if xdictp m1;
m1@(HDict _) >= m2  = case m2 of
                        _@(MDict _) = hmdict m1 >= hmdict m2;
                        _@(Dict _)  = m1 >= hdict m2;
                      end if xdictp m2;
m1 >= m2@(HDict _)  = case m1 of
                        _@(MDict _) = hmdict m1 >= hmdict m2;
                        _@(Dict _)  = hdict m1 >= m2;
                      end if xdictp m2;
m1@(MDict _) >= m2@(Dict _) = m1 >= mdict m2;
m1@(Dict _) >= m2@(MDict _) = mdict m1 >= m2;

m1@(HMDict _) < m2 = m1 < hmdict m2 if xdictp m2;
m1 < m2@(HMDict _) = hmdict m1 < m2 if xdictp m1;
m1@(HDict _) < m2  = case m2 of
                       _@(MDict _) = hmdict m1 < hmdict m2;
                       _@(Dict _)  = m1 < hdict m2;
                     end if xdictp m2;
m1 < m2@(HDict _)  = case m1 of
                       _@(MDict _) = hmdict m1 < hmdict m2;
                       _@(Dict _)  = hdict m1 < m2;
                     end if xdictp m2;
m1@(MDict _) < m2@(Dict _) = m1 < mdict m2;
m1@(Dict _) < m2@(MDict _) = mdict m1 < m2;

m1@(HMDict _) > m2 = m1 > hmdict m2 if xdictp m2;
m1 > m2@(HMDict _) = hmdict m1 > m2 if xdictp m1;
m1@(HDict _) > m2  = case m2 of
                       _@(MDict _) = hmdict m1 > hmdict m2;
                       _@(Dict _)  = m1 > hdict m2;
                     end if xdictp m2;
m1 > m2@(HDict _)  = case m1 of
                       _@(MDict _) = hmdict m1 > hmdict m2;
                       _@(Dict _)  = hdict m1 > m2;
                     end if xdictp m2;
m1@(MDict _) > m2@(Dict _) = m1 > mdict m2;
m1@(Dict _) > m2@(MDict _) = mdict m1 > m2;

m1@(HMDict _) + m2 = m1 + hmdict m2 if xdictp m2;
m1 + m2@(HMDict _) = hmdict m1 + m2 if xdictp m1;
m1@(HDict _) + m2  = case m2 of
                       _@(MDict _) = hmdict m1 + hmdict m2;
                       _@(Dict _)  = m1 + hdict m2;
                     end if xdictp m2;
m1 + m2@(HDict _)  = case m1 of
                       _@(MDict _) = hmdict m1 + hmdict m2;
                       _@(Dict _)  = hdict m1 + m2;
                     end if xdictp m2;
m1@(MDict _) + m2@(Dict _) = m1 + mdict m2;
m1@(Dict _) + m2@(MDict _) = mdict m1 + m2;

m1@(HMDict _) - m2 = m1 - hmdict m2 if xdictp m2;
m1 - m2@(HMDict _) = hmdict m1 - m2 if xdictp m1;
m1@(HDict _) - m2  = case m2 of
                       _@(MDict _) = hmdict m1 - hmdict m2;
                       _@(Dict _)  = m1 - hdict m2;
                     end if xdictp m2;
m1 - m2@(HDict _)  = case m1 of
                       _@(MDict _) = hmdict m1 - hmdict m2;
                       _@(Dict _)  = hdict m1 - m2;
                     end if xdictp m2;
m1@(MDict _) - m2@(Dict _) = m1 - mdict m2;
m1@(Dict _) - m2@(MDict _) = mdict m1 - m2;

m1@(HMDict _) * m2 = m1 * hmdict m2 if xdictp m2;
m1 * m2@(HMDict _) = hmdict m1 * m2 if xdictp m1;
m1@(HDict _) * m2  = case m2 of
                       _@(MDict _) = hmdict m1 * hmdict m2;
                       _@(Dict _)  = m1 * hdict m2;
                     end if xdictp m2;
m1 * m2@(HDict _)  = case m1 of
                       _@(MDict _) = hmdict m1 * hmdict m2;
                       _@(Dict _)  = hdict m1 * m2;
                     end if xdictp m2;
m1@(MDict _) * m2@(Dict _) = m1 * mdict m2;
m1@(Dict _) * m2@(MDict _) = mdict m1 * m2;

*/
