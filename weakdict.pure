/*
  weakdict.pure

    Low-level conventions
    ---------------------
    * original object x gets a sentry box (this can chain a regular sentry)
    * the box contains a refcell r that keeps a list of which weak_ref
      sentries have been associated with x; r also contains an unsafe ptr to x
      (we keep that always at the head of the list)
    * clients can use r as a weakref to x; it will live longer than x does
      but won't keep x alive. When x starts to die, r will no longer deref to
      x; however x will in fact still be alive until all its weak_sentries
      have run (and after them, its ordinary sentries).

    High-level weak-key and weak-value dictionaries are guided by Python's
    implementation of these, and my experience working with Lua's weak tables.
*/


using trees23;

// we need to overwrite the stdlib definitions of these
public _sentry _clear_sentry _get_sentry _cookedp _cooked;

// global exception
public bad_pointer_value;


// for our constructors and private methods
namespace weakdict;

private Box weak_get weak_getref weak_ref;
private nonfix notfound nil;

private extern expr* pure_sentry(expr*,expr*); //  = sentry; // IMPURE!
private extern expr* pure_clear_sentry(expr*); // = clear_sentry; // IMPURE!
private extern expr* pure_get_sentry(expr*); // = get_sentry;
private extern bool  pure_has_sentry(expr*); // = cookedp;

// to cooperate with existing sentry framework
// our sentries are a box that can chain a regular sentry
// and the ::_get_sentry etc methods ignore our box

::_sentry f x = if pure_has_sentry x then
    case pure_get_sentry x of
        Box r _ = pure_sentry (Box r f) x;
        _ = pure_sentry f x;
    end else pure_sentry f x;

::_clear_sentry x = if pure_has_sentry x then
    case pure_get_sentry x of
        Box r nil = x;
        Box r _ = pure_sentry (Box r nil) x;
        _ = pure_clear_sentry x;
    end else x;

::_get_sentry x = s if s ~== nil when
    s = if pure_has_sentry x then
        case pure_get_sentry x of
            Box r s = s;
            s = s;
        end else nil;
end;

::_cookedp x = if pure_has_sentry x then
    case pure_get_sentry x of
        Box r nil = 0;
        _ = 1;
    end else 0;

::_cooked p::pointer = ::_sentry free p;


// We need our own version of these, at least until our _sentry
// methods are moved to stdlib, because our refcells won't typecheck as being ::refp.
public ref unref put get refp;

// parameterizing unref permits installing hooks like gasp, below
ref x = __C::pointer_put_expr r (__C::pure_new x) $$
        _sentry (unref _clear_sentry) r when r::pointer = __C::pure_expr_pointer end;

unref next r::pointer = __C::pure_free (__C::pointer_get_expr r) $$
                        next r if refp r;

put r::pointer x = __C::pure_free (__C::pointer_get_expr r) $$
                   __C::pointer_put_expr r (__C::pure_new x) $$ x if refp r;

get r::pointer = __C::pointer_get_expr r if refp r;

refp r = case r of
    _::pointer = case _get_sentry r of unref _ = 1; _ = 0 end;
    _ = 0;
end;

// for testing, make object announce its death
// works for refcells created using the above methods, and ordinary expressions
public gasp;
gasp name::string x = case _get_sentry x of
    unref next = _sentry (unref (next . announcer)) x;
    _get_sentry _ = _sentry announcer x;
    _ = throw "sentry conflict"
end with
    announcer _ = printf "%s is dying\n" name;
end;


// x is dying
Box r s x = case s of
    nil = handle r x;
    s   = handle r x $$ s x;
end with
    handle r x = () when
                    // do we need to use pure_ref x here...?
                    u:ss = get r;
                    // assert(u is still unsafe ptr, not notfound)
                    // now that x is dying, no one can look it up via r anymore
                    put r [notfound];
                    // run the weak_ref sentries
                    // we give them the weakref as an argument but not x
                    // so there's no danger of them reviving x
                    do (($r).get) ss;
                    // do we need to use pure_unref x here ...?
               end;
end;


// lookup x from weak_ref
weak_get r = case get r of
    u:_ = {} if u === notfound;
        = '{x} when
            x = __C::pointer_get_expr u; // deref the unsafe ptr
          end otherwise;
end;

// lookup existing weak_ref from x
weak_getref x = if ~pure_has_sentry x then notfound
               else case pure_get_sentry x of
                    Box r _ = r;
                    _ = notfound;
               end;

// make new weak_ref for x (with optional sentry)
// returns pair of weak_ref, a ()-function that expires this sentry
// use void if you don't want a sentry (that case is optimized)
weak_ref x sen::function
= r, void when
    r = case weak_getref x of
        notfound = r when
                       u::pointer = __C::pure_expr_pointer;
                       __C::pointer_put_expr u x; // unsafe ptr to x (x's refcount not increased)
                       // r is a refcell containing the unsafe ptr and a list of weak_sentries
                       r = ref [u];
                       // setup sentry Box on x
                       pure_sentry (Box r s) x when
                            s = if pure_has_sentry x
                                then pure_get_sentry x
                                else nil;
                       end;
                   end;
               r = r; // TODO may want to u:ss = get r and prune expired ss
        end;
    x; // keep x from being collected until everything is set up
end if sen === ::void;
= r, expirer when
    r, expirer = case weak_getref x of
        notfound = r, expirer when
                       u::pointer = __C::pure_expr_pointer;
                       __C::pointer_put_expr u x; // unsafe ptr to x (x's refcount not increased)
                       // r is a refcell containing the unsafe ptr and a list of weak_sentries
                       senptr = ref sen;
                       expirer = \() -> put senptr void;
                       r = ref [u, senptr];
                       // setup sentry Box on x
                       pure_sentry (Box r s) x when
                            s = if pure_has_sentry x
                                then pure_get_sentry x
                                else nil;
                       end;
                   end;
               r = r, expirer when
                       senptr = ref sen;
                       expirer = \() -> put senptr void;
                       u:ss = get r;
                       // TODO may want to prune expired ss
                       put r (u:senptr:ss);
                   end;
        end;
    x; // keep x from being collected until everything is set up
end otherwise;


// high-level API

public wk_newdict wv_newdict wk_insert;
public wk_member wv_member wv_mmember wk_get wv_get wv_mget wv_insert;
public wk_delete wv_delete wv_mdelete wk_delete_val wv_delete_val wv_mdelete_val;
public wkv_apply;

private WVE;

// value comparisons ignore expirers
// note that all === values will be purged from wv-dicts at same time
(WVE r1 _) ::== (WVE r2 _) = r1 === r2;
(WVE r1 _) ::== r2 | r1 ::== (WVE r2 _) = r1 === r2;

wk_newdict K deleter = K dptr (sentrybase wd) when
    dptr = ref trees23::emptytree;
    wd, _ = weak_ref dptr void;
end with
    sentrybase wd r = case weak_get wd of
        {dptr} = put dptr (deleter (get dptr) r); // $$ ();
        _      = ();
    end;
end;

wv_newdict K deleter = K dptr (sentrybase wd) when
    dptr = ref trees23::emptytree;
    wd, _ = weak_ref dptr void;
end with
    sentrybase wd k r = case weak_get wd of
        {dptr} = put dptr (deleter (get dptr) (k=>r)); // $$ ();
        _      = ();
    end;
end;

wk_insert inserter dptr sb k v = () when
    d = get dptr;
    wk, expirer = weak_ref k sb;
    // harmless to let sentry run after wk has been deleted from d
    // so we don't bother keeping track of the expirer
    d = inserter d (wk=>v);
    put dptr d;
end;

wv_insert inserter dptr sb k v = () when
    d = get dptr;
    wv, expirer = weak_ref v (sb k);
    // we have to keep track of the expirer, else other k=>v pairs
    // with the same k may be deleted after this value is deleted from d
    d = inserter d (k=>WVE wv expirer);
    put dptr d;
end;

wk_delete deleter dptr k = () when
    d = get dptr;
    case weak_getref k of
        notfound  = (); // k has no box, won't be in dict
        kr = put dptr (deleter d kr);
    end;
end;

wv_delete popper dptr k = () when
    d = get dptr;
    d, WVE _ expirer = popper d k; // may throw out_of_bounds
    expirer ();
    put dptr d;
end;

wv_mdelete popper dptr k = () when
    d = get dptr;
    d, vs = popper d k; // may throw out_of_bounds
    do (\(WVE _ expirer) -> expirer ()) vs;
    put dptr d;
end;

wk_delete_val deleter dptr k v = () when
    d = get dptr;
    case weak_getref k of
        notfound  = (); // k has no box, won't be in dict
        kr = put dptr (deleter d (kr=>v));
    end;
end;

wv_delete_val popper dptr k v = () when
    d = get dptr;
    case weak_getref v of
        notfound  = (); // v has no box, won't be in dict
        vr = () when
            d, WVE _ expirer = popper d (k=>vr); // may throw out_of_bounds
            expirer ();
            put dptr d;
        end;
    end;
end;

wv_mdelete_val popper dptr k v = () when
    d = get dptr;
    case weak_getref v of
        notfound  = (); // v has no box, won't be in dict
        vr = () when
            d, vs = popper d (k=>vr); // may throw out_of_bounds
            do (\(WVE _ expirer) -> expirer ()) vs;
            put dptr d;
        end;
    end;
end;

wk_member tester dptr k = case weak_getref k of
    notfound  = 0; // k has no box, won't be in dict
    kr = tester (get dptr) kr;
end;

wv_member getter dptr k =
catch handler (case getter (get dptr) k of
    WVE vr _ = case weak_get vr of
        {_} = 1;
        _  = 0; // v is dying, but its weak_sentry hasn't yet purged this k=>v
        end;
end) with
    handler out_of_bounds = 0; // k not in d
    handler e = throw e;
end;

// special-case the wvm-dicts, check all members
wv_mmember getter dptr k =
catch handler (any f (getter (get dptr) k) with // may throw out_of_bounds
    f (WVE vr _) = case weak_get vr of
        {v} = 1;
        _   = 0; // v is dying, but its weak_sentry hasn't yet purged this k=>v
    end;
end) with
    handler out_of_bounds = 0; // k not in d
    handler e = throw e;
end;


wk_get getter dptr k = case weak_getref k of
    notfound = throw out_of_bounds; // k has no box, won't be in dict
    kr       = getter (get dptr) kr; // may throw out_of_bounds
end;

wv_get getter dptr k = case weak_get vr of
    {v} = v;
    _   = throw out_of_bounds; // v is dying, but its weak_sentry hasn't yet purged this k=>v
end when
    WVE vr _ = getter (get dptr) k; // may throw out_of_bounds
end;

// special-case the wvm-dicts, get all members
wv_mget getter dptr k = catmap f (getter (get dptr) k) with // may throw out_of_bounds
    f (WVE vr _) = case weak_get vr of
        {v} = [v];
        _   = []; // v is dying, but its weak_sentry hasn't yet purged this k=>v
    end;
end;

// uses private get from this weakdict:: namespace
wkv_apply f dptr = f (get dptr);


namespace;

// These should be considered private.
public WKDict WKMDict WVDict WVMDict WVHDict WVHMDict;


// TODO: do we need to define unions of these?
type wkdict   (WKDict _ _) | wkmdict   (WKMDict _ _)
   | wvdict   (WVDict _ _) | wvmdict   (WVMDict _ _)
   | wvhdict (WVHDict _ _) | wvhmdict (WVHMDict _ _);

// type checks
wkdictp   x = typep wkdict  x;
wkmdictp  x = typep wkmdict x;
wvdictp   x = typep wvdict  x;
wvmdictp  x = typep wvmdict x;
wvhdictp  x = typep wvhdict  x;
wvhmdictp x = typep wvhmdict x;


// create an empty dict
emptywkdict   = weakdict::wk_newdict  WKDict   trees23::hdeletek;
emptywkmdict  = weakdict::wk_newdict  WKMDict  trees23::mhdeleteka;
emptywvdict   = weakdict::wv_newdict  WVDict   trees23::deletekv;
// given how our sentries/expirers work, all === values are purged at same time
emptywvmdict  = weakdict::wv_newdict  WVMDict  trees23::mdeletekva;
emptywvhdict  = weakdict::wv_newdict  WVHDict  trees23::hdeletekv;
// given how our sentries/expirers work, all === values are purged at same time
emptywvhmdict = weakdict::wv_newdict  WVHMDict trees23::mhdeletekva;

// create a dict from a list
wkdict   kvs::rlist = foldl insert emptywkdict   kvs;
wkmdict  kvs::rlist = foldl insert emptywkmdict  kvs;
wvdict   kvs::rlist = foldl insert emptywvdict   kvs;
wvmdict  kvs::rlist = foldl insert emptywvmdict  kvs;
wvhdict  kvs::rlist = foldl insert emptywvhdict  kvs;
wvhmdict kvs::rlist = foldl insert emptywvhmdict kvs;

// create a dict from a list of keys and a constant value
mkwkdict   v ks::rlist = wkdict   (zipwith (=>) ks (repeaten (#xs) v));
mkwkmdict  v ks::rlist = wkmdict  (zipwith (=>) ks (repeaten (#xs) v));
mkwvdict   v ks::rlist = wvdict   (zipwith (=>) ks (repeaten (#xs) v));
mkwvmdict  v ks::rlist = wvmdict  (zipwith (=>) ks (repeaten (#xs) v));
mkwvhdict  v ks::rlist = wvhdict  (zipwith (=>) ks (repeaten (#xs) v));
mkwvhmdict v ks::rlist = wvhmdict (zipwith (=>) ks (repeaten (#xs) v));


// insert a member
insert w@(WKDict   dptr sb) (k=>v) = weakdict::wk_insert trees23::hinsertk  dptr sb k v $$ w;
insert w@(WKMDict  dptr sb) (k=>v) = weakdict::wk_insert trees23::mhinsertk dptr sb k v $$ w;
insert w@(WVDict   dptr sb) (k=>v) = weakdict::wv_insert trees23::insertk   dptr sb k v $$ w;
insert w@(WVMDict  dptr sb) (k=>v) = weakdict::wv_insert trees23::minsertk  dptr sb k v $$ w;
insert w@(WVHDict  dptr sb) (k=>v) = weakdict::wv_insert trees23::hinsertk  dptr sb k v $$ w;
insert w@(WVHMDict dptr sb) (k=>v) = weakdict::wv_insert trees23::mhinsertk dptr sb k v $$ w;

// curried version of insert
update  w@(WKDict  _ _) k v | update  w@(WKMDict _ _) k v |
update  w@(WVDict  _ _) k v | update  w@(WVMDict _ _) k v |
update w@(WVHDict  _ _) k v | update w@(WVHMDict _ _) k v = insert w (k=>v);

// delete a member by key, deletes older of duplicate keys in mdicts
delete w@(WKDict   dptr _) k = weakdict::wk_delete  trees23::hdeletek   dptr k $$ w;
delete w@(WKMDict  dptr _) k = weakdict::wk_delete  trees23::mhdeleteko dptr k $$ w;
delete w@(WVDict   dptr _) k = weakdict::wv_delete  trees23::popk       dptr k $$ w;
delete w@(WVMDict  dptr _) k = weakdict::wv_delete  trees23::mpopko     dptr k $$ w;
delete w@(WVHDict  dptr _) k = weakdict::wv_delete  trees23::hpopk      dptr k $$ w;
delete w@(WVHMDict dptr _) k = weakdict::wv_delete  trees23::mhpopko    dptr k $$ w;

// deletes newer of duplicate keys in mdicts
delete_new w@(WKDict   dptr _) k = weakdict::wk_delete  trees23::hdeletek   dptr k $$ w;
delete_new w@(WKMDict  dptr _) k = weakdict::wk_delete  trees23::mhdeletekn dptr k $$ w;
delete_new w@(WVDict   dptr _) k = weakdict::wv_delete  trees23::popk       dptr k $$ w;
delete_new w@(WVMDict  dptr _) k = weakdict::wv_delete  trees23::mpopkn     dptr k $$ w;
delete_new w@(WVHDict  dptr _) k = weakdict::wv_delete  trees23::hpopk      dptr k $$ w;
delete_new w@(WVHMDict dptr _) k = weakdict::wv_delete  trees23::mhpopkn    dptr k $$ w;

/*
// delete all instances of a given key
// TODO mpopka and mhpopka not yet defined
delete_all w@(WKDict   dptr _) k = weakdict::wk_delete  trees23::hdeletek   dptr k $$ w;
delete_all w@(WKMDict  dptr _) k = weakdict::wk_delete  trees23::mhdeleteka dptr k $$ w;
delete_all w@(WVDict   dptr _) k = weakdict::wv_delete  trees23::popk       dptr k $$ w;
delete_all w@(WVMDict  dptr _) k = weakdict::wv_mdelete trees23::mpopka     dptr k $$ w;
delete_all w@(WVHDict  dptr _) k = weakdict::wv_delete  trees23::hpopk      dptr k $$ w;
delete_all w@(WVHMDict dptr _) k = weakdict::wv_mdelete trees23::mhpopka    dptr k $$ w;
*/

// delete a member by key=>val
delete_val w@(WKDict   dptr _) (k=>v) = weakdict::wk_delete_val  trees23::hdeletekv   dptr k v $$ w;
// uses mhdeletekva
delete_val w@(WKMDict  dptr _) (k=>v) = weakdict::wk_delete_val  trees23::mhdeletekva dptr k v $$ w;
delete_val w@(WVDict   dptr _) (k=>v) = weakdict::wv_delete_val  trees23::popkv    dptr k v $$ w;
// uses mpop/deletekva (this is necessary given how our sentries/expirers work)
delete_val w@(WVMDict  dptr _) (k=>v) = weakdict::wv_mdelete_val trees23::mpopkva  dptr k v $$ w;
delete_val w@(WVHDict  dptr _) (k=>v) = weakdict::wv_delete_val  trees23::hpopkv   dptr k v $$ w;
// uses mhpop/deletekva (this is necessary given how our sentries/expirers work)
delete_val w@(WVHMDict dptr _) (k=>v) = weakdict::wv_mdelete_val trees23::mhpopkva dptr k v $$ w;


// membership test
member (WKDict   dptr _) k = weakdict::wk_member  trees23::hmemberk dptr k;
member (WKMDict  dptr _) k = weakdict::wk_member  trees23::hmemberk dptr k; // there are no m[h]memberk
member (WVDict   dptr _) k = weakdict::wv_member  trees23::getk     dptr k;
member (WVMDict  dptr _) k = weakdict::wv_mmember trees23::mgetk    dptr k;
member (WVHDict  dptr _) k = weakdict::wv_member  trees23::hgetk    dptr k;
member (WVHMDict dptr _) k = weakdict::wv_mmember trees23::mhgetk   dptr k;

// get a value by key
(WKDict   dptr _)!k = weakdict::wk_get  trees23::hgetk   dptr k;
// TODO get old-only, new-only?
(WKMDict  dptr _)!k = weakdict::wk_get  trees23::mhgetk  dptr k;
(WVDict   dptr _)!k = weakdict::wv_get  trees23::getk    dptr k;
// TODO get old-only, new-only?
(WVMDict  dptr _)!k = weakdict::wv_mget trees23::mgetk   dptr k;
(WVHDict  dptr _)!k = weakdict::wv_get  trees23::hgetk   dptr k;
// TODO get old-only, new-only?
(WVHMDict dptr _)!k = weakdict::wv_mget trees23::mhgetk  dptr k;

// I'm not sure the size and iteration methods should be exposed
// In any case, they should be regarded as volatile: liable to change
// at any time, even while being computed
// Even if Pure's current GC happens to be friendlier than that.
// Exposing them for now to help test.

#(WKDict   dptr _) = weakdict::wkv_apply trees23::hsize dptr; // h- and m- are same
#(WKMDict  dptr _) = weakdict::wkv_apply trees23::hsize dptr; // there are no mhsize
#(WVDict   dptr _) = weakdict::wkv_apply trees23::size  dptr;
#(WVMDict  dptr _) = weakdict::wkv_apply trees23::msize dptr;
#(WVHDict  dptr _) = weakdict::wkv_apply trees23::hsize dptr;
#(WVHMDict dptr _) = weakdict::wkv_apply trees23::hsize dptr; // there are no mhsize

null (WKDict   dptr _) = weakdict::wkv_apply trees23::null dptr;
null (WKMDict  dptr _) = weakdict::wkv_apply trees23::null dptr;
null (WVDict   dptr _) = weakdict::wkv_apply trees23::null dptr;
null (WVMDict  dptr _) = weakdict::wkv_apply trees23::null dptr;
null (WVHDict  dptr _) = weakdict::wkv_apply trees23::null dptr;
null (WVHMDict dptr _) = weakdict::wkv_apply trees23::null dptr;

members (WKDict   dptr _) = weakdict::wkv_apply trees23::hmembers dptr; // h- and m- are same
members (WKMDict  dptr _) = weakdict::wkv_apply trees23::hmembers dptr; // there are no mhmembers
members (WVDict   dptr _) = weakdict::wkv_apply trees23::members  dptr;
members (WVMDict  dptr _) = weakdict::wkv_apply trees23::mmembers dptr;
members (WVHDict  dptr _) = weakdict::wkv_apply trees23::hmembers dptr;
members (WVHMDict dptr _) = weakdict::wkv_apply trees23::hmembers dptr; // there are no mhmembers

keys (WKDict   dptr _) = weakdict::wkv_apply trees23::hkeys dptr; // h- and m- are same
keys (WKMDict  dptr _) = weakdict::wkv_apply trees23::hkeys dptr; // there are no mhmembers
keys (WVDict   dptr _) = weakdict::wkv_apply trees23::keys  dptr;
keys (WVMDict  dptr _) = weakdict::wkv_apply trees23::mkeys dptr;
keys (WVHDict  dptr _) = weakdict::wkv_apply trees23::hkeys dptr;
keys (WVHMDict dptr _) = weakdict::wkv_apply trees23::hkeys dptr; // there are no mhmembers

vals (WKDict   dptr _) = weakdict::wkv_apply trees23::hvals dptr; // h- and m- are same
vals (WKMDict  dptr _) = weakdict::wkv_apply trees23::hvals dptr; // there are no mhmembers
vals (WVDict   dptr _) = weakdict::wkv_apply trees23::vals  dptr;
vals (WVMDict  dptr _) = weakdict::wkv_apply trees23::mvals dptr;
vals (WVHDict  dptr _) = weakdict::wkv_apply trees23::hvals dptr;
vals (WVHMDict dptr _) = weakdict::wkv_apply trees23::hvals dptr; // there are no mhmembers




/*
wk  -->  h
wkm --> mh

wv  -->  0-k
wvh -->  h
wvm -->  m
wvhm--> mh


[m]size [m]foldl [m]foldl1 [m]foldr [m]foldr1 [m]members [m]keys [m]vals;
[m]first [m]last [m]rmfirst [m]rmlast [m]popfirst [m]poplast;
// the hsize..hpoplast methods === the m- ones; no mh-version

[h]memberk -- no m-version

[h]insertk
m[h]insertk

[h]deletek [h]popk
m[h]deleteko ; m[h]popko
m[h]deletekn ; m[h]popkn // == h{delete,pop}k

[h]deletekv
m[h]deletekva = delete all matching kv
m[h]deletekvo = m[h]deletekv
m[h]deletekvn

m[h]deleteka // == deletek

[h]getk
m[h]getk = list all members
m[h]getko
m[h]getkn




list d::xdict = members d;

// get the first and last member
first (Dict   d) = avl::first  d;
first (MDict  d) = avl::mfirst d;
last  (Dict   d) = avl::last   d;
last  (MDict  d) = avl::mlast  d;
first (HDict  d) = avl::hfirst d;
first (HMDict d) = avl::hfirst d;
last  (HDict  d) = avl::hlast  d;
last  (HMDict d) = avl::hlast  d;

// remove the first and last member
rmfirst (Dict   d) = Dict   (avl::rmfirst  d);
rmlast  (Dict   d) = Dict   (avl::rmlast   d);
rmfirst (MDict  d) = MDict  (avl::mrmfirst d);
rmlast  (MDict  d) = MDict  (avl::mrmlast  d);
rmfirst (HDict  d) = HDict  (avl::hrmfirst d);
rmlast  (HDict  d) = HDict  (avl::hrmlast  d);
rmfirst (HMDict d) = HMDict (avl::hrmfirst d);
rmlast  (HMDict d) = HMDict (avl::hrmlast  d);


// conversions between the different dictionary types
public members;
dict d@(Dict _) | hdict d@(HDict _) | mdict d@(MDict _) |
  hmdict d@(HMDict _) = d;
dict   d::xdict = dict   (members d);
hdict  d::xdict = hdict  (members d);
mdict  d::xdict = mdict  (members d);
hmdict d::xdict = hmdict (members d);

// comparisons
d1@(Dict _)   == d2@(Dict _)   = cmp (members d1) (members d2) with
  /- This case is optimized so that we only need a single traversal of the
     member lists which can be done in linear time. Also note that keys are
     compared for equality in the sense that two keys are equal if neither is
     less than the other, whereas values are compared for proper equality (==)
     if it is defined, falling back to (===) otherwise. -/
  cmp [] [] = 1;
  cmp (x:xs) [] = 0;
  cmp [] (x:xs) = 0;
  cmp ((xk=>xv):xs) ((yk=>yv):ys) =
    ~(xk<yk || yk<xk) && eq xv yv && cmp xs ys;
  eq u v = case u==v of res::int = res; _ = u===v end;
end;
d1@(MDict _)  == d2@(MDict _)  |
d1@(HDict _)  == d2@(HDict _)  |
d1@(HMDict _) == d2@(HMDict _) = d1 <= d2 && d2 <= d1;

d1@(Dict _)   ~= d2@(Dict _)   |
d1@(MDict _)  ~= d2@(MDict _)  |
d1@(HDict _)  ~= d2@(HDict _)  |
d1@(HMDict _) ~= d2@(HMDict _) = ~(d1 == d2);

d1@(Dict _)   <= d2@(Dict _)   = cmp (members d1) (members d2) with
  /- Again, this case is optimized so that we only need a single traversal of
     the member lists. Also note that the member lists are ordered by key, so
     that we can use a kind of subset check for two ordered sequences which
     can still be done in linear time. -/
  cmp [] [] = 1;
  cmp (x:xs) [] = 0;
  cmp [] (x:xs) = 1;
  cmp xs1@((xk=>xv):xs) ((yk=>yv):ys)
  = 0 if xk<yk;
  = cmp xs1 ys if yk<xk;
  = eq xv yv && cmp xs ys;
  eq u v = case u==v of res::int = res; _ = u===v end;
end;
d1@(MDict _)  <= d2@(MDict _)  |
d1@(HDict _)  <= d2@(HDict _)  |
d1@(HMDict _) <= d2@(HMDict _) = null (d1 - d2);

d1@(Dict _)   >= d2@(Dict _)   = d2 <= d1;
d1@(MDict _)  >= d2@(MDict _)  |
d1@(HDict _)  >= d2@(HDict _)  |
d1@(HMDict _) >= d2@(HMDict _) = null (d2 - d1);

d1@(Dict _)   <  d2@(Dict _)   |
d1@(MDict _)  <  d2@(MDict _)  |
d1@(HDict _)  <  d2@(HDict _)  |
d1@(HMDict _) <  d2@(HMDict _) = d1 <= d2 && ~(d1 >= d2);

d1@(Dict _)   >  d2@(Dict _)   |
d1@(MDict _)  >  d2@(MDict _)  |
d1@(HDict _)  >  d2@(HDict _)  |
d1@(HMDict _) >  d2@(HMDict _) = d1 >= d2 && ~(d1 <= d2);

// sum, difference, intersection
d1@(Dict _)   +  d2@(Dict _)   |
d1@(MDict _)  +  d2@(MDict _)  |
d1@(HDict _)  +  d2@(HDict _)  |
d1@(HMDict _) +  d2@(HMDict _) = foldl insert d1 (members d2);

d1@(Dict _)   -  d2@(Dict _)   |
d1@(MDict _)  -  d2@(MDict _)  |
d1@(HDict _)  -  d2@(HDict _)  |
d1@(HMDict _) -  d2@(HMDict _) = foldl delete_val d1 (members d2);

d1@(Dict _)   *  d2@(Dict _)   |
d1@(MDict _)  *  d2@(MDict _)  |
d1@(HDict _)  *  d2@(HDict _)  |
d1@(HMDict _) *  d2@(HMDict _) = d1 - (d1 - d2);

// automatic coercion rules

m1@(HMDict _) == m2 = m1 == hmdict m2 if xdictp m2;
m1 == m2@(HMDict _) = hmdict m1 == m2 if xdictp m1;
m1@(HDict _) == m2  = case m2 of
                        _@(MDict _) = hmdict m1 == hmdict m2;
                        _@(Dict _)  = m1 == hdict m2;
                      end if xdictp m2;
m1 == m2@(HDict _)  = case m1 of
                        _@(MDict _) = hmdict m1 == hmdict m2;
                        _@(Dict _)  = hdict m1 == m2;
                      end if xdictp m2;
m1@(MDict _) == m2@(Dict _) = m1 == mdict m2;
m1@(Dict _) == m2@(MDict _) = mdict m1 == m2;

m1@(HMDict _) ~= m2 = m1 ~= hmdict m2 if xdictp m2;
m1 ~= m2@(HMDict _) = hmdict m1 ~= m2 if xdictp m1;
m1@(HDict _) ~= m2  = case m2 of
                        _@(MDict _) = hmdict m1 ~= hmdict m2;
                        _@(Dict _)  = m1 ~= hdict m2;
                      end if xdictp m2;
m1 ~= m2@(HDict _)  = case m1 of
                        _@(MDict _) = hmdict m1 ~= hmdict m2;
                        _@(Dict _)  = hdict m1 ~= m2;
                      end if xdictp m2;
m1@(MDict _) ~= m2@(Dict _) = m1 ~= mdict m2;
m1@(Dict _) ~= m2@(MDict _) = mdict m1 ~= m2;

m1@(HMDict _) <= m2 = m1 <= hmdict m2 if xdictp m2;
m1 <= m2@(HMDict _) = hmdict m1 <= m2 if xdictp m1;
m1@(HDict _) <= m2  = case m2 of
                        _@(MDict _) = hmdict m1 <= hmdict m2;
                        _@(Dict _)  = m1 <= hdict m2;
                      end if xdictp m2;
m1 <= m2@(HDict _)  = case m1 of
                        _@(MDict _) = hmdict m1 <= hmdict m2;
                        _@(Dict _)  = hdict m1 <= m2;
                      end if xdictp m2;
m1@(MDict _) <= m2@(Dict _) = m1 <= mdict m2;
m1@(Dict _) <= m2@(MDict _) = mdict m1 <= m2;

m1@(HMDict _) >= m2 = m1 >= hmdict m2 if xdictp m2;
m1 >= m2@(HMDict _) = hmdict m1 >= m2 if xdictp m1;
m1@(HDict _) >= m2  = case m2 of
                        _@(MDict _) = hmdict m1 >= hmdict m2;
                        _@(Dict _)  = m1 >= hdict m2;
                      end if xdictp m2;
m1 >= m2@(HDict _)  = case m1 of
                        _@(MDict _) = hmdict m1 >= hmdict m2;
                        _@(Dict _)  = hdict m1 >= m2;
                      end if xdictp m2;
m1@(MDict _) >= m2@(Dict _) = m1 >= mdict m2;
m1@(Dict _) >= m2@(MDict _) = mdict m1 >= m2;

m1@(HMDict _) < m2 = m1 < hmdict m2 if xdictp m2;
m1 < m2@(HMDict _) = hmdict m1 < m2 if xdictp m1;
m1@(HDict _) < m2  = case m2 of
                       _@(MDict _) = hmdict m1 < hmdict m2;
                       _@(Dict _)  = m1 < hdict m2;
                     end if xdictp m2;
m1 < m2@(HDict _)  = case m1 of
                       _@(MDict _) = hmdict m1 < hmdict m2;
                       _@(Dict _)  = hdict m1 < m2;
                     end if xdictp m2;
m1@(MDict _) < m2@(Dict _) = m1 < mdict m2;
m1@(Dict _) < m2@(MDict _) = mdict m1 < m2;

m1@(HMDict _) > m2 = m1 > hmdict m2 if xdictp m2;
m1 > m2@(HMDict _) = hmdict m1 > m2 if xdictp m1;
m1@(HDict _) > m2  = case m2 of
                       _@(MDict _) = hmdict m1 > hmdict m2;
                       _@(Dict _)  = m1 > hdict m2;
                     end if xdictp m2;
m1 > m2@(HDict _)  = case m1 of
                       _@(MDict _) = hmdict m1 > hmdict m2;
                       _@(Dict _)  = hdict m1 > m2;
                     end if xdictp m2;
m1@(MDict _) > m2@(Dict _) = m1 > mdict m2;
m1@(Dict _) > m2@(MDict _) = mdict m1 > m2;

m1@(HMDict _) + m2 = m1 + hmdict m2 if xdictp m2;
m1 + m2@(HMDict _) = hmdict m1 + m2 if xdictp m1;
m1@(HDict _) + m2  = case m2 of
                       _@(MDict _) = hmdict m1 + hmdict m2;
                       _@(Dict _)  = m1 + hdict m2;
                     end if xdictp m2;
m1 + m2@(HDict _)  = case m1 of
                       _@(MDict _) = hmdict m1 + hmdict m2;
                       _@(Dict _)  = hdict m1 + m2;
                     end if xdictp m2;
m1@(MDict _) + m2@(Dict _) = m1 + mdict m2;
m1@(Dict _) + m2@(MDict _) = mdict m1 + m2;

m1@(HMDict _) - m2 = m1 - hmdict m2 if xdictp m2;
m1 - m2@(HMDict _) = hmdict m1 - m2 if xdictp m1;
m1@(HDict _) - m2  = case m2 of
                       _@(MDict _) = hmdict m1 - hmdict m2;
                       _@(Dict _)  = m1 - hdict m2;
                     end if xdictp m2;
m1 - m2@(HDict _)  = case m1 of
                       _@(MDict _) = hmdict m1 - hmdict m2;
                       _@(Dict _)  = hdict m1 - m2;
                     end if xdictp m2;
m1@(MDict _) - m2@(Dict _) = m1 - mdict m2;
m1@(Dict _) - m2@(MDict _) = mdict m1 - m2;

m1@(HMDict _) * m2 = m1 * hmdict m2 if xdictp m2;
m1 * m2@(HMDict _) = hmdict m1 * m2 if xdictp m1;
m1@(HDict _) * m2  = case m2 of
                       _@(MDict _) = hmdict m1 * hmdict m2;
                       _@(Dict _)  = m1 * hdict m2;
                     end if xdictp m2;
m1 * m2@(HDict _)  = case m1 of
                       _@(MDict _) = hmdict m1 * hmdict m2;
                       _@(Dict _)  = hdict m1 * m2;
                     end if xdictp m2;
m1@(MDict _) * m2@(Dict _) = m1 * mdict m2;
m1@(Dict _) * m2@(MDict _) = mdict m1 * m2;

*/
