/*
  weakdict.pure

    Low-level conventions
    ---------------------
    * original object x gets a sentry box (this can chain a regular sentry)
    * the box contains a refcell r that keeps a list of which weak_ref
      sentries have been associated with x; r also contains an unsafe ptr to x
      (we keep that always at the head of the list)
    * clients can use r as a weakref to x; it will live longer than x does
      but won't keep x alive. When x starts to die, r will no longer deref to
      x; however x will in fact still be alive until all its weak_sentries
      have run (and after them, its ordinary sentries).

    High-level weak-key and weak-value dictionaries are guided by Python's
    implementation of these, and my experience working with Lua's weak tables.
*/


using trees23;

// we need to overwrite the stdlib definitions of these
public _sentry _clear_sentry _get_sentry _cookedp _cooked;

// global exception
public bad_pointer_value;


// for our constructors and private methods
namespace weakdict;

private Box weak_get weak_getref weak_ref;
private nonfix notfound nil;

private extern expr* pure_sentry(expr*,expr*); //  = sentry; // IMPURE!
private extern expr* pure_clear_sentry(expr*); // = clear_sentry; // IMPURE!
private extern expr* pure_get_sentry(expr*); // = get_sentry;
private extern bool  pure_has_sentry(expr*); // = cookedp;

// to cooperate with existing sentry framework
// our sentries are a box that can chain a regular sentry
// and the ::_get_sentry etc methods ignore our box

::_sentry f x = if pure_has_sentry x then
    case pure_get_sentry x of
        Box r _ = pure_sentry (Box r f) x;
        _ = pure_sentry f x;
    end else pure_sentry f x;

::_clear_sentry x = if pure_has_sentry x then
    case pure_get_sentry x of
        Box r nil = x;
        Box r _ = pure_sentry (Box r nil) x;
        _ = pure_clear_sentry x;
    end else x;

::_get_sentry x = s if s ~== nil when
    s = if pure_has_sentry x then
        case pure_get_sentry x of
            Box r s = s;
            s = s;
        end else nil;
end;

::_cookedp x = if pure_has_sentry x then
    case pure_get_sentry x of
        Box r nil = 0;
        _ = 1;
    end else 0;

::_cooked p::pointer = ::_sentry free p;


// We need our own version of these, at least until our _sentry
// methods are moved to stdlib, because our refcells won't typecheck as being refp.
// (Some of our refcells won't typecheck even afterwards.)

private ref unref put get;

ref x = __C::pointer_put_expr r (__C::pure_new x) $$
        _sentry unref r when r::pointer = __C::pure_expr_pointer end;

unref r::pointer = __C::pure_free (__C::pointer_get_expr r) $$
                   _clear_sentry r;

put r::pointer x = __C::pure_free (__C::pointer_get_expr r) $$
                   __C::pointer_put_expr r (__C::pure_new x) $$ x;

get r::pointer = __C::pointer_get_expr r;




// x is dying
Box r s x = case s of
    nil = handle r x;
    s   = handle r x $$ s x;
end with
    handle r x = () when
                    // do we need to use pure_ref x here...?
                    u:ss = get r;
                    // assert(u is still unsafe ptr, not notfound)
                    // now that x is dying, no one can look it up via r anymore
                    put r [notfound];
                    // run the weak_ref sentries
                    // we give them the weakref as an argument but not x
                    // so there's no danger of them reviving x
                    do ($ r) ss;
                    // do we need to use pure_unref x here ...?
               end;
end;

/*
// is there a way to get x's address without allocating a new pointer?
weak_addr x = xaddr when
    u::pointer = __C::pure_expr_pointer;
    __C::pointer_put_expr u x;
    xaddr = get_pointer u;
end;

let H = hashtable::emptyhashtable; // global hashtable of (addr=>weak_ref)s

lookup xaddr = hashtable::getk H xaddr notfound;
/-
    lookup xaddr = hashtable::eachk H f xaddr notfound with
        f (_=>r) = if alive r then r else 0; // 0 means continue
    end;
    alive r = u ~== NULL when u:_ = __C::pointer_get_expr r end;
*/


// lookup x from weak_ref
weak_get r = case get r of
    u:_ = {} if u === notfound;
        = '{x} when
            x = get u; // deref the unsafe ptr
          end otherwise;
end;

// lookup existing weak_ref from x
weak_getref x = if ~pure_has_sentry x then notfound
               else case pure_get_sentry x of
                    Box r _ = r;
                    _ = notfound;
               end;

// make new weak_ref for x (with optional sentry)
// use void if you don't want a sentry (that case is optimized)
weak_ref x sen::function = r when
    pure_new x; // lock x from being collected until everything is set up
                // might I use pure_ref instead?
    r = case weak_getref x of
        notfound = r when
                       u::pointer = __C::pure_expr_pointer;
                       __C::pointer_put_expr u x; // unsafe ptr to x (x's refcount not increased)
                       // r is a refcell containing the unsafe ptr and a list of weak_sentries
                       r = ref (u:ss) when
                            ss = if sen === ::void
                                 then []
                                 else [sen];
                           end;
                       // setup sentry Box on x
                       pure_sentry (Box r s) x when
                            s = if pure_has_sentry x
                                then pure_get_sentry x
                                else nil;
                       end;
                   end;
               r = r if sen === ::void;
                 = put r (u:sen:ss) $$ r when // add sentry
                       u:ss = get r;
                   end otherwise;
        end;
    pure_free x; // might I use pure_unref instead?
end;

// high-level API

public wk_newdict wv_newdict wk_insert wk_member wv_member wk_get wv_get;
public wv_insert wk_delete wv_delete wk_delete_val wv_delete_val;
public wkv_apply;

using system;

wk_newdict K deleter = K dptr (sentrybase wd) when
    dptr = ref trees23::emptytree;
    wd = weak_ref dptr void;
end with
    sentrybase wd r = case weak_get wd of
        {dptr} = put dptr (deleter (get dptr) r) $$ ();
        _      = ();
    end;
end;

wv_newdict K deleter = K dptr (sentrybase wd) when
    dptr = ref trees23::emptytree;
    wd = weak_ref dptr void;
end with
    sentrybase wd k _ = case weak_get wd of
        {dptr} = put dptr (deleter (get dptr) k) $$ ();
        _      = ();
    end;
end;

wk_insert inserter dptr sb k v = () when
    d = get dptr;
    d = inserter d (weak_ref k sb=>v);
    put dptr d;
end;

wv_insert inserter dptr sb k v = () when
    d = get dptr;
    d = inserter d (k=>weak_ref v (sb k));
    put dptr d;
end;

wk_delete deleter dptr k = () when
    d = get dptr;
    case weak_getref k of
        notfound  = (); // k has no box, won't be in dict
        kr = put dptr (deleter d kr);
    end;
end;

wv_delete deleter dptr k = () when
    d = get dptr;
    put dptr (deleter d k);
end;

wk_delete_val deleter dptr k v = () when
    d = get dptr;
    case weak_getref k of
        notfound  = (); // k has no box, won't be in dict
        kr = put dptr (deleter d kr v);
    end;
end;

wv_delete_val deleter dptr k v = () when
    d = get dptr;
    case weak_getref v of
        notfound  = (); // v has no box, won't be in dict
        vr = put dptr (deleter d k vr);
    end;
end;


wk_member tester dptr k = case weak_getref k of
    notfound  = 0; // k has no box, won't be in dict
    kr = tester (get dptr) kr;
end;

wv_member getter dptr k =
catch handler (case getter (get dptr) k of
    vr = case weak_get vr of
        {_} = 1;
        _  = 0; // v is dying, but its weak_sentry hasn't yet purged this k=>v
        end;
end) with
    handler out_of_bounds = 0; // k not in d
    handler e = throw e;
end;

wk_get getter dptr k = case weak_getref k of
    notfound = throw out_of_bounds; // k has no box, won't be in dict
    kr       = getter (get dptr) kr;
end;

wv_get getter dptr k = case weak_get vr of
    {v} = v;
    _   = throw out_of_bounds; // v is dying, but its weak_sentry hasn't yet purged this k=>v
end when
    vr = getter (get dptr) k;
end;

wv_mget getter dptr k = catmap f (getter (get dptr) k) with
    f vr = case weak_get vr of
        {v} = [v];
        _   = []; // v is dying, but its weak_sentry hasn't yet purged this k=>v
    end;
end;

// uses private get from this weakdict:: namespace
wkv_apply f dptr = f (get dptr);


namespace;

// These should be considered private.
public WKDict WKMDict WVDict WVMDict WVHDict WVHMDict;


// TODO: do we need to define unions of these?
type wkdict   (WKDict _ _) | wkmdict   (WKMDict _ _)
   | wvdict   (WVDict _ _) | wvmdict   (WVMDict _ _)
   | wvhdict (WVHDict _ _) | wvhmdict (WVHMDict _ _);

// type checks
wkdictp   x = typep wkdict  x;
wkmdictp  x = typep wkmdict x;
wvdictp   x = typep wvdict  x;
wvmdictp  x = typep wvmdict x;
wvhdictp  x = typep wvhdict  x;
wvhmdictp x = typep wvhmdict x;


// create an empty dict
emptywkdict   = weakdict::wk_newdict WKDict   trees23::hdeletek;
emptywkmdict  = weakdict::wk_newdict WKMDict  trees23::mhdeletek;
emptywvdict   = weakdict::wv_newdict WVDict   trees23::deletek;
emptywvmdict  = weakdict::wv_newdict WVMDict  trees23::mdeletek;
emptywvhdict  = weakdict::wv_newdict WVHDict  trees23::hdeletek;
emptywvhmdict = weakdict::wv_newdict WVHMDict trees23::mhdeletek;

// create a dict from a list
wkdict   kvs::rlist = foldl insert emptywkdict   kvs;
wkmdict  kvs::rlist = foldl insert emptywkmdict  kvs;
wvdict   kvs::rlist = foldl insert emptywvdict   kvs;
wvmdict  kvs::rlist = foldl insert emptywvmdict  kvs;
wvhdict  kvs::rlist = foldl insert emptywvhdict  kvs;
wvhmdict kvs::rlist = foldl insert emptywvhmdict kvs;

// create a dict from a list of keys and a constant value
mkwkdict   v ks::rlist = wkdict   (zipwith (=>) ks (repeaten (#xs) v));
mkwkmdict  v ks::rlist = wkmdict  (zipwith (=>) ks (repeaten (#xs) v));
mkwvdict   v ks::rlist = wvdict   (zipwith (=>) ks (repeaten (#xs) v));
mkwvmdict  v ks::rlist = wvmdict  (zipwith (=>) ks (repeaten (#xs) v));
mkwvhdict  v ks::rlist = wvhdict  (zipwith (=>) ks (repeaten (#xs) v));
mkwvhmdict v ks::rlist = wvhmdict (zipwith (=>) ks (repeaten (#xs) v));


// insert a member
insert w@(WKDict   dptr sb) (k=>v) = weakdict::wk_insert trees23::hinsertk  dptr sb k v $$ w;
insert w@(WKMDict  dptr sb) (k=>v) = weakdict::wk_insert trees23::mhinsertk dptr sb k v $$ w;
insert w@(WVDict   dptr sb) (k=>v) = weakdict::wv_insert trees23::insertk   dptr sb k v $$ w;
insert w@(WVMDict  dptr sb) (k=>v) = weakdict::wv_insert trees23::minsertk  dptr sb k v $$ w;
insert w@(WVHDict  dptr sb) (k=>v) = weakdict::wv_insert trees23::hinsertk  dptr sb k v $$ w;
insert w@(WVHMDict dptr sb) (k=>v) = weakdict::wv_insert trees23::mhinsertk dptr sb k v $$ w;

// curried version of insert
update  w@(WKDict  _ _) k v | update  w@(WKMDict _ _) k v |
update  w@(WVDict  _ _) k v | update  w@(WVMDict _ _) k v |
update w@(WVHDict  _ _) k v | update w@(WVHMDict _ _) k v = insert w (k=>v);

// delete a member by key
delete w@(WKDict   dptr _) k = weakdict::wk_delete trees23::hdeletek  dptr k $$ w;
delete w@(WKMDict  dptr _) k = weakdict::wk_delete trees23::mhdeletek dptr k $$ w;
delete w@(WVDict   dptr _) k = weakdict::wv_delete trees23::deletek   dptr k $$ w;
delete w@(WVMDict  dptr _) k = weakdict::wv_delete trees23::mdeletek  dptr k $$ w;
delete w@(WVHDict  dptr _) k = weakdict::wv_delete trees23::hdeletek  dptr k $$ w;
delete w@(WVHMDict dptr _) k = weakdict::wv_delete trees23::mhdeletek dptr k $$ w;


// delete a member by key=>val
delete_val w@(WKDict   dptr _) (k=>v) = weakdict::wk_delete_val trees23::hdeletekv  dptr k v $$ w;
delete_val w@(WKMDict  dptr _) (k=>v) = weakdict::wk_delete_val trees23::mhdeletekv dptr k v $$ w;
delete_val w@(WVDict   dptr _) (k=>v) = weakdict::wv_delete_val trees23::deletekv   dptr k v $$ w;
delete_val w@(WVMDict  dptr _) (k=>v) = weakdict::wv_delete_val trees23::mdeletekv  dptr k v $$ w;
delete_val w@(WVHDict  dptr _) (k=>v) = weakdict::wv_delete_val trees23::hdeletekv  dptr k v $$ w;
delete_val w@(WVHMDict dptr _) (k=>v) = weakdict::wv_delete_val trees23::mhdeletekv dptr k v $$ w;


// delete all instances of a given key
delete_all w@(WKDict   dptr _) k = weakdict::wk_delete trees23::hdeletek   dptr k $$ w;
delete_all w@(WKMDict  dptr _) k = weakdict::wk_delete trees23::mhdeleteka dptr k $$ w;
delete_all w@(WVDict   dptr _) k = weakdict::wv_delete trees23::deletek    dptr k $$ w;
delete_all w@(WVMDict  dptr _) k = weakdict::wv_delete trees23::mdeleteka  dptr k $$ w;
delete_all w@(WVHDict  dptr _) k = weakdict::wv_delete trees23::hdeletek   dptr k $$ w;
delete_all w@(WVHMDict dptr _) k = weakdict::wv_delete trees23::mhdeleteka dptr k $$ w;


// membership test
member (WKDict   dptr _) k = weakdict::wk_member trees23::hmemberk dptr k;
member (WKMDict  dptr _) k = weakdict::wk_member trees23::hmemberk dptr k;
member (WVDict   dptr _) k = weakdict::wv_member trees23::getk     dptr k;
member (WVMDict  dptr _) k = weakdict::wv_member trees23::mgetkn   dptr k;
member (WVHDict  dptr _) k = weakdict::wv_member trees23::hgetk    dptr k;
member (WVHMDict dptr _) k = weakdict::wv_member trees23::mhgetkn  dptr k;

// get a value by key
(WKDict   dptr _)!k = weakdict::wk_get  trees23::hgetk   dptr k;
(WKMDict  dptr _)!k = weakdict::wk_get  trees23::mhgetk  dptr k;
(WVDict   dptr _)!k = weakdict::wv_get  trees23::getk    dptr k;
(WVMDict  dptr _)!k = weakdict::wv_mget trees23::mgetk   dptr k;
(WVHDict  dptr _)!k = weakdict::wv_get  trees23::hgetk   dptr k;
(WVHMDict dptr _)!k = weakdict::wv_mget trees23::mhgetk  dptr k;

// I'm not sure the size and iteration methods should be exposed
// In any case, they should be regarded as volatile: liable to change
// at any time, even while being computed
// Even if Pure's current GC happens to be friendlier than that.

#(WKDict   dptr _) = weakdict::wkv_apply trees23::hsize dptr;
#(WKMDict  dptr _) = weakdict::wkv_apply trees23::hsize dptr;
#(WVDict   dptr _) = weakdict::wkv_apply trees23::size  dptr;
#(WVMDict  dptr _) = weakdict::wkv_apply trees23::msize dptr;
#(WVHDict  dptr _) = weakdict::wkv_apply trees23::hsize dptr;
#(WVHMDict dptr _) = weakdict::wkv_apply trees23::hsize dptr;

null (WKDict   dptr _) = weakdict::wkv_apply trees23::null dptr;
null (WKMDict  dptr _) = weakdict::wkv_apply trees23::null dptr;
null (WVDict   dptr _) = weakdict::wkv_apply trees23::null dptr;
null (WVMDict  dptr _) = weakdict::wkv_apply trees23::null dptr;
null (WVHDict  dptr _) = weakdict::wkv_apply trees23::null dptr;
null (WVHMDict dptr _) = weakdict::wkv_apply trees23::null dptr;

members (WKDict   dptr _) = weakdict::wkv_apply trees23::hmembers dptr;
members (WKMDict  dptr _) = weakdict::wkv_apply trees23::hmembers dptr;
members (WVDict   dptr _) = weakdict::wkv_apply trees23::members  dptr;
members (WVMDict  dptr _) = weakdict::wkv_apply trees23::mmembers dptr;
members (WVHDict  dptr _) = weakdict::wkv_apply trees23::hmembers dptr;
members (WVHMDict dptr _) = weakdict::wkv_apply trees23::hmembers dptr;

keys (WKDict   dptr _) = weakdict::wkv_apply trees23::hkeys dptr;
keys (WKMDict  dptr _) = weakdict::wkv_apply trees23::hkeys dptr;
keys (WVDict   dptr _) = weakdict::wkv_apply trees23::keys  dptr;
keys (WVMDict  dptr _) = weakdict::wkv_apply trees23::mkeys dptr;
keys (WVHDict  dptr _) = weakdict::wkv_apply trees23::hkeys dptr;
keys (WVHMDict dptr _) = weakdict::wkv_apply trees23::hkeys dptr;

vals (WKDict   dptr _) = weakdict::wkv_apply trees23::hvals dptr;
vals (WKMDict  dptr _) = weakdict::wkv_apply trees23::hvals dptr;
vals (WVDict   dptr _) = weakdict::wkv_apply trees23::vals  dptr;
vals (WVMDict  dptr _) = weakdict::wkv_apply trees23::mvals dptr;
vals (WVHDict  dptr _) = weakdict::wkv_apply trees23::hvals dptr;
vals (WVHMDict dptr _) = weakdict::wkv_apply trees23::hvals dptr;


/*

list d::xdict = members d;

// get the first and last member
first (Dict   d) = avl::first  d;
first (MDict  d) = avl::mfirst d;
last  (Dict   d) = avl::last   d;
last  (MDict  d) = avl::mlast  d;
first (HDict  d) = avl::hfirst d;
first (HMDict d) = avl::hfirst d;
last  (HDict  d) = avl::hlast  d;
last  (HMDict d) = avl::hlast  d;

// remove the first and last member
rmfirst (Dict   d) = Dict   (avl::rmfirst  d);
rmlast  (Dict   d) = Dict   (avl::rmlast   d);
rmfirst (MDict  d) = MDict  (avl::mrmfirst d);
rmlast  (MDict  d) = MDict  (avl::mrmlast  d);
rmfirst (HDict  d) = HDict  (avl::hrmfirst d);
rmlast  (HDict  d) = HDict  (avl::hrmlast  d);
rmfirst (HMDict d) = HMDict (avl::hrmfirst d);
rmlast  (HMDict d) = HMDict (avl::hrmlast  d);


// conversions between the different dictionary types
public members;
dict d@(Dict _) | hdict d@(HDict _) | mdict d@(MDict _) |
  hmdict d@(HMDict _) = d;
dict   d::xdict = dict   (members d);
hdict  d::xdict = hdict  (members d);
mdict  d::xdict = mdict  (members d);
hmdict d::xdict = hmdict (members d);

// comparisons
d1@(Dict _)   == d2@(Dict _)   = cmp (members d1) (members d2) with
  /- This case is optimized so that we only need a single traversal of the
     member lists which can be done in linear time. Also note that keys are
     compared for equality in the sense that two keys are equal if neither is
     less than the other, whereas values are compared for proper equality (==)
     if it is defined, falling back to (===) otherwise. -/
  cmp [] [] = 1;
  cmp (x:xs) [] = 0;
  cmp [] (x:xs) = 0;
  cmp ((xk=>xv):xs) ((yk=>yv):ys) =
    ~(xk<yk || yk<xk) && eq xv yv && cmp xs ys;
  eq u v = case u==v of res::int = res; _ = u===v end;
end;
d1@(MDict _)  == d2@(MDict _)  |
d1@(HDict _)  == d2@(HDict _)  |
d1@(HMDict _) == d2@(HMDict _) = d1 <= d2 && d2 <= d1;

d1@(Dict _)   ~= d2@(Dict _)   |
d1@(MDict _)  ~= d2@(MDict _)  |
d1@(HDict _)  ~= d2@(HDict _)  |
d1@(HMDict _) ~= d2@(HMDict _) = ~(d1 == d2);

d1@(Dict _)   <= d2@(Dict _)   = cmp (members d1) (members d2) with
  /- Again, this case is optimized so that we only need a single traversal of
     the member lists. Also note that the member lists are ordered by key, so
     that we can use a kind of subset check for two ordered sequences which
     can still be done in linear time. -/
  cmp [] [] = 1;
  cmp (x:xs) [] = 0;
  cmp [] (x:xs) = 1;
  cmp xs1@((xk=>xv):xs) ((yk=>yv):ys)
  = 0 if xk<yk;
  = cmp xs1 ys if yk<xk;
  = eq xv yv && cmp xs ys;
  eq u v = case u==v of res::int = res; _ = u===v end;
end;
d1@(MDict _)  <= d2@(MDict _)  |
d1@(HDict _)  <= d2@(HDict _)  |
d1@(HMDict _) <= d2@(HMDict _) = null (d1 - d2);

d1@(Dict _)   >= d2@(Dict _)   = d2 <= d1;
d1@(MDict _)  >= d2@(MDict _)  |
d1@(HDict _)  >= d2@(HDict _)  |
d1@(HMDict _) >= d2@(HMDict _) = null (d2 - d1);

d1@(Dict _)   <  d2@(Dict _)   |
d1@(MDict _)  <  d2@(MDict _)  |
d1@(HDict _)  <  d2@(HDict _)  |
d1@(HMDict _) <  d2@(HMDict _) = d1 <= d2 && ~(d1 >= d2);

d1@(Dict _)   >  d2@(Dict _)   |
d1@(MDict _)  >  d2@(MDict _)  |
d1@(HDict _)  >  d2@(HDict _)  |
d1@(HMDict _) >  d2@(HMDict _) = d1 >= d2 && ~(d1 <= d2);

// sum, difference, intersection
d1@(Dict _)   +  d2@(Dict _)   |
d1@(MDict _)  +  d2@(MDict _)  |
d1@(HDict _)  +  d2@(HDict _)  |
d1@(HMDict _) +  d2@(HMDict _) = foldl insert d1 (members d2);

d1@(Dict _)   -  d2@(Dict _)   |
d1@(MDict _)  -  d2@(MDict _)  |
d1@(HDict _)  -  d2@(HDict _)  |
d1@(HMDict _) -  d2@(HMDict _) = foldl delete_val d1 (members d2);

d1@(Dict _)   *  d2@(Dict _)   |
d1@(MDict _)  *  d2@(MDict _)  |
d1@(HDict _)  *  d2@(HDict _)  |
d1@(HMDict _) *  d2@(HMDict _) = d1 - (d1 - d2);

// automatic coercion rules

m1@(HMDict _) == m2 = m1 == hmdict m2 if xdictp m2;
m1 == m2@(HMDict _) = hmdict m1 == m2 if xdictp m1;
m1@(HDict _) == m2  = case m2 of
                        _@(MDict _) = hmdict m1 == hmdict m2;
                        _@(Dict _)  = m1 == hdict m2;
                      end if xdictp m2;
m1 == m2@(HDict _)  = case m1 of
                        _@(MDict _) = hmdict m1 == hmdict m2;
                        _@(Dict _)  = hdict m1 == m2;
                      end if xdictp m2;
m1@(MDict _) == m2@(Dict _) = m1 == mdict m2;
m1@(Dict _) == m2@(MDict _) = mdict m1 == m2;

m1@(HMDict _) ~= m2 = m1 ~= hmdict m2 if xdictp m2;
m1 ~= m2@(HMDict _) = hmdict m1 ~= m2 if xdictp m1;
m1@(HDict _) ~= m2  = case m2 of
                        _@(MDict _) = hmdict m1 ~= hmdict m2;
                        _@(Dict _)  = m1 ~= hdict m2;
                      end if xdictp m2;
m1 ~= m2@(HDict _)  = case m1 of
                        _@(MDict _) = hmdict m1 ~= hmdict m2;
                        _@(Dict _)  = hdict m1 ~= m2;
                      end if xdictp m2;
m1@(MDict _) ~= m2@(Dict _) = m1 ~= mdict m2;
m1@(Dict _) ~= m2@(MDict _) = mdict m1 ~= m2;

m1@(HMDict _) <= m2 = m1 <= hmdict m2 if xdictp m2;
m1 <= m2@(HMDict _) = hmdict m1 <= m2 if xdictp m1;
m1@(HDict _) <= m2  = case m2 of
                        _@(MDict _) = hmdict m1 <= hmdict m2;
                        _@(Dict _)  = m1 <= hdict m2;
                      end if xdictp m2;
m1 <= m2@(HDict _)  = case m1 of
                        _@(MDict _) = hmdict m1 <= hmdict m2;
                        _@(Dict _)  = hdict m1 <= m2;
                      end if xdictp m2;
m1@(MDict _) <= m2@(Dict _) = m1 <= mdict m2;
m1@(Dict _) <= m2@(MDict _) = mdict m1 <= m2;

m1@(HMDict _) >= m2 = m1 >= hmdict m2 if xdictp m2;
m1 >= m2@(HMDict _) = hmdict m1 >= m2 if xdictp m1;
m1@(HDict _) >= m2  = case m2 of
                        _@(MDict _) = hmdict m1 >= hmdict m2;
                        _@(Dict _)  = m1 >= hdict m2;
                      end if xdictp m2;
m1 >= m2@(HDict _)  = case m1 of
                        _@(MDict _) = hmdict m1 >= hmdict m2;
                        _@(Dict _)  = hdict m1 >= m2;
                      end if xdictp m2;
m1@(MDict _) >= m2@(Dict _) = m1 >= mdict m2;
m1@(Dict _) >= m2@(MDict _) = mdict m1 >= m2;

m1@(HMDict _) < m2 = m1 < hmdict m2 if xdictp m2;
m1 < m2@(HMDict _) = hmdict m1 < m2 if xdictp m1;
m1@(HDict _) < m2  = case m2 of
                       _@(MDict _) = hmdict m1 < hmdict m2;
                       _@(Dict _)  = m1 < hdict m2;
                     end if xdictp m2;
m1 < m2@(HDict _)  = case m1 of
                       _@(MDict _) = hmdict m1 < hmdict m2;
                       _@(Dict _)  = hdict m1 < m2;
                     end if xdictp m2;
m1@(MDict _) < m2@(Dict _) = m1 < mdict m2;
m1@(Dict _) < m2@(MDict _) = mdict m1 < m2;

m1@(HMDict _) > m2 = m1 > hmdict m2 if xdictp m2;
m1 > m2@(HMDict _) = hmdict m1 > m2 if xdictp m1;
m1@(HDict _) > m2  = case m2 of
                       _@(MDict _) = hmdict m1 > hmdict m2;
                       _@(Dict _)  = m1 > hdict m2;
                     end if xdictp m2;
m1 > m2@(HDict _)  = case m1 of
                       _@(MDict _) = hmdict m1 > hmdict m2;
                       _@(Dict _)  = hdict m1 > m2;
                     end if xdictp m2;
m1@(MDict _) > m2@(Dict _) = m1 > mdict m2;
m1@(Dict _) > m2@(MDict _) = mdict m1 > m2;

m1@(HMDict _) + m2 = m1 + hmdict m2 if xdictp m2;
m1 + m2@(HMDict _) = hmdict m1 + m2 if xdictp m1;
m1@(HDict _) + m2  = case m2 of
                       _@(MDict _) = hmdict m1 + hmdict m2;
                       _@(Dict _)  = m1 + hdict m2;
                     end if xdictp m2;
m1 + m2@(HDict _)  = case m1 of
                       _@(MDict _) = hmdict m1 + hmdict m2;
                       _@(Dict _)  = hdict m1 + m2;
                     end if xdictp m2;
m1@(MDict _) + m2@(Dict _) = m1 + mdict m2;
m1@(Dict _) + m2@(MDict _) = mdict m1 + m2;

m1@(HMDict _) - m2 = m1 - hmdict m2 if xdictp m2;
m1 - m2@(HMDict _) = hmdict m1 - m2 if xdictp m1;
m1@(HDict _) - m2  = case m2 of
                       _@(MDict _) = hmdict m1 - hmdict m2;
                       _@(Dict _)  = m1 - hdict m2;
                     end if xdictp m2;
m1 - m2@(HDict _)  = case m1 of
                       _@(MDict _) = hmdict m1 - hmdict m2;
                       _@(Dict _)  = hdict m1 - m2;
                     end if xdictp m2;
m1@(MDict _) - m2@(Dict _) = m1 - mdict m2;
m1@(Dict _) - m2@(MDict _) = mdict m1 - m2;

m1@(HMDict _) * m2 = m1 * hmdict m2 if xdictp m2;
m1 * m2@(HMDict _) = hmdict m1 * m2 if xdictp m1;
m1@(HDict _) * m2  = case m2 of
                       _@(MDict _) = hmdict m1 * hmdict m2;
                       _@(Dict _)  = m1 * hdict m2;
                     end if xdictp m2;
m1 * m2@(HDict _)  = case m1 of
                       _@(MDict _) = hmdict m1 * hmdict m2;
                       _@(Dict _)  = hdict m1 * m2;
                     end if xdictp m2;
m1@(MDict _) * m2@(Dict _) = m1 * mdict m2;
m1@(Dict _) * m2@(MDict _) = mdict m1 * m2;

*/
