/*
"Natural" or "adaptive" bottom-up merge sort.

Optimized to exploit existing runs of ascending/descending elements,
to consume at most O(log n) levels of its working stack,
and to be mostly tail-recursive, while minimizing how often
sorted and merged runs need to be reversed.

Inspired by http://www.drmaciver.com/tag/timsort/.

Sort is stable, and *should* have O(n log n) avg and worst-case behavior.
However, currently this implementation is flawed: empirical testing
shows it to have O(n^2) avg time. Will continue looking into why.

On avg, generates about 4 cells per list element. Takes about 10s to sort
10k elements. By comparison, the C-implemented sort takes .01s and generates
about 2 cells per list element. (If I could reduce time from O(n^2)
to O(n log n), they should therefore be comparable.)

Copyright (c) 2012 by Dubiousjim <dubiousjim@gmail.com>.
See license at https://github.com/dubiousjim/unspoiled/blob/master/LICENSE

This implementation accepts (<) as its first argument, and operates only on
lists. It could easily be extended to operate on other immutable structures.
*/


// "reverse and append"
// used in the definition of append but not (yet) exposed
// in prelude.pure
revapp [] base = base;
revapp (x:xs) base = revapp xs (x:base);

msort _ [] = [];
msort lt (x:xs) = step lt xs x [] 1 (-1) [] with
    // ya = are these ys strictly ascending?
    step lt (x:xs) y ys 1 _ zss
        = step lt xs x (y:ys) 2 (lt x y) zss;
    step lt (x:xs) y ys yn ya zss
        = step lt xs x (y:ys) (succ yn) ya zss if (lt x y) == ya;
    step lt (x:xs) y ys yn ya zss = case zss of
        // to keep the zss stack small, we merge ys with its top layer
        // whenever #ys > half the size of the top zs
        (_,zn,_):_ = step lt xs x [] 1 (-1)
                     (merge1 lt (y:ys) yn ya zss) if yn*2 > zn;
        // else just push these ys onto zss
        zss = step lt xs x [] 1 (-1) ((y:ys,yn,ya):zss);
    end;
    // we've finished stepping through original list
    // note: at this point yn can be 1
    step lt [] y ys yn ya zss = mergen lt (y:ys) yn ya zss;

    // now keep merge1-ing until zss stack is empty
    // when done, if final ys aren't strictly ascending, reverse them
    mergen _ ys _ ya [] = if ya then ys else reverse ys;
    mergen lt ys yn ya zss = case merge1 lt ys yn ya zss of
        (zs,zn,za):zss = mergen lt zs zn za zss;
    end;

    // won't be tail called
    merge1 lt ys@(y:_) yn ya ((zs@(z:_),zn,za):zss) =
        if ya && ~za && ~(lt y z) then
            (revapp ys zs, yn+zn, 0):zss
        else if ~ya && za && (lt y z) then
            (revapp zs ys, yn+zn, 0):zss
        else if yn == 1 then
            (merge lt (~za) ys zs [], yn+zn, ~za):zss
        else ((ws, yn+zn, wa):zss when
            // ws = the merge of ys and zs
            // wa = are the ws strictly ascending?
            wa, ys, zs = if ya == za then ~za, ys, zs
                         else if zn < yn then za, ys, reverse zs
                         else ya, reverse ys, zs;
            ws = merge lt wa ys zs [];
        end);

    merge _ _ us [] ws | merge _ _ [] us ws = revapp us ws;
    merge lt wa (yy@(y:ys)) (zz@(z:zs)) ws =
        if (lt y z) ~= wa then
            merge lt wa ys zz (y:ws)
        else
            merge lt wa yy zs (z:ws);

end;



// We test with tuples, for which we provide a definition of <.
// The second alphabetic element tracks where the tuple occurred in the
// original list, so we can verify the stability of the sort.
// < is blind to the presence of the alphabetic element.
// We also define a >= which does take account of the alphabetic element.
// This isn't used in the sort algorithm, but only when verifying whether
// its results are stably sorted.

(a,_) < (b,_) = a < b;
(b,j) >= (a,i) = b > a || (b==a && j >= i);
sorted [] = true;
sorted (b:bs) = aux b bs with
    aux _ [] = true;
    aux a (b:bs) = b >= a && aux b bs;
end;

// generate random test tuples
using math;
rand n = random31 mod n;
data top len = map (\i -> rand top,i) ("a".."a"+len-1);

// To test:
// > all id [sorted $ msort (<) (data j 26) | i=1..300;j=2..8];
// 1
