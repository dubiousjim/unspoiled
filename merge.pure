/*
"Natural" or "adaptive" bottom-up merge sort.

Sort is stable, and has O(n log n) avg and worst-case behavior.
Optimized to exploit existing runs of ascending/descending elements,
to consume at most O(log n) levels of its working stack,
and to be mostly tail-recursive, while minimizing how often
sorted and merged runs need to be reversed.

Inspired by http://www.drmaciver.com/tag/timsort/.

Copyright (c) 2012 by Dubiousjim <dubiousjim@gmail.com>.
See license at https://github.com/dubiousjim/unspoiled/blob/master/LICENSE

This implementation operates only on lists, and requires < to be defined on
their elements. It could easily be extended to permit the caller to supply an
ordering relation, or to operate on other immutable structures.
*/


// "reverse and append"
// used in the definition of append but not (yet) exposed
// in prelude.pure
revapp [] base = base;
revapp (x:xs) base = revapp xs (x:base);

msort [] = [];
msort (x:xs) = step xs x [] 1 (-1) true [] with
    // ya = are these ys strictly ascending?
    // ia = would these ys "ideally" be strictly ascending?
    step (x:xs) y ys 1 _ ia zss
        = step xs x (y:ys) 2 (x<y) ia zss;
    step (x:xs) y ys yn ya ia zss
        = step xs x (y:ys) (succ yn) ya ia zss if (x<y) == ya;
    step (x:xs) y ys yn ya ia zss = case zss of
        // to keep the zss stack small, we merge ys with its top layer
        // whenever #ys > half the size of the top zs
        (_,zn,_):_ = step xs x [] 1 (-1)
                     (~ia) (merge1 (y:ys) yn ya ia zss) if yn*2 > zn;
        // else just push these ys onto zss
        // next set of ys will "ideally" be in the reverse order
        zss = step xs x [] 1 (-1) (~ia) ((y:ys,yn,ya):zss);
    end;
    // we've finished stepping through original list
    // note: at this point yn can be 1
    step [] y ys yn ya ia zss = mergen (y:ys) yn ya ia zss;

    // now keep merge1-ing until zss stack is empty
    // when done, if final ys aren't strictly ascending, reverse them
    mergen ys _ ya ia [] = if ya then ys else reverse ys;
    mergen ys yn ya ia zss = case merge1 ys yn ya ia zss of
        (zs,zn,za):zss = mergen zs zn za (~ia) zss;
    end;

    // won't be tail called
    merge1 ys@(y:_) yn ya ia ((zs@(z:_),zn,za):zss) =
        if ya && ~za && ~(y < z) then
            (revapp ys zs, yn+zn, 0):zss
        else if ~ya && za && (y < z) then
            (revapp zs ys, yn+zn, 0):zss
        else if yn == 1 then
            (merge (~za) ys zs [], yn+zn, ~za):zss
        else ((ws, yn+zn, wa):zss when
            // ws = the merge of ys and zs
            // wa = are the ws strictly ascending?
            ys = if ya~=ia && za==ia then reverse ys else ys;
            zs = if ya==ia && za~=ia then reverse zs else zs;
            wa = if ya~=ia && za~=ia then ia else ~ia;
            ws = merge wa ys zs [];
        end);

    merge _ us [] ws | merge _ [] us ws = revapp us ws;
    merge wa (yy@(y:ys)) (zz@(z:zs)) ws =
        if (y<z) == wa then
            merge wa yy zs (z:ws)
        else
            merge wa ys zz (y:ws);
end;



// We test with tuples, for which we provide a definition of <.
// The second alphabetic element tracks where the tuple occurred in the
// original list, so we can verify the stability of the sort.
// < is blind to the presence of the alphabetic element.
// We also define a >= which does take account of the alphabetic element.
// This isn't used in the sort algorithm, but only when verifying whether
// its results are stably sorted.

(a,_) < (b,_) = a < b;
(b,j) >= (a,i) = b > a || (b==a && j >= i);
sorted [] = true;
sorted (b:bs) = aux b bs with
    aux _ [] = true;
    aux a (b:bs) = b >= a && aux b bs;
end;

// generate random test tuples
using math;
rand n = random31 mod n;
data top len = map (\i -> rand top,i) ("a".."a"+len-1);

// To test:
// > all id [sorted $ msort (data j 26) | i=1..300;j=2..8];
// 1
