const false,true = 0,1;
slice x/*0:01*/ y/*0:1*/ = x/*0:01*/!!y/*0:1*/;
{
  rule #0: slice x y = x!!y
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
f/*0:01*/$x/*0:1*/ = f/*0:01*/ x/*0:1*/;
(f/*0:001*/.g/*0:01*/) x/*0:1*/ = f/*0:001*/ (g/*0:01*/ x/*0:1*/);
void _/*0:1*/ = ();
id x/*0:1*/ = x/*0:1*/;
cst x/*0:01*/ y/*0:1*/ = x/*0:01*/;
flip f/*0:001*/ x/*0:01*/ y/*0:1*/ = f/*0:001*/ y/*0:1*/ x/*0:01*/;
curry f/*0:001*/ x/*0:01*/ y/*0:1*/ = f/*0:001*/ (x/*0:01*/,y/*0:1*/);
curry3 f/*0:0001*/ x/*0:001*/ y/*0:01*/ z/*0:1*/ = f/*0:0001*/ (x/*0:001*/,y/*0:01*/,z/*0:1*/);
uncurry f/*0:01*/ (x/*0:101*/,y/*0:11*/) = f/*0:01*/ x/*0:101*/ y/*0:11*/;
uncurry3 f/*0:01*/ (x/*0:101*/,y/*0:1101*/,z/*0:111*/) = f/*0:01*/ x/*0:101*/ y/*0:1101*/ z/*0:111*/;
fix f/*0:1*/ = f/*0:1*/ (fix f/*1:1*/&);
def f/*0:01*/$x/*0:1*/ = f/*0:01*/ x/*0:1*/;
def (f/*0:001*/.g/*0:01*/) x/*0:1*/ = f/*0:001*/ (g/*0:01*/ x/*0:1*/);
def void () = ();
def void [] = ();
def void {} = ();
def void [x/*0:101*/] = void x/*0:101*/;
def void {x/*0:100*/} = void x/*0:100*/;
(x/*0:0101*/=>v/*0:011*/)==(y/*0:101*/=>w/*0:11*/) = x/*0:0101*/==y/*0:101*/&&v/*0:011*/==w/*0:11*/;
(x/*0:0101*/=>v/*0:011*/)~=(y/*0:101*/=>w/*0:11*/) = x/*0:0101*/~=y/*0:101*/||v/*0:011*/~=w/*0:11*/;
key (x/*0:101*/=>v/*0:11*/) = x/*0:101*/;
val (x/*0:101*/=>v/*0:11*/) = v/*0:11*/;
x/*0:01*/,() = x/*0:01*/;
(),y/*0:1*/ = y/*0:1*/;
(x/*0:0101*/,y/*0:011*/),z/*0:1*/ = x/*0:0101*/,y/*0:011*/,z/*0:1*/;
()==() = 1;
(x/*0:0101*/,xs/*0:011*/)==(y/*0:101*/,ys/*0:11*/) = x/*0:0101*/==y/*0:101*/&&xs/*0:011*/==ys/*0:11*/;
(x/*0:0101*/,xs/*0:011*/)==_/*0:1*/ = 0;
()==_/*0:1*/ = 0;
_/*0:01*/==(x/*0:101*/,xs/*0:11*/) = 0;
_/*0:01*/==() = 0;
()~=() = 0;
(x/*0:0101*/,xs/*0:011*/)~=(y/*0:101*/,ys/*0:11*/) = x/*0:0101*/~=y/*0:101*/||xs/*0:011*/~=ys/*0:11*/;
(x/*0:0101*/,xs/*0:011*/)~=_/*0:1*/ = 1;
()~=_/*0:1*/ = 1;
_/*0:01*/~=(x/*0:101*/,xs/*0:11*/) = 1;
_/*0:01*/~=() = 1;
null () = 1;
null (x/*0:101*/,xs/*0:11*/) = 0;
#() = 0;
#(x/*0:101*/,xs/*0:11*/) = accum/*0*/ 1 xs/*0:11*/ with accum n/*0:01*/ :: int (x/*0:101*/,xs/*0:11*/) = accum/*1*/ (n/*0:01*/+1) xs/*0:11*/; accum n/*0:01*/ :: int x/*0:1*/ = n/*0:01*/+1 {
  rule #0: accum n::int (x,xs) = accum (n+1) xs
  rule #1: accum n::int x = n+1
  state 0: #0 #1
	<var>::int state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	, state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
} end;
(x/*0:0101*/,xs/*0:011*/)!n/*0:1*/ :: int = throw out_of_bounds if n/*0:1*/<0;
(x/*0:0101*/,xs/*0:011*/)!0 = x/*0:0101*/;
(x/*0:0101*/,y/*0:01101*/,xs/*0:0111*/)!n/*0:1*/ :: int = (y/*0:01101*/,xs/*0:0111*/)!(n/*0:1*/-1);
(x/*0:0101*/,y/*0:011*/)!1 = y/*0:011*/;
(x/*0:0101*/,y/*0:011*/)!n/*0:1*/ :: int = throw out_of_bounds;
()!n/*0:1*/ :: int = throw out_of_bounds;
xs@()!!ns/*0:1*/ = tuple (list xs/*0:01*/!!ns/*0:1*/);
xs@(_/*0:0101*/,_/*0:011*/)!!ns/*0:1*/ = tuple (list xs/*0:01*/!!ns/*0:1*/);
reverse () = ();
reverse (x/*0:101*/,xs/*0:11*/) = accum/*0*/ x/*0:101*/ xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/,xs/*0:11*/) = accum/*1*/ (x/*0:101*/,ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ x/*0:1*/ = x/*0:1*/,ys/*0:01*/ {
  rule #0: accum ys (x,xs) = accum (x,ys) xs
  rule #1: accum ys x = x,ys
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	, state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
} end;
[]==[] = 1;
x/*0:0101*/:xs/*0:011*/==[] = 0;
[]==x/*0:101*/:xs/*0:11*/ = 0;
x/*0:0101*/:xs/*0:011*/==y/*0:101*/:ys/*0:11*/ = x/*0:0101*/==y/*0:101*/&&xs/*0:011*/==ys/*0:11*/;
[]~=[] = 0;
x/*0:0101*/:xs/*0:011*/~=[] = 1;
[]~=x/*0:101*/:xs/*0:11*/ = 1;
x/*0:0101*/:xs/*0:011*/~=y/*0:101*/:ys/*0:11*/ = x/*0:0101*/~=y/*0:101*/||xs/*0:011*/~=ys/*0:11*/;
null [] = 1;
null (x/*0:101*/:xs/*0:11*/) = 0;
#[] = 0;
#(x/*0:101*/:xs/*0:11*/) = accum/*0*/ 1 xs/*0:11*/ with accum n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (n/*0:01*/+1) xs/*0:11*/; accum n/*0:01*/ :: int [] = n/*0:01*/; accum n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/+#xs/*0:1*/ {
  rule #0: accum n::int (x:xs) = accum (n+1) xs
  rule #1: accum n::int [] = n
  rule #2: accum n::int xs = n+#xs
  state 0: #0 #1 #2
	<var>::int state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
[]!n/*0:1*/ :: int = throw out_of_bounds;
(x/*0:0101*/:xs/*0:011*/)!0 = x/*0:0101*/;
(x/*0:0101*/:xs/*0:011*/)!n/*0:1*/ :: int = xs/*0:011*/!(n/*0:1*/-1) if n/*0:1*/>0;
(x/*0:0101*/:xs/*0:011*/)!n/*0:1*/ :: int = throw out_of_bounds;
xs/*0:01*/!!ns/*0:1*/ = ys/*0:*/ if ok/*1*/ ys/*0:*/ when ys/*0:*/ = case ns/*0:1*/ of ns@(n/*0:01*/ :: int:_/*0:1*/) = list (take (count/*1*/ ns/*0:*/) (drop n/*0:01*/ xs/*1:01*/)) if listp xs/*1:01*/&&cont/*1*/ ns/*0:*/; _/*0:*/ = catmap (nth/*1*/ xs/*1:01*/) ns/*1:1*/ {
  rule #0: ns@(n::int:_) = list (take (count ns) (drop n xs)) if listp xs&&cont ns
  rule #1: _ = catmap (nth xs) ns
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	: state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
	<var>::int state 12
  state 10: #1
	<var> state 11
  state 11: #1
  state 12: #0 #1
	<var> state 13
  state 13: #0 #1
} end {
  rule #0: ys = case ns of ns@(n::int:_) = list (take (count ns) (drop n xs)) if listp xs&&cont ns; _ = catmap (nth xs) ns end
  state 0: #0
	<var> state 1
  state 1: #0
} end with cont (n/*0:101*/ :: int:ns/*0:11*/) = ~thunkp ns/*0:11*/&&(case ns/*0:11*/ of [] = 1; m/*0:01*/ :: int:_/*0:1*/ = cont/*2*/ ns/*1:11*/ if m/*0:01*/==n/*1:101*/+1; _/*0:*/ = 0 {
  rule #0: [] = 1
  rule #1: m::int:_ = cont ns if m==n+1
  rule #2: _ = 0
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
	[] state 14
  state 1: #2
  state 2: #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
	<var>::int state 12
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #1 #2
	<var> state 13
  state 13: #1 #2
  state 14: #0 #2
} end) {
  rule #0: cont (n::int:ns) = ~thunkp ns&&(case ns of [] = 1; m::int:_ = cont ns if m==n+1; _ = 0 end)
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var>::int state 4
  state 4: #0
	<var> state 5
  state 5: #0
}; nth xs/*0:01*/ n/*0:1*/ = catch (cst []) [xs/*1:01*/!n/*1:1*/] {
  rule #0: nth xs n = catch (cst []) [xs!n]
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}; count ns/*0:1*/ = #dropwhile (\n/*0:1*/ :: int -> n/*0:1*/<0 {
  rule #0: _ n::int = n<0
  state 0: #0
	<var>::int state 1
  state 1: #0
}) ns/*0:1*/ {
  rule #0: count ns = #dropwhile (\n::int -> n<0) ns
  state 0: #0
	<var> state 1
  state 1: #0
}; ok (catmap (nth _/*0:1011*/) _/*0:11*/) = 0; ok _/*0:1*/ = 1 {
  rule #0: ok (catmap (nth _) _) = 0
  rule #1: ok _ = 1
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	catmap state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #1
	<var> state 11
  state 11: #1
  state 12: #0 #1
	<var> state 13
	nth state 16
  state 13: #1
	<var> state 14
  state 14: #1
	<var> state 15
  state 15: #1
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end;
subseq [] a/*0:01*/ :: int b/*0:1*/ :: int = [];
subseq xs@(_/*0:00101*/:_/*0:0011*/) a/*0:01*/ :: int b/*0:1*/ :: int = take/*0*/ (b/*0:1*/-a/*0:01*/+1) (drop a/*0:01*/ xs/*0:001*/) with take n/*0:01*/ :: int [] = []; take n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = tick/*1*/ n/*0:01*/ [] xs/*0:1*/ {
  rule #0: take n::int [] = []
  rule #1: take n::int xs@(_:_) = tick n [] xs
  state 0: #0 #1
	<var>::int state 1
  state 1: #0 #1
	<app> state 2
	[] state 7
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0
}; tick n/*0:001*/ :: int zs/*0:01*/ xs/*0:1*/ = tack/*1*/ zs/*0:01*/ [] if n/*0:001*/<=0; tick n/*0:001*/ :: int zs/*0:01*/ xs/*0:1*/ = case xs/*0:1*/ of [] = tack/*2*/ zs/*1:01*/ []; x/*0:01*/:xs/*0:1*/ = tick/*2*/ (n/*1:001*/-1) (x/*0:01*/:zs/*1:01*/) xs/*0:1*/; _/*0:*/ = tack/*2*/ zs/*1:01*/ (take/*2*/ n/*1:001*/ xs/*1:1*/) {
  rule #0: [] = tack zs []
  rule #1: x:xs = tick (n-1) (x:zs) xs
  rule #2: _ = tack zs (take n xs)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
	[] state 12
  state 1: #2
  state 2: #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
  state 10: #1 #2
	<var> state 11
  state 11: #1 #2
  state 12: #0 #2
} end {
  rule #0: tick n::int zs xs = tack zs [] if n<=0
  rule #1: tick n::int zs xs = case xs of [] = tack zs []; x:xs = tick (n-1) (x:zs) xs; _ = tack zs (take n xs) end
  state 0: #0 #1
	<var>::int state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
	<var> state 3
  state 3: #0 #1
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ xs/*0:011*/ (x/*0:0101*/:ys/*0:1*/); tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (x:ys)
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
subseq x/*0:001*/ a/*0:01*/ b/*0:1*/ = slice x/*0:001*/ (a/*0:01*/..b/*0:1*/);
def x/*0:01*/!!(a/*0:101*/..b/*0:11*/) = subseq x/*0:01*/ a/*0:101*/ b/*0:11*/;
[]+ys/*0:1*/ = ys/*0:1*/;
xs@(_/*0:0101*/:_/*0:011*/)+ys/*0:1*/ = tick/*0*/ [] xs/*0:01*/ ys/*0:1*/ with tick zs/*0:001*/ (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ (x/*0:0101*/:zs/*0:001*/) ((xs/*1:011*/+ys/*1:1*/)&) if thunkp xs/*0:011*/; tick zs/*0:001*/ (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tick/*1*/ (x/*0:0101*/:zs/*0:001*/) xs/*0:011*/ ys/*0:1*/; tick zs/*0:001*/ [] ys/*0:1*/ = tack/*1*/ zs/*0:001*/ ys/*0:1*/; tick zs/*0:001*/ xs/*0:01*/ ys/*0:1*/ = tack/*1*/ zs/*0:001*/ (xs/*0:01*/+ys/*0:1*/) {
  rule #0: tick zs (x:xs) ys = tack (x:zs) ((xs+ys)&) if thunkp xs
  rule #1: tick zs (x:xs) ys = tick (x:zs) xs ys
  rule #2: tick zs [] ys = tack zs ys
  rule #3: tick zs xs ys = tack zs (xs+ys)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<app> state 4
	[] state 17
  state 2: #3
	<var> state 3
  state 3: #3
  state 4: #0 #1 #3
	<var> state 5
	<app> state 8
  state 5: #3
	<var> state 6
  state 6: #3
	<var> state 7
  state 7: #3
  state 8: #0 #1 #3
	<var> state 9
	: state 13
  state 9: #3
	<var> state 10
  state 10: #3
	<var> state 11
  state 11: #3
	<var> state 12
  state 12: #3
  state 13: #0 #1 #3
	<var> state 14
  state 14: #0 #1 #3
	<var> state 15
  state 15: #0 #1 #3
	<var> state 16
  state 16: #0 #1 #3
  state 17: #2 #3
	<var> state 18
  state 18: #2 #3
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ xs/*0:011*/ (x/*0:0101*/:ys/*0:1*/); tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (x:ys)
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
reverse [] = [];
reverse (x/*0:101*/:xs/*0:11*/) = accum/*0*/ [x/*0:101*/] xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (x/*0:101*/:ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ [] = ys/*0:01*/; accum ys/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: accum ys (x:xs) = accum (x:ys) xs
  rule #1: accum ys [] = ys
  rule #2: accum ys xs = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
list () = [];
list (x/*0:101*/,xs/*0:11*/) = accum/*0*/ [x/*0:101*/] xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/,xs/*0:11*/) = accum/*1*/ (x/*0:101*/:ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ x/*0:1*/ = reverse (x/*0:1*/:ys/*0:01*/) {
  rule #0: accum ys (x,xs) = accum (x:ys) xs
  rule #1: accum ys x = reverse (x:ys)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	, state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
} end;
tuple [] = ();
tuple (x/*0:101*/:xs/*0:11*/) = accum/*0*/ (t/*0*/ x/*0:101*/) xs/*0:11*/ with t x@(_/*0:101*/,_/*0:11*/) = reverse x/*0:1*/; t x/*0:1*/ = x/*0:1*/ {
  rule #0: t x@(_,_) = reverse x
  rule #1: t x = x
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	, state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
}; accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (t/*1*/ x/*0:101*/,ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ [] = t/*1*/ ys/*0:01*/; accum ys/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: accum ys (x:xs) = accum (t x,ys) xs
  rule #1: accum ys [] = t ys
  rule #2: accum ys xs = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
tuple x@() = x/*0:1*/;
tuple x@(_/*0:101*/,_/*0:11*/) = x/*0:1*/;
list [] = [];
list (x/*0:101*/:xs/*0:11*/) = accum/*0*/ [x/*0:101*/] xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (x/*0:101*/:ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ [] = reverse ys/*0:01*/; accum ys/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: accum ys (x:xs) = accum (x:ys) xs
  rule #1: accum ys [] = reverse ys
  rule #2: accum ys xs = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
stream [] = [];
stream (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:xs/*0:11*/ if thunkp xs/*0:11*/;
stream (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:stream xs/*1:11*/&;
stream () = [];
stream xs@(_/*0:101*/,_/*0:11*/) = stream (list xs/*0:1*/);
n1/*0:0101*/:n2/*0:011*/..m/*0:1*/ = if nanp n1/*2:0101*/||nanp m/*2:1*/||double m/*2:1*/===-s/*0:01*/ then [] else if double m/*2:1*/===s/*0:01*/ then iterate (flip (+) k/*1:*/) n1/*2:0101*/ else iterwhile (p/*0:1*/ (m/*2:1*/+0.5*k/*1:*/)) (flip (+) k/*1:*/) n1/*2:0101*/ when s/*0:01*/,p/*0:1*/ = if k/*0:*/>0 then inf,(>=) else -inf,(<=) {
  rule #0: s,p = if k>0 then inf,(>=) else -inf,(<=)
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end if realp k/*0:*/&&k/*0:*/~=0&&~infp n1/*1:0101*/&&~infp n2/*1:011*/ when k/*0:*/ = n2/*0:011*/-n1/*0:0101*/ {
  rule #0: k = n2-n1
  state 0: #0
	<var> state 1
  state 1: #0
} end;
n/*0:01*/..m/*0:1*/ = if nanp n/*0:01*/||nanp m/*0:1*/||double m/*0:1*/===-inf then [] else if double m/*0:1*/===inf then iterate (flip (+) 1) n/*0:01*/ else iterwhile ((>=) m/*0:1*/) (flip (+) 1) n/*0:01*/ if ~listp n/*0:01*/&&~infp n/*0:01*/;
all p/*0:01*/ [] = 1;
all p/*0:01*/ (x/*0:101*/:xs/*0:11*/) = p/*0:01*/ x/*0:101*/&&all p/*0:01*/ xs/*0:11*/;
any p/*0:01*/ [] = 0;
any p/*0:01*/ (x/*0:101*/:xs/*0:11*/) = p/*0:01*/ x/*0:101*/||any p/*0:01*/ xs/*0:11*/;
do f/*0:01*/ [] = ();
do f/*0:01*/ (x/*0:101*/:xs/*0:11*/) = f/*0:01*/ x/*0:101*/$$do f/*0:01*/ xs/*0:11*/;
drop n/*0:01*/ :: int [] = [];
drop n/*0:01*/ :: int ys@(x/*0:101*/:xs/*0:11*/) = drop (n/*0:01*/-1) xs/*0:11*/ if n/*0:01*/>1;
drop n/*0:01*/ :: int ys@(x/*0:101*/:xs/*0:11*/) = xs/*0:11*/ if n/*0:01*/==1;
drop n/*0:01*/ :: int ys@(x/*0:101*/:xs/*0:11*/) = ys/*0:1*/;
dropwhile p/*0:01*/ [] = [];
dropwhile p/*0:01*/ ys@(x/*0:101*/:xs/*0:11*/) = dropwhile p/*0:01*/ xs/*0:11*/ if p/*0:01*/ x/*0:101*/;
dropwhile p/*0:01*/ ys@(x/*0:101*/:xs/*0:11*/) = ys/*0:1*/;
filter p/*0:01*/ [] = [];
filter p/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*1*/ (add/*1*/ p/*1:01*/ x/*0:101*/ zs/*0:01*/) (filter p/*2:01*/ xs/*1:11*/&) if thunkp xs/*0:11*/; tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tick/*1*/ (add/*1*/ p/*1:01*/ x/*0:101*/ zs/*0:01*/) xs/*0:11*/; tick zs/*0:01*/ [] = tack/*1*/ zs/*0:01*/ []; tick _/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: tick zs (x:xs) = tack (add p x zs) (filter p xs&) if thunkp xs
  rule #1: tick zs (x:xs) = tick (add p x zs) xs
  rule #2: tick zs [] = tack zs []
  rule #3: tick _ xs = throw (bad_list_value xs)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #3
  state 3: #0 #1 #3
	<var> state 4
	<app> state 6
  state 4: #3
	<var> state 5
  state 5: #3
  state 6: #0 #1 #3
	<var> state 7
	: state 10
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #0 #1 #3
	<var> state 11
  state 11: #0 #1 #3
	<var> state 12
  state 12: #0 #1 #3
  state 13: #2 #3
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ xs/*0:011*/ (x/*0:0101*/:ys/*0:1*/); tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (x:ys)
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
}; add p/*0:001*/ x/*0:01*/ xs/*0:1*/ = if p/*0:001*/ x/*0:01*/ then x/*0:01*/:xs/*0:1*/ else xs/*0:1*/ {
  rule #0: add p x xs = if p x then x:xs else xs
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end;
foldl f/*0:001*/ a/*0:01*/ [] = a/*0:01*/;
foldl f/*0:001*/ a/*0:01*/ (x/*0:101*/:xs/*0:11*/) = foldl f/*0:001*/ (f/*0:001*/ a/*0:01*/ x/*0:101*/) xs/*0:11*/;
foldl1 f/*0:01*/ (x/*0:101*/:xs/*0:11*/) = foldl f/*0:01*/ x/*0:101*/ xs/*0:11*/;
foldr f/*0:001*/ a/*0:01*/ [] = a/*0:01*/;
foldr f/*0:001*/ a/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*1*/ (x/*0:101*/:zs/*0:01*/) (foldr f/*2:001*/ a/*2:01*/ xs/*1:11*/&) if thunkp xs/*0:11*/; tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tick/*1*/ (x/*0:101*/:zs/*0:01*/) xs/*0:11*/; tick zs/*0:01*/ [] = tack/*1*/ zs/*0:01*/ a/*1:01*/; tick zs/*0:01*/ xs/*0:1*/ = tack/*1*/ zs/*0:01*/ (foldr f/*1:001*/ a/*1:01*/ xs/*0:1*/) {
  rule #0: tick zs (x:xs) = tack (x:zs) (foldr f a xs&) if thunkp xs
  rule #1: tick zs (x:xs) = tick (x:zs) xs
  rule #2: tick zs [] = tack zs a
  rule #3: tick zs xs = tack zs (foldr f a xs)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #3
  state 3: #0 #1 #3
	<var> state 4
	<app> state 6
  state 4: #3
	<var> state 5
  state 5: #3
  state 6: #0 #1 #3
	<var> state 7
	: state 10
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #0 #1 #3
	<var> state 11
  state 11: #0 #1 #3
	<var> state 12
  state 12: #0 #1 #3
  state 13: #2 #3
}; tack (x/*0:0101*/:xs/*0:011*/) y/*0:1*/ = tack/*1*/ xs/*0:011*/ (f/*1:001*/ x/*0:0101*/ y/*0:1*/); tack [] y/*0:1*/ = y/*0:1*/ {
  rule #0: tack (x:xs) y = tack xs (f x y)
  rule #1: tack [] y = y
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
foldr1 f/*0:01*/ [x/*0:101*/] = x/*0:101*/;
foldr1 f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ ys@(_/*0:101*/:xs/*0:11*/) = tack/*1*/ zs/*0:01*/ (foldr1 f/*2:01*/ ys/*1:1*/&) if thunkp xs/*0:11*/; tick zs/*0:01*/ xs/*0:1*/ = case xs/*0:1*/ of [x/*0:01*/] = tack/*2*/ zs/*1:01*/ x/*0:01*/; x/*0:01*/:xs/*0:1*/ = tick/*2*/ (x/*0:01*/:zs/*1:01*/) xs/*0:1*/; _/*0:*/ = tack/*2*/ zs/*1:01*/ (foldr1 f/*2:01*/ xs/*1:1*/) {
  rule #0: [x] = tack zs x
  rule #1: x:xs = tick (x:zs) xs
  rule #2: _ = tack zs (foldr1 f xs)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #1 #2
	<var> state 10
  state 10: #0 #1 #2
	<var> state 11
	[] state 12
  state 11: #1 #2
  state 12: #0 #1 #2
} end {
  rule #0: tick zs ys@(_:xs) = tack zs (foldr1 f ys&) if thunkp xs
  rule #1: tick zs xs = case xs of [x] = tack zs x; x:xs = tick (x:zs) xs; _ = tack zs (foldr1 f xs) end
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	: state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
}; tack (x/*0:0101*/:xs/*0:011*/) y/*0:1*/ = tack/*1*/ xs/*0:011*/ (f/*1:01*/ x/*0:0101*/ y/*0:1*/); tack [] y/*0:1*/ = y/*0:1*/ {
  rule #0: tack (x:xs) y = tack xs (f x y)
  rule #1: tack [] y = y
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
head (x/*0:101*/:xs/*0:11*/) = x/*0:101*/;
init [x/*0:101*/] = [];
init xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ ys@(_/*0:101*/:xs/*0:11*/) = tack/*1*/ zs/*0:01*/ (init ys/*1:1*/&) if thunkp xs/*0:11*/; tick zs/*0:01*/ xs/*0:1*/ = case xs/*0:1*/ of [x/*0:01*/] = tack/*2*/ zs/*1:01*/ []; x/*0:01*/:xs/*0:1*/ = tick/*2*/ (x/*0:01*/:zs/*1:01*/) xs/*0:1*/; _/*0:*/ = tack/*2*/ zs/*1:01*/ (init xs/*1:1*/) {
  rule #0: [x] = tack zs []
  rule #1: x:xs = tick (x:zs) xs
  rule #2: _ = tack zs (init xs)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #1 #2
	<var> state 10
  state 10: #0 #1 #2
	<var> state 11
	[] state 12
  state 11: #1 #2
  state 12: #0 #1 #2
} end {
  rule #0: tick zs ys@(_:xs) = tack zs (init ys&) if thunkp xs
  rule #1: tick zs xs = case xs of [x] = tack zs []; x:xs = tick (x:zs) xs; _ = tack zs (init xs) end
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	: state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ xs/*0:011*/ (x/*0:0101*/:ys/*0:1*/); tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (x:ys)
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
last [x/*0:101*/] = x/*0:101*/;
last (x/*0:101*/:xs/*0:11*/) = last xs/*0:11*/;
map f/*0:01*/ [] = [];
map f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*1*/ (f/*1:01*/ x/*0:101*/:zs/*0:01*/) (map f/*2:01*/ xs/*1:11*/&) if thunkp xs/*0:11*/; tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tick/*1*/ (f/*1:01*/ x/*0:101*/:zs/*0:01*/) xs/*0:11*/; tick zs/*0:01*/ [] = tack/*1*/ zs/*0:01*/ []; tick zs/*0:01*/ xs/*0:1*/ = tack/*1*/ zs/*0:01*/ (map f/*1:01*/ xs/*0:1*/) {
  rule #0: tick zs (x:xs) = tack (f x:zs) (map f xs&) if thunkp xs
  rule #1: tick zs (x:xs) = tick (f x:zs) xs
  rule #2: tick zs [] = tack zs []
  rule #3: tick zs xs = tack zs (map f xs)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #3
  state 3: #0 #1 #3
	<var> state 4
	<app> state 6
  state 4: #3
	<var> state 5
  state 5: #3
  state 6: #0 #1 #3
	<var> state 7
	: state 10
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #0 #1 #3
	<var> state 11
  state 11: #0 #1 #3
	<var> state 12
  state 12: #0 #1 #3
  state 13: #2 #3
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ xs/*0:011*/ (x/*0:0101*/:ys/*0:1*/); tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (x:ys)
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
scanl f/*0:001*/ a/*0:01*/ [] = [a/*0:01*/];
scanl f/*0:001*/ a/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ a/*0:01*/ [] xs/*0:1*/ with tick a/*0:001*/ zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*1*/ (a/*0:001*/:zs/*0:01*/) (scanl f/*2:001*/ (f/*2:001*/ a/*1:001*/ x/*1:101*/) xs/*1:11*/&) if thunkp xs/*0:11*/; tick a/*0:001*/ zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tick/*1*/ (f/*1:001*/ a/*0:001*/ x/*0:101*/) (a/*0:001*/:zs/*0:01*/) xs/*0:11*/; tick a/*0:001*/ zs/*0:01*/ [] = tack/*1*/ zs/*0:01*/ [a/*0:001*/]; tick a/*0:001*/ zs/*0:01*/ xs/*0:1*/ = tack/*1*/ zs/*0:01*/ (scanl f/*1:001*/ a/*0:001*/ xs/*0:1*/) {
  rule #0: tick a zs (x:xs) = tack (a:zs) (scanl f (f a x) xs&) if thunkp xs
  rule #1: tick a zs (x:xs) = tick (f a x) (a:zs) xs
  rule #2: tick a zs [] = tack zs [a]
  rule #3: tick a zs xs = tack zs (scanl f a xs)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
  state 2: #0 #1 #2 #3
	<var> state 3
	<app> state 4
	[] state 14
  state 3: #3
  state 4: #0 #1 #3
	<var> state 5
	<app> state 7
  state 5: #3
	<var> state 6
  state 6: #3
  state 7: #0 #1 #3
	<var> state 8
	: state 11
  state 8: #3
	<var> state 9
  state 9: #3
	<var> state 10
  state 10: #3
  state 11: #0 #1 #3
	<var> state 12
  state 12: #0 #1 #3
	<var> state 13
  state 13: #0 #1 #3
  state 14: #2 #3
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ xs/*0:011*/ (x/*0:0101*/:ys/*0:1*/); tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (x:ys)
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
scanl1 f/*0:01*/ [] = [];
scanl1 f/*0:01*/ (x/*0:101*/:xs/*0:11*/) = scanl f/*0:01*/ x/*0:101*/ xs/*0:11*/;
scanr f/*0:001*/ a/*0:01*/ [] = [a/*0:01*/];
scanr f/*0:001*/ a/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*4*/ zs/*3:01*/ us/*0:*/ when ys/*0:*/ = scanr f/*2:001*/ a/*2:01*/ xs/*1:11*/&; y/*0:*/ = (case ys/*1:*/ of y/*0:01*/:_/*0:1*/ = y/*0:01*/; scanr _/*0:001*/ _/*0:01*/ ys/*0:1*/ = throw (bad_list_value ys/*0:1*/); _/*0:*/ = throw (bad_list_value ys/*2:*/) {
  rule #0: y:_ = y
  rule #1: scanr _ _ ys = throw (bad_list_value ys)
  rule #2: _ = throw (bad_list_value ys)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	<app> state 9
	: state 18
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
	scanr state 14
  state 10: #2
	<var> state 11
  state 11: #2
	<var> state 12
  state 12: #2
	<var> state 13
  state 13: #2
  state 14: #1 #2
	<var> state 15
  state 15: #1 #2
	<var> state 16
  state 16: #1 #2
	<var> state 17
  state 17: #1 #2
  state 18: #0 #2
	<var> state 19
  state 19: #0 #2
	<var> state 20
  state 20: #0 #2
} end)&; us/*0:*/ = f/*3:001*/ x/*2:101*/ y/*0:*/:ys/*1:*/ {
  rule #0: us = f x y:ys
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: y = (case ys of y:_ = y; scanr _ _ ys = throw (bad_list_value ys); _ = throw (bad_list_value ys) end)&
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: ys = scanr f a xs&
  state 0: #0
	<var> state 1
  state 1: #0
} end if thunkp xs/*0:11*/; tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*1*/ zs/*0:01*/ (f/*3:001*/ x/*2:101*/ (y/*0:01*/ when y/*0:01*/:_/*0:1*/ = ys/*1:*/ {
  rule #0: y:_ = ys
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end)&:ys/*0:*/ when ys/*0:*/ = scanr f/*2:001*/ a/*2:01*/ xs/*1:11*/& {
  rule #0: ys = scanr f a xs&
  state 0: #0
	<var> state 1
  state 1: #0
} end) if thunkp xs/*0:11*/; tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tick/*1*/ (x/*0:101*/:zs/*0:01*/) xs/*0:11*/; tick zs/*0:01*/ [] = tack/*1*/ zs/*0:01*/ [a/*1:01*/]; tick zs/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: tick zs (x:xs) = tack zs us when ys = scanr f a xs&; y = (case ys of y:_ = y; scanr _ _ ys = throw (bad_list_value ys); _ = throw (bad_list_value ys) end)&; us = f x y:ys end if thunkp xs
  rule #1: tick zs (x:xs) = tack zs (f x (y when y:_ = ys end)&:ys when ys = scanr f a xs& end) if thunkp xs
  rule #2: tick zs (x:xs) = tick (x:zs) xs
  rule #3: tick zs [] = tack zs [a]
  rule #4: tick zs xs = throw (bad_list_value xs)
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #4
  state 3: #0 #1 #2 #4
	<var> state 4
	<app> state 6
  state 4: #4
	<var> state 5
  state 5: #4
  state 6: #0 #1 #2 #4
	<var> state 7
	: state 10
  state 7: #4
	<var> state 8
  state 8: #4
	<var> state 9
  state 9: #4
  state 10: #0 #1 #2 #4
	<var> state 11
  state 11: #0 #1 #2 #4
	<var> state 12
  state 12: #0 #1 #2 #4
  state 13: #3 #4
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*2*/ xs/*1:011*/ (f/*2:001*/ x/*1:0101*/ y/*0:01*/:ys/*1:1*/) when y/*0:01*/:_/*0:1*/ = ys/*0:1*/ {
  rule #0: y:_ = ys
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end; tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (f x y:ys) when y:_ = ys end
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
scanr1 f/*0:01*/ [] = [];
scanr1 f/*0:01*/ [x/*0:101*/] = [x/*0:101*/];
scanr1 f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*4*/ zs/*3:01*/ us/*0:*/ when ys/*0:*/ = scanr1 f/*2:01*/ xs/*1:11*/&; y/*0:*/ = (case ys/*1:*/ of y/*0:01*/:_/*0:1*/ = y/*0:01*/; scanr1 _/*0:01*/ ys/*0:1*/ = throw (bad_list_value ys/*0:1*/); _/*0:*/ = throw (bad_list_value ys/*2:*/) {
  rule #0: y:_ = y
  rule #1: scanr1 _ ys = throw (bad_list_value ys)
  rule #2: _ = throw (bad_list_value ys)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
	scanr1 state 12
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #2
	<var> state 10
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
  state 12: #1 #2
	<var> state 13
  state 13: #1 #2
	<var> state 14
  state 14: #1 #2
} end)&; us/*0:*/ = f/*3:01*/ x/*2:101*/ y/*0:*/:ys/*1:*/ {
  rule #0: us = f x y:ys
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: y = (case ys of y:_ = y; scanr1 _ ys = throw (bad_list_value ys); _ = throw (bad_list_value ys) end)&
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: ys = scanr1 f xs&
  state 0: #0
	<var> state 1
  state 1: #0
} end if thunkp xs/*0:11*/; tick zs/*0:01*/ xs/*0:1*/ = case xs/*0:1*/ of [x/*0:01*/] = tack/*2*/ zs/*1:01*/ [x/*0:01*/]; x/*0:01*/:xs/*0:1*/ = tick/*2*/ (x/*0:01*/:zs/*1:01*/) xs/*0:1*/; _/*0:*/ = throw (bad_list_value xs/*1:1*/) {
  rule #0: [x] = tack zs [x]
  rule #1: x:xs = tick (x:zs) xs
  rule #2: _ = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #1 #2
	<var> state 10
  state 10: #0 #1 #2
	<var> state 11
	[] state 12
  state 11: #1 #2
  state 12: #0 #1 #2
} end {
  rule #0: tick zs (x:xs) = tack zs us when ys = scanr1 f xs&; y = (case ys of y:_ = y; scanr1 _ ys = throw (bad_list_value ys); _ = throw (bad_list_value ys) end)&; us = f x y:ys end if thunkp xs
  rule #1: tick zs xs = case xs of [x] = tack zs [x]; x:xs = tick (x:zs) xs; _ = throw (bad_list_value xs) end
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	: state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*2*/ xs/*1:011*/ (f/*2:01*/ x/*1:0101*/ y/*0:01*/:ys/*1:1*/) when y/*0:01*/:_/*0:1*/ = ys/*0:1*/ {
  rule #0: y:_ = ys
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end; tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (f x y:ys) when y:_ = ys end
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
tail (x/*0:101*/:xs/*0:11*/) = xs/*0:11*/;
take n/*0:01*/ :: int [] = [];
take n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ n/*0:01*/ [] xs/*0:1*/ with tick n/*0:001*/ :: int zs/*0:01*/ xs/*0:1*/ = tack/*1*/ zs/*0:01*/ [] if n/*0:001*/<=0; tick n/*0:001*/ :: int zs/*0:01*/ xs/*0:1*/ = tack/*1*/ zs/*0:01*/ (take n/*1:001*/ xs/*1:1*/&) if thunkp xs/*0:1*/; tick n/*0:001*/ :: int zs/*0:01*/ xs/*0:1*/ = case xs/*0:1*/ of [] = tack/*2*/ zs/*1:01*/ []; x/*0:01*/:xs/*0:1*/ = tick/*2*/ (n/*1:001*/-1) (x/*0:01*/:zs/*1:01*/) xs/*0:1*/; _/*0:*/ = tack/*2*/ zs/*1:01*/ (take n/*1:001*/ xs/*1:1*/) {
  rule #0: [] = tack zs []
  rule #1: x:xs = tick (n-1) (x:zs) xs
  rule #2: _ = tack zs (take n xs)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
	[] state 12
  state 1: #2
  state 2: #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
  state 10: #1 #2
	<var> state 11
  state 11: #1 #2
  state 12: #0 #2
} end {
  rule #0: tick n::int zs xs = tack zs [] if n<=0
  rule #1: tick n::int zs xs = tack zs (take n xs&) if thunkp xs
  rule #2: tick n::int zs xs = case xs of [] = tack zs []; x:xs = tick (n-1) (x:zs) xs; _ = tack zs (take n xs) end
  state 0: #0 #1 #2
	<var>::int state 1
  state 1: #0 #1 #2
	<var> state 2
  state 2: #0 #1 #2
	<var> state 3
  state 3: #0 #1 #2
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ xs/*0:011*/ (x/*0:0101*/:ys/*0:1*/); tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (x:ys)
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
takewhile p/*0:01*/ [] = [];
takewhile p/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ xs/*0:1*/ = tack/*1*/ zs/*0:01*/ (takewhile p/*2:01*/ xs/*1:1*/&) if thunkp xs/*0:1*/; tick zs/*0:01*/ xs/*0:1*/ = case xs/*0:1*/ of [] = tack/*2*/ zs/*1:01*/ []; x/*0:01*/:xs/*0:1*/ = tick/*2*/ (x/*0:01*/:zs/*1:01*/) xs/*0:1*/ if p/*2:01*/ x/*0:01*/; x/*0:01*/:xs/*0:1*/ = tack/*2*/ zs/*1:01*/ []; _/*0:*/ = tack/*2*/ zs/*1:01*/ (takewhile p/*2:01*/ xs/*1:1*/) {
  rule #0: [] = tack zs []
  rule #1: x:xs = tick (x:zs) xs if p x
  rule #2: x:xs = tack zs []
  rule #3: _ = tack zs (takewhile p xs)
  state 0: #0 #1 #2 #3
	<var> state 1
	<app> state 2
	[] state 12
  state 1: #3
  state 2: #1 #2 #3
	<var> state 3
	<app> state 5
  state 3: #3
	<var> state 4
  state 4: #3
  state 5: #1 #2 #3
	<var> state 6
	: state 9
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #1 #2 #3
	<var> state 10
  state 10: #1 #2 #3
	<var> state 11
  state 11: #1 #2 #3
  state 12: #0 #3
} end {
  rule #0: tick zs xs = tack zs (takewhile p xs&) if thunkp xs
  rule #1: tick zs xs = case xs of [] = tack zs []; x:xs = tick (x:zs) xs if p x; x:xs = tack zs []; _ = tack zs (takewhile p xs) end
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ xs/*0:011*/ (x/*0:0101*/:ys/*0:1*/); tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (x:ys)
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
cat [] = [];
cat xs@(_/*0:101*/:_/*0:11*/) = foldr/*0*/ (tick/*0*/ []) [] xs/*0:1*/ with foldr f/*0:001*/ a/*0:01*/ [] = a/*0:01*/; foldr f/*0:001*/ a/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*1*/ (x/*0:101*/:zs/*0:01*/) (foldr/*3*/ f/*2:001*/ a/*2:01*/ xs/*1:11*/&) if thunkp xs/*0:11*/; tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tick/*1*/ (x/*0:101*/:zs/*0:01*/) xs/*0:11*/; tick zs/*0:01*/ [] = tack/*1*/ zs/*0:01*/ a/*1:01*/; tick zs/*0:01*/ xs/*0:1*/ = tack/*1*/ zs/*0:01*/ (foldr/*2*/ f/*1:001*/ a/*1:01*/ xs/*0:1*/) {
  rule #0: tick zs (x:xs) = tack (x:zs) (foldr f a xs&) if thunkp xs
  rule #1: tick zs (x:xs) = tick (x:zs) xs
  rule #2: tick zs [] = tack zs a
  rule #3: tick zs xs = tack zs (foldr f a xs)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #3
  state 3: #0 #1 #3
	<var> state 4
	<app> state 6
  state 4: #3
	<var> state 5
  state 5: #3
  state 6: #0 #1 #3
	<var> state 7
	: state 10
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #0 #1 #3
	<var> state 11
  state 11: #0 #1 #3
	<var> state 12
  state 12: #0 #1 #3
  state 13: #2 #3
}; tack (x/*0:0101*/:xs/*0:011*/) y/*0:1*/ = tack/*1*/ xs/*0:011*/ (f/*1:001*/ x/*0:0101*/ y/*0:1*/); tack [] y/*0:1*/ = y/*0:1*/ {
  rule #0: tack (x:xs) y = tack xs (f x y)
  rule #1: tack [] y = y
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end; foldr (tick _/*0:0011*/) [] x/*0:1*/ = cat x/*0:1*/ {
  rule #0: foldr f a [] = a
  rule #1: foldr f a xs@(_:_) = tick [] xs with tick zs (x:xs) = tack (x:zs) (foldr f a xs&) if thunkp xs; tick zs (x:xs) = tick (x:zs) xs; tick zs [] = tack zs a; tick zs xs = tack zs (foldr f a xs); tack (x:xs) y = tack xs (f x y); tack [] y = y end
  rule #2: foldr (tick _) [] x = cat x
  state 0: #0 #1 #2
	<var> state 1
	<app> state 9
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
	<app> state 3
	[] state 8
  state 3: #1
	<app> state 4
  state 4: #1
	: state 5
  state 5: #1
	<var> state 6
  state 6: #1
	<var> state 7
  state 7: #1
  state 8: #0
  state 9: #0 #1 #2
	<var> state 10
	tick state 19
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
	<app> state 13
	[] state 18
  state 13: #1
	<app> state 14
  state 14: #1
	: state 15
  state 15: #1
	<var> state 16
  state 16: #1
	<var> state 17
  state 17: #1
  state 18: #0
  state 19: #0 #1 #2
	<var> state 20
  state 20: #0 #1 #2
	<var> state 21
	[] state 28
  state 21: #0 #1
	<app> state 22
	[] state 27
  state 22: #1
	<app> state 23
  state 23: #1
	: state 24
  state 24: #1
	<var> state 25
  state 25: #1
	<var> state 26
  state 26: #1
  state 27: #0
  state 28: #0 #1 #2
	<var> state 29
	<app> state 30
	[] state 40
  state 29: #2
  state 30: #1 #2
	<var> state 31
	<app> state 33
  state 31: #2
	<var> state 32
  state 32: #2
  state 33: #1 #2
	<var> state 34
	: state 37
  state 34: #2
	<var> state 35
  state 35: #2
	<var> state 36
  state 36: #2
  state 37: #1 #2
	<var> state 38
  state 38: #1 #2
	<var> state 39
  state 39: #1 #2
  state 40: #0 #2
}; tick zs/*0:001*/ (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ (x/*0:0101*/:zs/*0:001*/) (tick/*2*/ [] xs/*1:011*/ ys/*1:1*/&) if thunkp xs/*0:011*/; tick zs/*0:001*/ (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tick/*1*/ (x/*0:0101*/:zs/*0:001*/) xs/*0:011*/ ys/*0:1*/; tick zs/*0:001*/ [] ys/*0:1*/ = tack/*1*/ zs/*0:001*/ ys/*0:1*/; tick zs/*0:001*/ xs/*0:01*/ ys/*0:1*/ = tack/*1*/ zs/*0:001*/ (xs/*0:01*/+ys/*0:1*/) {
  rule #0: tick zs (x:xs) ys = tack (x:zs) (tick [] xs ys&) if thunkp xs
  rule #1: tick zs (x:xs) ys = tick (x:zs) xs ys
  rule #2: tick zs [] ys = tack zs ys
  rule #3: tick zs xs ys = tack zs (xs+ys)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<app> state 4
	[] state 17
  state 2: #3
	<var> state 3
  state 3: #3
  state 4: #0 #1 #3
	<var> state 5
	<app> state 8
  state 5: #3
	<var> state 6
  state 6: #3
	<var> state 7
  state 7: #3
  state 8: #0 #1 #3
	<var> state 9
	: state 13
  state 9: #3
	<var> state 10
  state 10: #3
	<var> state 11
  state 11: #3
	<var> state 12
  state 12: #3
  state 13: #0 #1 #3
	<var> state 14
  state 14: #0 #1 #3
	<var> state 15
  state 15: #0 #1 #3
	<var> state 16
  state 16: #0 #1 #3
  state 17: #2 #3
	<var> state 18
  state 18: #2 #3
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ xs/*0:011*/ (x/*0:0101*/:ys/*0:1*/); tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (x:ys)
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
catmap f/*0:01*/ [] = [];
catmap f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = cat (map f/*0:01*/ xs/*0:1*/);
listmap f/*0:01*/ [] = [];
listmap f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = map f/*0:01*/ xs/*0:1*/;
index [] _/*0:1*/ = -1;
index (x/*0:0101*/:xs/*0:011*/) y/*0:1*/ = search/*0*/ 0 (x/*0:0101*/:xs/*0:011*/) with search _/*0:01*/ [] = -1; search n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ if x/*0:101*/==y/*1:1*/; search n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = search/*1*/ (n/*0:01*/+1) xs/*0:11*/; search _/*0:01*/ xs/*0:1*/ = index xs/*0:1*/ y/*1:1*/ {
  rule #0: search _ [] = -1
  rule #1: search n::int (x:xs) = n if x==y
  rule #2: search n::int (x:xs) = search (n+1) xs
  rule #3: search _ xs = index xs y
  state 0: #0 #1 #2 #3
	<var> state 1
	<var>::int state 4
  state 1: #0 #3
	<var> state 2
	[] state 3
  state 2: #3
  state 3: #0 #3
  state 4: #0 #1 #2 #3
	<var> state 5
	<app> state 6
	[] state 16
  state 5: #3
  state 6: #1 #2 #3
	<var> state 7
	<app> state 9
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #1 #2 #3
	<var> state 10
	: state 13
  state 10: #3
	<var> state 11
  state 11: #3
	<var> state 12
  state 12: #3
  state 13: #1 #2 #3
	<var> state 14
  state 14: #1 #2 #3
	<var> state 15
  state 15: #1 #2 #3
  state 16: #0 #3
} end;
iterate f/*0:01*/ x/*0:1*/ = x/*0:1*/:iterate f/*1:01*/ (f/*1:01*/ x/*1:1*/)&;
repeat x/*0:1*/ = x/*0:1*/:repeat x/*1:1*/&;
cycle ys@(x/*0:101*/:xs/*0:11*/) = x/*0:101*/:(xs/*1:11*/+cycle ys/*1:1*/)&;
iterwhile p/*0:001*/ f/*0:01*/ x/*0:1*/ = accum/*0*/ [] p/*0:001*/ f/*0:01*/ x/*0:1*/ with accum xs/*0:0001*/ p/*0:001*/ f/*0:01*/ x/*0:1*/ = accum/*1*/ (x/*0:1*/:xs/*0:0001*/) p/*0:001*/ f/*0:01*/ (f/*0:01*/ x/*0:1*/) if p/*0:001*/ x/*0:1*/; accum xs/*0:0001*/ p/*0:001*/ f/*0:01*/ x/*0:1*/ = reverse xs/*0:0001*/ {
  rule #0: accum xs p f x = accum (x:xs) p f (f x) if p x
  rule #1: accum xs p f x = reverse xs
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
	<var> state 3
  state 3: #0 #1
	<var> state 4
  state 4: #0 #1
} end;
iteraten n/*0:001*/ :: int f/*0:01*/ x/*0:1*/ = [] if n/*0:001*/<=0;
iteraten n/*0:001*/ :: int f/*0:01*/ x/*0:1*/ = accum/*0*/ [] n/*0:001*/ f/*0:01*/ x/*0:1*/ with accum xs/*0:0001*/ n/*0:001*/ :: int f/*0:01*/ x/*0:1*/ = reverse (x/*0:1*/:xs/*0:0001*/) if n/*0:001*/==1; accum xs/*0:0001*/ n/*0:001*/ :: int f/*0:01*/ x/*0:1*/ = accum/*1*/ (x/*0:1*/:xs/*0:0001*/) (n/*0:001*/-1) f/*0:01*/ (f/*0:01*/ x/*0:1*/) {
  rule #0: accum xs n::int f x = reverse (x:xs) if n==1
  rule #1: accum xs n::int f x = accum (x:xs) (n-1) f (f x)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::int state 2
  state 2: #0 #1
	<var> state 3
  state 3: #0 #1
	<var> state 4
  state 4: #0 #1
} end;
repeatn n/*0:01*/ :: int x/*0:1*/ = accum/*0*/ [] n/*0:01*/ x/*0:1*/ with accum xs/*0:001*/ n/*0:01*/ :: int x/*0:1*/ = xs/*0:001*/ if n/*0:01*/<=0; accum xs/*0:001*/ n/*0:01*/ :: int x/*0:1*/ = accum/*1*/ (x/*0:1*/:xs/*0:001*/) (n/*0:01*/-1) x/*0:1*/ {
  rule #0: accum xs n::int x = xs if n<=0
  rule #1: accum xs n::int x = accum (x:xs) (n-1) x
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::int state 2
  state 2: #0 #1
	<var> state 3
  state 3: #0 #1
} end;
cyclen n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = [] if n/*0:01*/<=0;
cyclen n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = accum/*0*/ [] n/*2:01*/ with accum ys/*0:01*/ n/*0:1*/ :: int = cat ys/*0:01*/+take n/*0:1*/ xs/*2:*/ if n/*0:1*/<=m/*1:*/; accum ys/*0:01*/ n/*0:1*/ :: int = accum/*1*/ (xs/*2:*/:ys/*0:01*/) (n/*0:1*/-m/*1:*/) {
  rule #0: accum ys n::int = cat ys+take n xs if n<=m
  rule #1: accum ys n::int = accum (xs:ys) (n-m)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::int state 2
  state 2: #0 #1
} end when xs/*0:*/ = x/*0:101*/:xs/*0:11*/; m/*0:*/ :: int = #xs/*0:*/ {
  rule #0: m::int = #xs
  state 0: #0
	<var>::int state 1
  state 1: #0
} {
  rule #0: xs = x:xs
  state 0: #0
	<var> state 1
  state 1: #0
} end if rlistp xs/*0:11*/;
zip [] _/*0:1*/ = [];
zip _/*0:01*/ [] = [];
zip xs@(_/*0:0101*/:_/*0:011*/) ys@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:01*/ ys/*0:1*/ with tick us/*0:001*/ (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = tack/*1*/ ((x/*0:0101*/,y/*0:101*/):us/*0:001*/) (zip xs/*1:011*/ ys/*1:11*/&) if thunkp xs/*0:011*/||thunkp ys/*0:11*/; tick us/*0:001*/ (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = tick/*1*/ ((x/*0:0101*/,y/*0:101*/):us/*0:001*/) xs/*0:011*/ ys/*0:11*/; tick us/*0:001*/ [] _/*0:1*/ = tack/*1*/ us/*0:001*/ []; tick us/*0:001*/ _/*0:01*/ [] = tack/*1*/ us/*0:001*/ []; tick us/*0:001*/ xs/*0:01*/ ys/*0:1*/ = tack/*1*/ us/*0:001*/ (zip xs/*0:01*/ ys/*0:1*/) {
  rule #0: tick us (x:xs) (y:ys) = tack ((x,y):us) (zip xs ys&) if thunkp xs||thunkp ys
  rule #1: tick us (x:xs) (y:ys) = tick ((x,y):us) xs ys
  rule #2: tick us [] _ = tack us []
  rule #3: tick us _ [] = tack us []
  rule #4: tick us xs ys = tack us (zip xs ys)
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<app> state 5
	[] state 31
  state 2: #3 #4
	<var> state 3
	[] state 4
  state 3: #4
  state 4: #3 #4
  state 5: #0 #1 #3 #4
	<var> state 6
	<app> state 10
  state 6: #3 #4
	<var> state 7
  state 7: #3 #4
	<var> state 8
	[] state 9
  state 8: #4
  state 9: #3 #4
  state 10: #0 #1 #3 #4
	<var> state 11
	: state 16
  state 11: #3 #4
	<var> state 12
  state 12: #3 #4
	<var> state 13
  state 13: #3 #4
	<var> state 14
	[] state 15
  state 14: #4
  state 15: #3 #4
  state 16: #0 #1 #3 #4
	<var> state 17
  state 17: #0 #1 #3 #4
	<var> state 18
  state 18: #0 #1 #3 #4
	<var> state 19
	<app> state 20
	[] state 30
  state 19: #4
  state 20: #0 #1 #4
	<var> state 21
	<app> state 23
  state 21: #4
	<var> state 22
  state 22: #4
  state 23: #0 #1 #4
	<var> state 24
	: state 27
  state 24: #4
	<var> state 25
  state 25: #4
	<var> state 26
  state 26: #4
  state 27: #0 #1 #4
	<var> state 28
  state 28: #0 #1 #4
	<var> state 29
  state 29: #0 #1 #4
  state 30: #3 #4
  state 31: #2 #3 #4
	<var> state 32
	[] state 33
  state 32: #2 #4
  state 33: #2 #3 #4
}; tack (u/*0:0101*/:us/*0:011*/) vs/*0:1*/ = tack/*1*/ us/*0:011*/ (u/*0:0101*/:vs/*0:1*/); tack [] vs/*0:1*/ = vs/*0:1*/ {
  rule #0: tack (u:us) vs = tack us (u:vs)
  rule #1: tack [] vs = vs
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
zip3 [] _/*0:01*/ _/*0:1*/ = [];
zip3 _/*0:001*/ [] _/*0:1*/ = [];
zip3 _/*0:001*/ _/*0:01*/ [] = [];
zip3 xs@(_/*0:00101*/:_/*0:0011*/) ys@(_/*0:0101*/:_/*0:011*/) zs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ with tick us/*0:0001*/ (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = tack/*1*/ ((x/*0:00101*/,y/*0:0101*/,z/*0:101*/):us/*0:0001*/) (zip3 xs/*1:0011*/ ys/*1:011*/ zs/*1:11*/&) if thunkp xs/*0:0011*/||thunkp ys/*0:011*/||thunkp zs/*0:11*/; tick us/*0:0001*/ (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = tick/*1*/ ((x/*0:00101*/,y/*0:0101*/,z/*0:101*/):us/*0:0001*/) xs/*0:0011*/ ys/*0:011*/ zs/*0:11*/; tick us/*0:0001*/ [] _/*0:01*/ _/*0:1*/ = tack/*1*/ us/*0:0001*/ []; tick us/*0:0001*/ _/*0:001*/ [] _/*0:1*/ = tack/*1*/ us/*0:0001*/ []; tick us/*0:0001*/ _/*0:001*/ _/*0:01*/ [] = tack/*1*/ us/*0:0001*/ []; tick us/*0:0001*/ xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ = tack/*1*/ us/*0:0001*/ (zip3 xs/*0:001*/ ys/*0:01*/ zs/*0:1*/) {
  rule #0: tick us (x:xs) (y:ys) (z:zs) = tack ((x,y,z):us) (zip3 xs ys zs&) if thunkp xs||thunkp ys||thunkp zs
  rule #1: tick us (x:xs) (y:ys) (z:zs) = tick ((x,y,z):us) xs ys zs
  rule #2: tick us [] _ _ = tack us []
  rule #3: tick us _ [] _ = tack us []
  rule #4: tick us _ _ [] = tack us []
  rule #5: tick us xs ys zs = tack us (zip3 xs ys zs)
  state 0: #0 #1 #2 #3 #4 #5
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5
	<var> state 2
	<app> state 9
	[] state 63
  state 2: #3 #4 #5
	<var> state 3
	[] state 6
  state 3: #4 #5
	<var> state 4
	[] state 5
  state 4: #5
  state 5: #4 #5
  state 6: #3 #4 #5
	<var> state 7
	[] state 8
  state 7: #3 #5
  state 8: #3 #4 #5
  state 9: #0 #1 #3 #4 #5
	<var> state 10
	<app> state 18
  state 10: #3 #4 #5
	<var> state 11
  state 11: #3 #4 #5
	<var> state 12
	[] state 15
  state 12: #4 #5
	<var> state 13
	[] state 14
  state 13: #5
  state 14: #4 #5
  state 15: #3 #4 #5
	<var> state 16
	[] state 17
  state 16: #3 #5
  state 17: #3 #4 #5
  state 18: #0 #1 #3 #4 #5
	<var> state 19
	: state 28
  state 19: #3 #4 #5
	<var> state 20
  state 20: #3 #4 #5
	<var> state 21
  state 21: #3 #4 #5
	<var> state 22
	[] state 25
  state 22: #4 #5
	<var> state 23
	[] state 24
  state 23: #5
  state 24: #4 #5
  state 25: #3 #4 #5
	<var> state 26
	[] state 27
  state 26: #3 #5
  state 27: #3 #4 #5
  state 28: #0 #1 #3 #4 #5
	<var> state 29
  state 29: #0 #1 #3 #4 #5
	<var> state 30
  state 30: #0 #1 #3 #4 #5
	<var> state 31
	<app> state 34
	[] state 60
  state 31: #4 #5
	<var> state 32
	[] state 33
  state 32: #5
  state 33: #4 #5
  state 34: #0 #1 #4 #5
	<var> state 35
	<app> state 39
  state 35: #4 #5
	<var> state 36
  state 36: #4 #5
	<var> state 37
	[] state 38
  state 37: #5
  state 38: #4 #5
  state 39: #0 #1 #4 #5
	<var> state 40
	: state 45
  state 40: #4 #5
	<var> state 41
  state 41: #4 #5
	<var> state 42
  state 42: #4 #5
	<var> state 43
	[] state 44
  state 43: #5
  state 44: #4 #5
  state 45: #0 #1 #4 #5
	<var> state 46
  state 46: #0 #1 #4 #5
	<var> state 47
  state 47: #0 #1 #4 #5
	<var> state 48
	<app> state 49
	[] state 59
  state 48: #5
  state 49: #0 #1 #5
	<var> state 50
	<app> state 52
  state 50: #5
	<var> state 51
  state 51: #5
  state 52: #0 #1 #5
	<var> state 53
	: state 56
  state 53: #5
	<var> state 54
  state 54: #5
	<var> state 55
  state 55: #5
  state 56: #0 #1 #5
	<var> state 57
  state 57: #0 #1 #5
	<var> state 58
  state 58: #0 #1 #5
  state 59: #4 #5
  state 60: #3 #4 #5
	<var> state 61
	[] state 62
  state 61: #3 #5
  state 62: #3 #4 #5
  state 63: #2 #3 #4 #5
	<var> state 64
	[] state 67
  state 64: #2 #4 #5
	<var> state 65
	[] state 66
  state 65: #2 #5
  state 66: #2 #4 #5
  state 67: #2 #3 #4 #5
	<var> state 68
	[] state 69
  state 68: #2 #3 #5
  state 69: #2 #3 #4 #5
}; tack (u/*0:0101*/:us/*0:011*/) vs/*0:1*/ = tack/*1*/ us/*0:011*/ (u/*0:0101*/:vs/*0:1*/); tack [] vs/*0:1*/ = vs/*0:1*/ {
  rule #0: tack (u:us) vs = tack us (u:vs)
  rule #1: tack [] vs = vs
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
zipwith f/*0:001*/ [] _/*0:1*/ = [];
zipwith f/*0:001*/ _/*0:01*/ [] = [];
zipwith f/*0:001*/ xs@(_/*0:0101*/:_/*0:011*/) ys@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:01*/ ys/*0:1*/ with tick us/*0:001*/ (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = tack/*1*/ (f/*1:001*/ x/*0:0101*/ y/*0:101*/:us/*0:001*/) (zipwith f/*2:001*/ xs/*1:011*/ ys/*1:11*/&) if thunkp xs/*0:011*/||thunkp ys/*0:11*/; tick us/*0:001*/ (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = tick/*1*/ (f/*1:001*/ x/*0:0101*/ y/*0:101*/:us/*0:001*/) xs/*0:011*/ ys/*0:11*/; tick us/*0:001*/ [] _/*0:1*/ = tack/*1*/ us/*0:001*/ []; tick us/*0:001*/ _/*0:01*/ [] = tack/*1*/ us/*0:001*/ []; tick us/*0:001*/ xs/*0:01*/ ys/*0:1*/ = tack/*1*/ us/*0:001*/ (zipwith f/*1:001*/ xs/*0:01*/ ys/*0:1*/) {
  rule #0: tick us (x:xs) (y:ys) = tack (f x y:us) (zipwith f xs ys&) if thunkp xs||thunkp ys
  rule #1: tick us (x:xs) (y:ys) = tick (f x y:us) xs ys
  rule #2: tick us [] _ = tack us []
  rule #3: tick us _ [] = tack us []
  rule #4: tick us xs ys = tack us (zipwith f xs ys)
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<app> state 5
	[] state 31
  state 2: #3 #4
	<var> state 3
	[] state 4
  state 3: #4
  state 4: #3 #4
  state 5: #0 #1 #3 #4
	<var> state 6
	<app> state 10
  state 6: #3 #4
	<var> state 7
  state 7: #3 #4
	<var> state 8
	[] state 9
  state 8: #4
  state 9: #3 #4
  state 10: #0 #1 #3 #4
	<var> state 11
	: state 16
  state 11: #3 #4
	<var> state 12
  state 12: #3 #4
	<var> state 13
  state 13: #3 #4
	<var> state 14
	[] state 15
  state 14: #4
  state 15: #3 #4
  state 16: #0 #1 #3 #4
	<var> state 17
  state 17: #0 #1 #3 #4
	<var> state 18
  state 18: #0 #1 #3 #4
	<var> state 19
	<app> state 20
	[] state 30
  state 19: #4
  state 20: #0 #1 #4
	<var> state 21
	<app> state 23
  state 21: #4
	<var> state 22
  state 22: #4
  state 23: #0 #1 #4
	<var> state 24
	: state 27
  state 24: #4
	<var> state 25
  state 25: #4
	<var> state 26
  state 26: #4
  state 27: #0 #1 #4
	<var> state 28
  state 28: #0 #1 #4
	<var> state 29
  state 29: #0 #1 #4
  state 30: #3 #4
  state 31: #2 #3 #4
	<var> state 32
	[] state 33
  state 32: #2 #4
  state 33: #2 #3 #4
}; tack (u/*0:0101*/:us/*0:011*/) vs/*0:1*/ = tack/*1*/ us/*0:011*/ (u/*0:0101*/:vs/*0:1*/); tack [] vs/*0:1*/ = vs/*0:1*/ {
  rule #0: tack (u:us) vs = tack us (u:vs)
  rule #1: tack [] vs = vs
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
zipwith3 f/*0:0001*/ [] _/*0:01*/ _/*0:1*/ = [];
zipwith3 f/*0:0001*/ _/*0:001*/ [] _/*0:1*/ = [];
zipwith3 f/*0:0001*/ _/*0:001*/ _/*0:01*/ [] = [];
zipwith3 f/*0:0001*/ xs@(_/*0:00101*/:_/*0:0011*/) ys@(_/*0:0101*/:_/*0:011*/) zs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ with tick us/*0:0001*/ (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = tack/*1*/ (f/*1:0001*/ x/*0:00101*/ y/*0:0101*/ z/*0:101*/:us/*0:0001*/) (zipwith3 f/*2:0001*/ xs/*1:0011*/ ys/*1:011*/ zs/*1:11*/&) if thunkp xs/*0:0011*/||thunkp ys/*0:011*/||thunkp zs/*0:11*/; tick us/*0:0001*/ (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = tick/*1*/ (f/*1:0001*/ x/*0:00101*/ y/*0:0101*/ z/*0:101*/:us/*0:0001*/) xs/*0:0011*/ ys/*0:011*/ zs/*0:11*/; tick us/*0:0001*/ [] _/*0:01*/ _/*0:1*/ = tack/*1*/ us/*0:0001*/ []; tick us/*0:0001*/ _/*0:001*/ [] _/*0:1*/ = tack/*1*/ us/*0:0001*/ []; tick us/*0:0001*/ _/*0:001*/ _/*0:01*/ [] = tack/*1*/ us/*0:0001*/ []; tick us/*0:0001*/ xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ = tack/*1*/ us/*0:0001*/ (zipwith3 f/*1:0001*/ xs/*0:001*/ ys/*0:01*/ zs/*0:1*/) {
  rule #0: tick us (x:xs) (y:ys) (z:zs) = tack (f x y z:us) (zipwith3 f xs ys zs&) if thunkp xs||thunkp ys||thunkp zs
  rule #1: tick us (x:xs) (y:ys) (z:zs) = tick (f x y z:us) xs ys zs
  rule #2: tick us [] _ _ = tack us []
  rule #3: tick us _ [] _ = tack us []
  rule #4: tick us _ _ [] = tack us []
  rule #5: tick us xs ys zs = tack us (zipwith3 f xs ys zs)
  state 0: #0 #1 #2 #3 #4 #5
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5
	<var> state 2
	<app> state 9
	[] state 63
  state 2: #3 #4 #5
	<var> state 3
	[] state 6
  state 3: #4 #5
	<var> state 4
	[] state 5
  state 4: #5
  state 5: #4 #5
  state 6: #3 #4 #5
	<var> state 7
	[] state 8
  state 7: #3 #5
  state 8: #3 #4 #5
  state 9: #0 #1 #3 #4 #5
	<var> state 10
	<app> state 18
  state 10: #3 #4 #5
	<var> state 11
  state 11: #3 #4 #5
	<var> state 12
	[] state 15
  state 12: #4 #5
	<var> state 13
	[] state 14
  state 13: #5
  state 14: #4 #5
  state 15: #3 #4 #5
	<var> state 16
	[] state 17
  state 16: #3 #5
  state 17: #3 #4 #5
  state 18: #0 #1 #3 #4 #5
	<var> state 19
	: state 28
  state 19: #3 #4 #5
	<var> state 20
  state 20: #3 #4 #5
	<var> state 21
  state 21: #3 #4 #5
	<var> state 22
	[] state 25
  state 22: #4 #5
	<var> state 23
	[] state 24
  state 23: #5
  state 24: #4 #5
  state 25: #3 #4 #5
	<var> state 26
	[] state 27
  state 26: #3 #5
  state 27: #3 #4 #5
  state 28: #0 #1 #3 #4 #5
	<var> state 29
  state 29: #0 #1 #3 #4 #5
	<var> state 30
  state 30: #0 #1 #3 #4 #5
	<var> state 31
	<app> state 34
	[] state 60
  state 31: #4 #5
	<var> state 32
	[] state 33
  state 32: #5
  state 33: #4 #5
  state 34: #0 #1 #4 #5
	<var> state 35
	<app> state 39
  state 35: #4 #5
	<var> state 36
  state 36: #4 #5
	<var> state 37
	[] state 38
  state 37: #5
  state 38: #4 #5
  state 39: #0 #1 #4 #5
	<var> state 40
	: state 45
  state 40: #4 #5
	<var> state 41
  state 41: #4 #5
	<var> state 42
  state 42: #4 #5
	<var> state 43
	[] state 44
  state 43: #5
  state 44: #4 #5
  state 45: #0 #1 #4 #5
	<var> state 46
  state 46: #0 #1 #4 #5
	<var> state 47
  state 47: #0 #1 #4 #5
	<var> state 48
	<app> state 49
	[] state 59
  state 48: #5
  state 49: #0 #1 #5
	<var> state 50
	<app> state 52
  state 50: #5
	<var> state 51
  state 51: #5
  state 52: #0 #1 #5
	<var> state 53
	: state 56
  state 53: #5
	<var> state 54
  state 54: #5
	<var> state 55
  state 55: #5
  state 56: #0 #1 #5
	<var> state 57
  state 57: #0 #1 #5
	<var> state 58
  state 58: #0 #1 #5
  state 59: #4 #5
  state 60: #3 #4 #5
	<var> state 61
	[] state 62
  state 61: #3 #5
  state 62: #3 #4 #5
  state 63: #2 #3 #4 #5
	<var> state 64
	[] state 67
  state 64: #2 #4 #5
	<var> state 65
	[] state 66
  state 65: #2 #5
  state 66: #2 #4 #5
  state 67: #2 #3 #4 #5
	<var> state 68
	[] state 69
  state 68: #2 #3 #5
  state 69: #2 #3 #4 #5
}; tack (u/*0:0101*/:us/*0:011*/) vs/*0:1*/ = tack/*1*/ us/*0:011*/ (u/*0:0101*/:vs/*0:1*/); tack [] vs/*0:1*/ = vs/*0:1*/ {
  rule #0: tack (u:us) vs = tack us (u:vs)
  rule #1: tack [] vs = vs
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
dowith f/*0:001*/ (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = f/*0:001*/ x/*0:0101*/ y/*0:101*/$$dowith f/*0:001*/ xs/*0:011*/ ys/*0:11*/;
dowith f/*0:001*/ _/*0:01*/ _/*0:1*/ = ();
dowith3 f/*0:0001*/ (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = f/*0:0001*/ x/*0:00101*/ y/*0:0101*/ z/*0:101*/$$dowith3 f/*0:0001*/ xs/*0:0011*/ ys/*0:011*/ zs/*0:11*/;
dowith3 f/*0:0001*/ _/*0:001*/ _/*0:01*/ _/*0:1*/ = ();
unzip [] = [],[];
unzip us@(_/*0:101*/:_/*0:11*/) = foldr accum/*0*/ ([],[]) us/*0:1*/ with check us@(_/*0:101*/,_/*0:11*/) = us/*0:1*/; check (foldr _/*0:1001*/ _/*0:101*/ us/*0:11*/) = throw (bad_list_value us/*0:11*/); check us/*0:1*/ = throw (bad_tuple_value us/*0:1*/) {
  rule #0: check us@(_,_) = us
  rule #1: check (foldr _ _ us) = throw (bad_list_value us)
  rule #2: check us = throw (bad_tuple_value us)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	<app> state 9
	, state 18
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
	foldr state 14
  state 10: #2
	<var> state 11
  state 11: #2
	<var> state 12
  state 12: #2
	<var> state 13
  state 13: #2
  state 14: #1 #2
	<var> state 15
  state 15: #1 #2
	<var> state 16
  state 16: #1 #2
	<var> state 17
  state 17: #1 #2
  state 18: #0 #2
	<var> state 19
  state 19: #0 #2
	<var> state 20
  state 20: #0 #2
}; accum u@(x/*0:0101*/,y/*0:011*/) us/*0:1*/ = x/*0:0101*/:(xs/*0:01*/ when xs/*0:01*/,_/*0:1*/ = check/*2*/ us/*1:1*/ {
  rule #0: xs,_ = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end)&,y/*0:011*/:(ys/*0:1*/ when _/*0:01*/,ys/*0:1*/ = check/*2*/ us/*1:1*/ {
  rule #0: _,ys = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end)& if thunkp us/*0:1*/; accum u@(x/*0:0101*/,y/*0:011*/) us/*0:1*/ = x/*1:0101*/:xs/*0:01*/,y/*1:011*/:ys/*0:1*/ when xs/*0:01*/,ys/*0:1*/ = check/*1*/ us/*0:1*/ {
  rule #0: xs,ys = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end; accum u/*0:01*/ _/*0:1*/ = throw (bad_tuple_value u/*0:01*/) {
  rule #0: accum u@(x,y) us = x:(xs when xs,_ = check us end)&,y:(ys when _,ys = check us end)& if thunkp us
  rule #1: accum u@(x,y) us = x:xs,y:ys when xs,ys = check us end
  rule #2: accum u _ = throw (bad_tuple_value u)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 3
  state 1: #2
	<var> state 2
  state 2: #2
  state 3: #0 #1 #2
	<var> state 4
	<app> state 7
  state 4: #2
	<var> state 5
  state 5: #2
	<var> state 6
  state 6: #2
  state 7: #0 #1 #2
	<var> state 8
	, state 12
  state 8: #2
	<var> state 9
  state 9: #2
	<var> state 10
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #0 #1 #2
	<var> state 13
  state 13: #0 #1 #2
	<var> state 14
  state 14: #0 #1 #2
	<var> state 15
  state 15: #0 #1 #2
} end;
unzip3 [] = [],[],[];
unzip3 us@(_/*0:101*/:_/*0:11*/) = foldr accum/*0*/ ([],[],[]) us/*0:1*/ with check us@(_/*0:101*/,_/*0:1101*/,_/*0:111*/) = us/*0:1*/; check (foldr _/*0:1001*/ _/*0:101*/ us/*0:11*/) = throw (bad_list_value us/*0:11*/); check us/*0:1*/ = throw (bad_tuple_value us/*0:1*/) {
  rule #0: check us@(_,_,_) = us
  rule #1: check (foldr _ _ us) = throw (bad_list_value us)
  rule #2: check us = throw (bad_tuple_value us)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	<app> state 9
	, state 18
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
	foldr state 14
  state 10: #2
	<var> state 11
  state 11: #2
	<var> state 12
  state 12: #2
	<var> state 13
  state 13: #2
  state 14: #1 #2
	<var> state 15
  state 15: #1 #2
	<var> state 16
  state 16: #1 #2
	<var> state 17
  state 17: #1 #2
  state 18: #0 #2
	<var> state 19
  state 19: #0 #2
	<var> state 20
	<app> state 21
  state 20: #2
  state 21: #0 #2
	<var> state 22
	<app> state 24
  state 22: #2
	<var> state 23
  state 23: #2
  state 24: #0 #2
	<var> state 25
	, state 28
  state 25: #2
	<var> state 26
  state 26: #2
	<var> state 27
  state 27: #2
  state 28: #0 #2
	<var> state 29
  state 29: #0 #2
	<var> state 30
  state 30: #0 #2
}; accum u@(x/*0:0101*/,y/*0:01101*/,z/*0:0111*/) us/*0:1*/ = x/*0:0101*/:(xs/*0:01*/ when xs/*0:01*/,_/*0:101*/,_/*0:11*/ = check/*2*/ us/*1:1*/ {
  rule #0: xs,_,_ = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	, state 7
  state 7: #0
	<var> state 8
  state 8: #0
	<var> state 9
  state 9: #0
} end)&,y/*0:01101*/:(ys/*0:101*/ when _/*0:01*/,ys/*0:101*/,_/*0:11*/ = check/*2*/ us/*1:1*/ {
  rule #0: _,ys,_ = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	, state 7
  state 7: #0
	<var> state 8
  state 8: #0
	<var> state 9
  state 9: #0
} end)&,z/*0:0111*/:(zs/*0:11*/ when _/*0:01*/,_/*0:101*/,zs/*0:11*/ = check/*2*/ us/*1:1*/ {
  rule #0: _,_,zs = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	, state 7
  state 7: #0
	<var> state 8
  state 8: #0
	<var> state 9
  state 9: #0
} end)& if thunkp us/*0:1*/; accum u@(x/*0:0101*/,y/*0:01101*/,z/*0:0111*/) us/*0:1*/ = x/*1:0101*/:xs/*0:01*/,y/*1:01101*/:ys/*0:101*/,z/*1:0111*/:zs/*0:11*/ when xs/*0:01*/,ys/*0:101*/,zs/*0:11*/ = check/*1*/ us/*0:1*/ {
  rule #0: xs,ys,zs = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	, state 7
  state 7: #0
	<var> state 8
  state 8: #0
	<var> state 9
  state 9: #0
} end; accum u/*0:01*/ _/*0:1*/ = throw (bad_tuple_value u/*0:01*/) {
  rule #0: accum u@(x,y,z) us = x:(xs when xs,_,_ = check us end)&,y:(ys when _,ys,_ = check us end)&,z:(zs when _,_,zs = check us end)& if thunkp us
  rule #1: accum u@(x,y,z) us = x:xs,y:ys,z:zs when xs,ys,zs = check us end
  rule #2: accum u _ = throw (bad_tuple_value u)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 3
  state 1: #2
	<var> state 2
  state 2: #2
  state 3: #0 #1 #2
	<var> state 4
	<app> state 7
  state 4: #2
	<var> state 5
  state 5: #2
	<var> state 6
  state 6: #2
  state 7: #0 #1 #2
	<var> state 8
	, state 12
  state 8: #2
	<var> state 9
  state 9: #2
	<var> state 10
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #0 #1 #2
	<var> state 13
  state 13: #0 #1 #2
	<var> state 14
	<app> state 16
  state 14: #2
	<var> state 15
  state 15: #2
  state 16: #0 #1 #2
	<var> state 17
	<app> state 20
  state 17: #2
	<var> state 18
  state 18: #2
	<var> state 19
  state 19: #2
  state 20: #0 #1 #2
	<var> state 21
	, state 25
  state 21: #2
	<var> state 22
  state 22: #2
	<var> state 23
  state 23: #2
	<var> state 24
  state 24: #2
  state 25: #0 #1 #2
	<var> state 26
  state 26: #0 #1 #2
	<var> state 27
  state 27: #0 #1 #2
	<var> state 28
  state 28: #0 #1 #2
} end;
def void (catmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (listmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (rowcatmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (colcatmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (rowmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (colmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void x/*0:1*/ = __std__::__voidchk__ x/*0:1*/ x/*0:1*/;
def __std__::__voidchk__ (__ifelse__ y/*0:1001*/ z/*0:101*/ []) = __std__::__voidchk1__ (__ifelse__ y/*0:1001*/ (void z/*0:101*/) ());
def __std__::__voidchk__ (__ifelse__ y/*0:1001*/ z/*0:101*/ {}) = __std__::__voidchk1__ (__ifelse__ y/*0:1001*/ (void z/*0:101*/) ());
def __std__::__voidchk1__ x/*0:01*/ y/*0:1*/ = x/*0:01*/;
{
  rule #0: x,() = x
  rule #1: (),y = y
  rule #2: (x,y),z = x,y,z
  state 0: #0 #1 #2
	<var> state 1
	<app> state 3
	() state 17
  state 1: #0
	() state 2
  state 2: #0
  state 3: #0 #2
	<var> state 4
	<app> state 7
  state 4: #0
	<var> state 5
  state 5: #0
	() state 6
  state 6: #0
  state 7: #0 #2
	<var> state 8
	, state 12
  state 8: #0
	<var> state 9
  state 9: #0
	<var> state 10
  state 10: #0
	() state 11
  state 11: #0
  state 12: #0 #2
	<var> state 13
  state 13: #0 #2
	<var> state 14
  state 14: #0 #2
	<var> state 15
	() state 16
  state 15: #2
  state 16: #0 #2
  state 17: #0 #1
	<var> state 18
	() state 19
  state 18: #1
  state 19: #0 #1
}
{
  rule #0: flip f x y = f y x
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}
{
  rule #0: x::int==y::int = x==y
  rule #1: x::double==y::double = x==y
  rule #2: x::int==y::double = x==y
  rule #3: x::double==y::int = x==y
  rule #4: x::bigint==y::bigint = __C::bigint_cmp x y==0
  rule #5: x::int==y::bigint = bigint x==y
  rule #6: x::bigint==y::int = x==bigint y
  rule #7: x::bigint==y::double = double x==y
  rule #8: x::double==y::bigint = x==double y
  rule #9: x::matrix==y::matrix = x===y if nmatrixp x&&matrix_type x==matrix_type y
  rule #10: x::matrix==y::matrix = cmatrix x===y if nmatrixp x&&cmatrixp y
  rule #11: x::matrix==y::matrix = x===cmatrix y if cmatrixp x&&nmatrixp y
  rule #12: x::matrix==y::matrix = dmatrix x===y if imatrixp x&&dmatrixp y
  rule #13: x::matrix==y::matrix = x===dmatrix y if dmatrixp x&&imatrixp y
  rule #14: x::matrix==y::matrix = 0 if dim x~=dim y
  rule #15: x::matrix==y::matrix = compare 0 with compare i::int = 1 if i>=n; compare i::int = 0 if x!i~=y!i; compare i::int = compare (i+1) end when n::int = #x end
  rule #16: x::string==y::string = __C::strcmp x y==0
  rule #17: (x=>v)==(y=>w) = x==y&&v==w
  rule #18: ()==() = 1
  rule #19: (x,xs)==(y,ys) = x==y&&xs==ys
  rule #20: (x,xs)==_ = 0
  rule #21: ()==_ = 0
  rule #22: _==(x,xs) = 0
  rule #23: _==() = 0
  rule #24: []==[] = 1
  rule #25: x:xs==[] = 0
  rule #26: []==x:xs = 0
  rule #27: x:xs==y:ys = x==y&&xs==ys
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16 #17 #18 #19 #20 #21 #22 #23 #24 #25 #26 #27
	<var> state 1
	<var>::int state 8
	<var>::bigint state 18
	<var>::double state 28
	<var>::string state 38
	<var>::matrix state 46
	<app> state 54
	[] state 113
	() state 124
  state 1: #22 #23
	<app> state 2
	() state 7
  state 2: #22
	<app> state 3
  state 3: #22
	, state 4
  state 4: #22
	<var> state 5
  state 5: #22
	<var> state 6
  state 6: #22
  state 7: #23
  state 8: #0 #2 #5 #22 #23
	<var>::int state 9
	<var>::bigint state 10
	<var>::double state 11
	<app> state 12
	() state 17
  state 9: #0
  state 10: #5
  state 11: #2
  state 12: #22
	<app> state 13
  state 13: #22
	, state 14
  state 14: #22
	<var> state 15
  state 15: #22
	<var> state 16
  state 16: #22
  state 17: #23
  state 18: #4 #6 #7 #22 #23
	<var>::int state 19
	<var>::bigint state 20
	<var>::double state 21
	<app> state 22
	() state 27
  state 19: #6
  state 20: #4
  state 21: #7
  state 22: #22
	<app> state 23
  state 23: #22
	, state 24
  state 24: #22
	<var> state 25
  state 25: #22
	<var> state 26
  state 26: #22
  state 27: #23
  state 28: #1 #3 #8 #22 #23
	<var>::int state 29
	<var>::bigint state 30
	<var>::double state 31
	<app> state 32
	() state 37
  state 29: #3
  state 30: #8
  state 31: #1
  state 32: #22
	<app> state 33
  state 33: #22
	, state 34
  state 34: #22
	<var> state 35
  state 35: #22
	<var> state 36
  state 36: #22
  state 37: #23
  state 38: #16 #22 #23
	<var>::string state 39
	<app> state 40
	() state 45
  state 39: #16
  state 40: #22
	<app> state 41
  state 41: #22
	, state 42
  state 42: #22
	<var> state 43
  state 43: #22
	<var> state 44
  state 44: #22
  state 45: #23
  state 46: #9 #10 #11 #12 #13 #14 #15 #22 #23
	<var>::matrix state 47
	<app> state 48
	() state 53
  state 47: #9 #10 #11 #12 #13 #14 #15
  state 48: #22
	<app> state 49
  state 49: #22
	, state 50
  state 50: #22
	<var> state 51
  state 51: #22
	<var> state 52
  state 52: #22
  state 53: #23
  state 54: #17 #19 #20 #22 #23 #25 #27
	<var> state 55
	<app> state 63
  state 55: #22 #23
	<var> state 56
  state 56: #22 #23
	<app> state 57
	() state 62
  state 57: #22
	<app> state 58
  state 58: #22
	, state 59
  state 59: #22
	<var> state 60
  state 60: #22
	<var> state 61
  state 61: #22
  state 62: #23
  state 63: #17 #19 #20 #22 #23 #25 #27
	<var> state 64
	: state 73
	, state 86
	=> state 101
  state 64: #22 #23
	<var> state 65
  state 65: #22 #23
	<var> state 66
  state 66: #22 #23
	<app> state 67
	() state 72
  state 67: #22
	<app> state 68
  state 68: #22
	, state 69
  state 69: #22
	<var> state 70
  state 70: #22
	<var> state 71
  state 71: #22
  state 72: #23
  state 73: #22 #23 #25 #27
	<var> state 74
  state 74: #22 #23 #25 #27
	<var> state 75
  state 75: #22 #23 #25 #27
	<app> state 76
	[] state 84
	() state 85
  state 76: #22 #27
	<app> state 77
  state 77: #22 #27
	: state 78
	, state 81
  state 78: #27
	<var> state 79
  state 79: #27
	<var> state 80
  state 80: #27
  state 81: #22
	<var> state 82
  state 82: #22
	<var> state 83
  state 83: #22
  state 84: #25
  state 85: #23
  state 86: #19 #20 #22 #23
	<var> state 87
  state 87: #19 #20 #22 #23
	<var> state 88
  state 88: #19 #20 #22 #23
	<var> state 89
	<app> state 90
	() state 100
  state 89: #20
  state 90: #19 #20 #22
	<var> state 91
	<app> state 93
  state 91: #20
	<var> state 92
  state 92: #20
  state 93: #19 #20 #22
	<var> state 94
	, state 97
  state 94: #20
	<var> state 95
  state 95: #20
	<var> state 96
  state 96: #20
  state 97: #19 #20 #22
	<var> state 98
  state 98: #19 #20 #22
	<var> state 99
  state 99: #19 #20 #22
  state 100: #20 #23
  state 101: #17 #22 #23
	<var> state 102
  state 102: #17 #22 #23
	<var> state 103
  state 103: #17 #22 #23
	<app> state 104
	() state 112
  state 104: #17 #22
	<app> state 105
  state 105: #17 #22
	, state 106
	=> state 109
  state 106: #22
	<var> state 107
  state 107: #22
	<var> state 108
  state 108: #22
  state 109: #17
	<var> state 110
  state 110: #17
	<var> state 111
  state 111: #17
  state 112: #23
  state 113: #22 #23 #24 #26
	<app> state 114
	[] state 122
	() state 123
  state 114: #22 #26
	<app> state 115
  state 115: #22 #26
	: state 116
	, state 119
  state 116: #26
	<var> state 117
  state 117: #26
	<var> state 118
  state 118: #26
  state 119: #22
	<var> state 120
  state 120: #22
	<var> state 121
  state 121: #22
  state 122: #24
  state 123: #23
  state 124: #18 #21 #22 #23
	<var> state 125
	<app> state 126
	() state 136
  state 125: #21
  state 126: #21 #22
	<var> state 127
	<app> state 129
  state 127: #21
	<var> state 128
  state 128: #21
  state 129: #21 #22
	<var> state 130
	, state 133
  state 130: #21
	<var> state 131
  state 131: #21
	<var> state 132
  state 132: #21
  state 133: #21 #22
	<var> state 134
  state 134: #21 #22
	<var> state 135
  state 135: #21 #22
  state 136: #18 #21 #23
}
{
  rule #0: x::int~=y::int = x~=y
  rule #1: x::double~=y::double = x~=y
  rule #2: x::int~=y::double = x~=y
  rule #3: x::double~=y::int = x~=y
  rule #4: x::bigint~=y::bigint = __C::bigint_cmp x y~=0
  rule #5: x::int~=y::bigint = bigint x~=y
  rule #6: x::bigint~=y::int = x~=bigint y
  rule #7: x::bigint~=y::double = double x~=y
  rule #8: x::double~=y::bigint = x~=double y
  rule #9: x::matrix~=y::matrix = ~x==y
  rule #10: x::string~=y::string = __C::strcmp x y~=0
  rule #11: (x=>v)~=(y=>w) = x~=y||v~=w
  rule #12: ()~=() = 0
  rule #13: (x,xs)~=(y,ys) = x~=y||xs~=ys
  rule #14: (x,xs)~=_ = 1
  rule #15: ()~=_ = 1
  rule #16: _~=(x,xs) = 1
  rule #17: _~=() = 1
  rule #18: []~=[] = 0
  rule #19: x:xs~=[] = 1
  rule #20: []~=x:xs = 1
  rule #21: x:xs~=y:ys = x~=y||xs~=ys
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16 #17 #18 #19 #20 #21
	<var> state 1
	<var>::int state 8
	<var>::bigint state 18
	<var>::double state 28
	<var>::string state 38
	<var>::matrix state 46
	<app> state 54
	[] state 113
	() state 124
  state 1: #16 #17
	<app> state 2
	() state 7
  state 2: #16
	<app> state 3
  state 3: #16
	, state 4
  state 4: #16
	<var> state 5
  state 5: #16
	<var> state 6
  state 6: #16
  state 7: #17
  state 8: #0 #2 #5 #16 #17
	<var>::int state 9
	<var>::bigint state 10
	<var>::double state 11
	<app> state 12
	() state 17
  state 9: #0
  state 10: #5
  state 11: #2
  state 12: #16
	<app> state 13
  state 13: #16
	, state 14
  state 14: #16
	<var> state 15
  state 15: #16
	<var> state 16
  state 16: #16
  state 17: #17
  state 18: #4 #6 #7 #16 #17
	<var>::int state 19
	<var>::bigint state 20
	<var>::double state 21
	<app> state 22
	() state 27
  state 19: #6
  state 20: #4
  state 21: #7
  state 22: #16
	<app> state 23
  state 23: #16
	, state 24
  state 24: #16
	<var> state 25
  state 25: #16
	<var> state 26
  state 26: #16
  state 27: #17
  state 28: #1 #3 #8 #16 #17
	<var>::int state 29
	<var>::bigint state 30
	<var>::double state 31
	<app> state 32
	() state 37
  state 29: #3
  state 30: #8
  state 31: #1
  state 32: #16
	<app> state 33
  state 33: #16
	, state 34
  state 34: #16
	<var> state 35
  state 35: #16
	<var> state 36
  state 36: #16
  state 37: #17
  state 38: #10 #16 #17
	<var>::string state 39
	<app> state 40
	() state 45
  state 39: #10
  state 40: #16
	<app> state 41
  state 41: #16
	, state 42
  state 42: #16
	<var> state 43
  state 43: #16
	<var> state 44
  state 44: #16
  state 45: #17
  state 46: #9 #16 #17
	<var>::matrix state 47
	<app> state 48
	() state 53
  state 47: #9
  state 48: #16
	<app> state 49
  state 49: #16
	, state 50
  state 50: #16
	<var> state 51
  state 51: #16
	<var> state 52
  state 52: #16
  state 53: #17
  state 54: #11 #13 #14 #16 #17 #19 #21
	<var> state 55
	<app> state 63
  state 55: #16 #17
	<var> state 56
  state 56: #16 #17
	<app> state 57
	() state 62
  state 57: #16
	<app> state 58
  state 58: #16
	, state 59
  state 59: #16
	<var> state 60
  state 60: #16
	<var> state 61
  state 61: #16
  state 62: #17
  state 63: #11 #13 #14 #16 #17 #19 #21
	<var> state 64
	: state 73
	, state 86
	=> state 101
  state 64: #16 #17
	<var> state 65
  state 65: #16 #17
	<var> state 66
  state 66: #16 #17
	<app> state 67
	() state 72
  state 67: #16
	<app> state 68
  state 68: #16
	, state 69
  state 69: #16
	<var> state 70
  state 70: #16
	<var> state 71
  state 71: #16
  state 72: #17
  state 73: #16 #17 #19 #21
	<var> state 74
  state 74: #16 #17 #19 #21
	<var> state 75
  state 75: #16 #17 #19 #21
	<app> state 76
	[] state 84
	() state 85
  state 76: #16 #21
	<app> state 77
  state 77: #16 #21
	: state 78
	, state 81
  state 78: #21
	<var> state 79
  state 79: #21
	<var> state 80
  state 80: #21
  state 81: #16
	<var> state 82
  state 82: #16
	<var> state 83
  state 83: #16
  state 84: #19
  state 85: #17
  state 86: #13 #14 #16 #17
	<var> state 87
  state 87: #13 #14 #16 #17
	<var> state 88
  state 88: #13 #14 #16 #17
	<var> state 89
	<app> state 90
	() state 100
  state 89: #14
  state 90: #13 #14 #16
	<var> state 91
	<app> state 93
  state 91: #14
	<var> state 92
  state 92: #14
  state 93: #13 #14 #16
	<var> state 94
	, state 97
  state 94: #14
	<var> state 95
  state 95: #14
	<var> state 96
  state 96: #14
  state 97: #13 #14 #16
	<var> state 98
  state 98: #13 #14 #16
	<var> state 99
  state 99: #13 #14 #16
  state 100: #14 #17
  state 101: #11 #16 #17
	<var> state 102
  state 102: #11 #16 #17
	<var> state 103
  state 103: #11 #16 #17
	<app> state 104
	() state 112
  state 104: #11 #16
	<app> state 105
  state 105: #11 #16
	, state 106
	=> state 109
  state 106: #16
	<var> state 107
  state 107: #16
	<var> state 108
  state 108: #16
  state 109: #11
	<var> state 110
  state 110: #11
	<var> state 111
  state 111: #11
  state 112: #17
  state 113: #16 #17 #18 #20
	<app> state 114
	[] state 122
	() state 123
  state 114: #16 #20
	<app> state 115
  state 115: #16 #20
	: state 116
	, state 119
  state 116: #20
	<var> state 117
  state 117: #20
	<var> state 118
  state 118: #20
  state 119: #16
	<var> state 120
  state 120: #16
	<var> state 121
  state 121: #16
  state 122: #18
  state 123: #17
  state 124: #12 #15 #16 #17
	<var> state 125
	<app> state 126
	() state 136
  state 125: #15
  state 126: #15 #16
	<var> state 127
	<app> state 129
  state 127: #15
	<var> state 128
  state 128: #15
  state 129: #15 #16
	<var> state 130
	, state 133
  state 130: #15
	<var> state 131
  state 131: #15
	<var> state 132
  state 132: #15
  state 133: #15 #16
	<var> state 134
  state 134: #15 #16
	<var> state 135
  state 135: #15 #16
  state 136: #12 #15 #17
}
{
  rule #0: x::int+y::int = x+y
  rule #1: x::double+y::double = x+y
  rule #2: x::int+y::double = x+y
  rule #3: x::double+y::int = x+y
  rule #4: x::bigint+y::bigint = __C::bigint_add x y
  rule #5: x::int+y::bigint = bigint x+y
  rule #6: x::bigint+y::int = x+bigint y
  rule #7: x::bigint+y::double = double x+y
  rule #8: x::double+y::bigint = x+double y
  rule #9: s::string+n::int = chr (ord s+n) if #s==1
  rule #10: s::string+t::string = __C::string_concat s t
  rule #11: s::string+[] = chars s
  rule #12: s::string+xs@(_:_) = chars s+xs
  rule #13: []+s::string = chars s
  rule #14: xs@(_:_)+s::string = xs+chars s
  rule #15: []+ys = ys
  rule #16: xs@(_:_)+ys = tick [] xs ys with tick zs (x:xs) ys = tack (x:zs) ((xs+ys)&) if thunkp xs; tick zs (x:xs) ys = tick (x:zs) xs ys; tick zs [] ys = tack zs ys; tick zs xs ys = tack zs (xs+ys); tack (x:xs) ys = tack xs (x:ys); tack [] ys = ys end
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
	<var>::string state 13
	<app> state 22
	[] state 29
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
  state 13: #9 #10 #11 #12
	<var>::int state 14
	<var>::string state 15
	<app> state 16
	[] state 21
  state 14: #9
  state 15: #10
  state 16: #12
	<app> state 17
  state 17: #12
	: state 18
  state 18: #12
	<var> state 19
  state 19: #12
	<var> state 20
  state 20: #12
  state 21: #11
  state 22: #14 #16
	<app> state 23
  state 23: #14 #16
	: state 24
  state 24: #14 #16
	<var> state 25
  state 25: #14 #16
	<var> state 26
  state 26: #14 #16
	<var> state 27
	<var>::string state 28
  state 27: #16
  state 28: #14 #16
  state 29: #13 #15
	<var> state 30
	<var>::string state 31
  state 30: #15
  state 31: #13 #15
}
{
  rule #0: catmap f x::matrix = cat (list (map f x))
  rule #1: catmap f s::string = catmap f (chars s)
  rule #2: catmap f [] = []
  rule #3: catmap f xs@(_:_) = cat (map f xs)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: listmap f x::matrix = list (map f x)
  rule #1: listmap f s::string = map f (chars s)
  rule #2: listmap f [] = []
  rule #3: listmap f xs@(_:_) = map f xs
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: f$x = f x
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: n::int..m::int = __C::pure_int_seq n m 1
  rule #1: n1::int:n2::int..m::int = __C::pure_int_seq n1 m (n2-n1) if n1~=n2
  rule #2: n::double..m::double = __C::pure_double_seq n m 1.0 if ~infp n&&~infp m
  rule #3: n::int..m::double = __C::pure_double_seq (double n) m 1.0 if ~infp m
  rule #4: n::double..m::int = __C::pure_double_seq n (double m) 1.0 if ~infp n
  rule #5: n1::double:n2::double..m::double = __C::pure_double_seq n1 m (n2-n1) if ~infp n1&&~infp m&&n1~=n2
  rule #6: n1::int:n2::double..m::double = __C::pure_double_seq (double n1) m (n2-n1) if ~infp m&&n1~=n2
  rule #7: n1::double:n2::int..m::double = __C::pure_double_seq n1 m (n2-n1) if ~infp n1&&~infp m&&n1~=n2
  rule #8: n1::double:n2::double..m::int = __C::pure_double_seq n1 (double m) (n2-n1) if ~infp n1&&n1~=n2
  rule #9: n1::int:n2::int..m::double = __C::pure_double_seq (double n1) m (double (n2-n1)) if ~infp m&&n1~=n2
  rule #10: n1::int:n2::double..m::int = __C::pure_double_seq (double n1) (double m) (n2-n1) if n1~=n2
  rule #11: n1::double:n2::int..m::int = __C::pure_double_seq n1 (double m) (n2-n1) if ~infp n1&&n1~=n2
  rule #12: a::string..b::string = map chr (ord a..ord b) if charp a&&charp b
  rule #13: a::string:b::string..c::string = map chr (ord a:ord b..ord c) if charp a&&charp b&&charp c
  rule #14: n1:n2..m = if nanp n1||nanp m||double m===-s then [] else if double m===s then iterate (flip (+) k) n1 else iterwhile (p (m+0.5*k)) (flip (+) k) n1 when s,p = if k>0 then inf,(>=) else -inf,(<=) end if realp k&&k~=0&&~infp n1&&~infp n2 when k = n2-n1 end
  rule #15: n..m = if nanp n||nanp m||double m===-inf then [] else if double m===inf then iterate (flip (+) 1) n else iterwhile ((>=) m) (flip (+) 1) n if ~listp n&&~infp n
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15
	<var> state 1
	<var>::int state 3
	<var>::double state 7
	<var>::string state 11
	<app> state 14
  state 1: #15
	<var> state 2
  state 2: #15
  state 3: #0 #3 #15
	<var> state 4
	<var>::int state 5
	<var>::double state 6
  state 4: #15
  state 5: #0 #15
  state 6: #3 #15
  state 7: #2 #4 #15
	<var> state 8
	<var>::int state 9
	<var>::double state 10
  state 8: #15
  state 9: #4 #15
  state 10: #2 #15
  state 11: #12 #15
	<var> state 12
	<var>::string state 13
  state 12: #15
  state 13: #12 #15
  state 14: #1 #5 #6 #7 #8 #9 #10 #11 #13 #14 #15
	<var> state 15
	<app> state 18
  state 15: #15
	<var> state 16
  state 16: #15
	<var> state 17
  state 17: #15
  state 18: #1 #5 #6 #7 #8 #9 #10 #11 #13 #14 #15
	<var> state 19
	: state 23
  state 19: #15
	<var> state 20
  state 20: #15
	<var> state 21
  state 21: #15
	<var> state 22
  state 22: #15
  state 23: #1 #5 #6 #7 #8 #9 #10 #11 #13 #14 #15
	<var> state 24
	<var>::int state 27
	<var>::double state 38
	<var>::string state 49
  state 24: #14 #15
	<var> state 25
  state 25: #14 #15
	<var> state 26
  state 26: #14 #15
  state 27: #1 #6 #9 #10 #14 #15
	<var> state 28
	<var>::int state 30
	<var>::double state 34
  state 28: #14 #15
	<var> state 29
  state 29: #14 #15
  state 30: #1 #9 #14 #15
	<var> state 31
	<var>::int state 32
	<var>::double state 33
  state 31: #14 #15
  state 32: #1 #14 #15
  state 33: #9 #14 #15
  state 34: #6 #10 #14 #15
	<var> state 35
	<var>::int state 36
	<var>::double state 37
  state 35: #14 #15
  state 36: #10 #14 #15
  state 37: #6 #14 #15
  state 38: #5 #7 #8 #11 #14 #15
	<var> state 39
	<var>::int state 41
	<var>::double state 45
  state 39: #14 #15
	<var> state 40
  state 40: #14 #15
  state 41: #7 #11 #14 #15
	<var> state 42
	<var>::int state 43
	<var>::double state 44
  state 42: #14 #15
  state 43: #11 #14 #15
  state 44: #7 #14 #15
  state 45: #5 #8 #14 #15
	<var> state 46
	<var>::int state 47
	<var>::double state 48
  state 46: #14 #15
  state 47: #8 #14 #15
  state 48: #5 #14 #15
  state 49: #13 #14 #15
	<var> state 50
	<var>::string state 52
  state 50: #14 #15
	<var> state 51
  state 51: #14 #15
  state 52: #13 #14 #15
	<var> state 53
	<var>::string state 54
  state 53: #14 #15
  state 54: #13 #14 #15
}
{
  rule #0: #p::pointer = blob_size p if blobp p
  rule #1: #x::matrix = __C::matrix_size x
  rule #2: #s::string = __C::string_size s
  rule #3: #() = 0
  rule #4: #(x,xs) = accum 1 xs with accum n::int (x,xs) = accum (n+1) xs; accum n::int x = n+1 end
  rule #5: #[] = 0
  rule #6: #(x:xs) = accum 1 xs with accum n::int (x:xs) = accum (n+1) xs; accum n::int [] = n; accum n::int xs = n+#xs end
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var>::string state 1
	<var>::pointer state 2
	<var>::matrix state 3
	<app> state 4
	[] state 12
	() state 13
  state 1: #2
  state 2: #0
  state 3: #1
  state 4: #4 #6
	<app> state 5
  state 5: #4 #6
	: state 6
	, state 9
  state 6: #6
	<var> state 7
  state 7: #6
	<var> state 8
  state 8: #6
  state 9: #4
	<var> state 10
  state 10: #4
	<var> state 11
  state 11: #4
  state 12: #5
  state 13: #3
}
{
  rule #0: x::matrix!i::int = __C::matrix_elem_at x i if i>=0&&i<#x
  rule #1: x::matrix!i::int = throw out_of_bounds
  rule #2: x::matrix!(i::int,j::int) = __C::matrix_elem_at2 x i j if (i>=0&&i<n&&j>=0&&j<m when n::int,m::int = dim x end)
  rule #3: x::matrix!(i::int,j::int) = throw out_of_bounds
  rule #4: x::matrix!y = __C::record_elem_at x y if recordp x
  rule #5: s::string!n::int = __C::string_char_at s n if n>=0&&n<#s
  rule #6: s::string!n::int = throw out_of_bounds
  rule #7: (x,xs)!n::int = throw out_of_bounds if n<0
  rule #8: (x,xs)!0 = x
  rule #9: (x,y,xs)!n::int = (y,xs)!(n-1)
  rule #10: (x,y)!1 = y
  rule #11: (x,y)!n::int = throw out_of_bounds
  rule #12: ()!n::int = throw out_of_bounds
  rule #13: []!n::int = throw out_of_bounds
  rule #14: (x:xs)!0 = x
  rule #15: (x:xs)!n::int = xs!(n-1) if n>0
  rule #16: (x:xs)!n::int = throw out_of_bounds
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16
	<var>::string state 1
	<var>::matrix state 3
	<app> state 19
	[] state 51
	() state 53
  state 1: #5 #6
	<var>::int state 2
  state 2: #5 #6
  state 3: #0 #1 #2 #3 #4
	<var> state 4
	<var>::int state 5
	<app> state 6
  state 4: #4
  state 5: #0 #1 #4
  state 6: #2 #3 #4
	<var> state 7
	<app> state 9
  state 7: #4
	<var> state 8
  state 8: #4
  state 9: #2 #3 #4
	<var> state 10
	, state 13
  state 10: #4
	<var> state 11
  state 11: #4
	<var> state 12
  state 12: #4
  state 13: #2 #3 #4
	<var> state 14
	<var>::int state 16
  state 14: #4
	<var> state 15
  state 15: #4
  state 16: #2 #3 #4
	<var> state 17
	<var>::int state 18
  state 17: #4
  state 18: #2 #3 #4
  state 19: #7 #8 #9 #10 #11 #14 #15 #16
	<app> state 20
  state 20: #7 #8 #9 #10 #11 #14 #15 #16
	: state 21
	, state 26
  state 21: #14 #15 #16
	<var> state 22
  state 22: #14 #15 #16
	<var> state 23
  state 23: #14 #15 #16
	<var>::int state 24
	0::int state 25
  state 24: #15 #16
  state 25: #14 #15 #16
  state 26: #7 #8 #9 #10 #11
	<var> state 27
  state 27: #7 #8 #9 #10 #11
	<var> state 28
	<app> state 32
  state 28: #7 #8 #10 #11
	<var>::int state 29
	0::int state 30
	1::int state 31
  state 29: #7 #11
  state 30: #7 #8 #11
  state 31: #7 #10 #11
  state 32: #7 #8 #9 #10 #11
	<var> state 33
	<app> state 38
  state 33: #7 #8 #10 #11
	<var> state 34
  state 34: #7 #8 #10 #11
	<var>::int state 35
	0::int state 36
	1::int state 37
  state 35: #7 #11
  state 36: #7 #8 #11
  state 37: #7 #10 #11
  state 38: #7 #8 #9 #10 #11
	<var> state 39
	, state 45
  state 39: #7 #8 #10 #11
	<var> state 40
  state 40: #7 #8 #10 #11
	<var> state 41
  state 41: #7 #8 #10 #11
	<var>::int state 42
	0::int state 43
	1::int state 44
  state 42: #7 #11
  state 43: #7 #8 #11
  state 44: #7 #10 #11
  state 45: #7 #8 #9 #10 #11
	<var> state 46
  state 46: #7 #8 #9 #10 #11
	<var> state 47
  state 47: #7 #8 #9 #10 #11
	<var>::int state 48
	0::int state 49
	1::int state 50
  state 48: #7 #9 #11
  state 49: #7 #8 #9 #11
  state 50: #7 #9 #10 #11
  state 51: #13
	<var>::int state 52
  state 52: #13
  state 53: #12
	<var>::int state 54
  state 54: #12
}
{
  rule #0: x!!ns::matrix = x!!list ns
  rule #1: x!!(ns::matrix,ms) = x!!(list ns,ms) if ~tuplep ms
  rule #2: x!!(ns,ms::matrix) = x!!(ns,list ms)
  rule #3: x!!(ns::int,ms) = x!!([ns],ms) if ~tuplep ms
  rule #4: x!!(ns,ms::int) = x!!(ns,[ms])
  rule #5: x::matrix!!(ns,ms) = case ns,ms of ns@(n:_),ms@(m:_) = submat x (n,m) (#ns,#ms) if cont ns&&cont ms; _ = colcatmap (mth (rowcatmap (nth x) ns)) ms end with cont [n::int] = 1; cont (n::int:ns@(m::int:_)) = cont ns if m==n+1; cont _ = 0; mth x m = catch (cst {}) (col x m); nth x n = catch (cst {}) (row x n) end
  rule #6: x::matrix!!ns = if all intp ns&&packed x then rowvector x!!([0],ns) else colcatmap (nth x) ns with nth x n = catch (cst {}) {x!n} end
  rule #7: s::string!!ns = case ns of ns@(n:_) = substr s n (count ns) if cont ns; _ = string (chars s!!ns) end with cont [n::int] = 1; cont (n::int:ns@(m::int:_)) = cont ns if m==n+1; cont _ = 0; count ns = #dropwhile (\n::int -> n<0) ns end
  rule #8: xs@()!!ns = tuple (list xs!!ns)
  rule #9: xs@(_,_)!!ns = tuple (list xs!!ns)
  rule #10: xs!!ns = ys if ok ys when ys = case ns of ns@(n::int:_) = list (take (count ns) (drop n xs)) if listp xs&&cont ns; _ = catmap (nth xs) ns end end with cont (n::int:ns) = ~thunkp ns&&(case ns of [] = 1; m::int:_ = cont ns if m==n+1; _ = 0 end); nth xs n = catch (cst []) [xs!n]; count ns = #dropwhile (\n::int -> n<0) ns; ok (catmap (nth _) _) = 0; ok _ = 1 end
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10
	<var> state 1
	<var>::string state 24
	<var>::matrix state 47
	<app> state 70
	() state 146
  state 1: #0 #1 #2 #3 #4 #10
	<var> state 2
	<var>::matrix state 3
	<app> state 4
  state 2: #10
  state 3: #0 #10
  state 4: #1 #2 #3 #4 #10
	<var> state 5
	<app> state 7
  state 5: #10
	<var> state 6
  state 6: #10
  state 7: #1 #2 #3 #4 #10
	<var> state 8
	, state 11
  state 8: #10
	<var> state 9
  state 9: #10
	<var> state 10
  state 10: #10
  state 11: #1 #2 #3 #4 #10
	<var> state 12
	<var>::int state 16
	<var>::matrix state 20
  state 12: #2 #4 #10
	<var> state 13
	<var>::int state 14
	<var>::matrix state 15
  state 13: #10
  state 14: #4 #10
  state 15: #2 #10
  state 16: #2 #3 #4 #10
	<var> state 17
	<var>::int state 18
	<var>::matrix state 19
  state 17: #3 #10
  state 18: #3 #4 #10
  state 19: #2 #3 #10
  state 20: #1 #2 #4 #10
	<var> state 21
	<var>::int state 22
	<var>::matrix state 23
  state 21: #1 #10
  state 22: #1 #4 #10
  state 23: #1 #2 #10
  state 24: #0 #1 #2 #3 #4 #7 #10
	<var> state 25
	<var>::matrix state 26
	<app> state 27
  state 25: #7 #10
  state 26: #0 #7 #10
  state 27: #1 #2 #3 #4 #7 #10
	<var> state 28
	<app> state 30
  state 28: #7 #10
	<var> state 29
  state 29: #7 #10
  state 30: #1 #2 #3 #4 #7 #10
	<var> state 31
	, state 34
  state 31: #7 #10
	<var> state 32
  state 32: #7 #10
	<var> state 33
  state 33: #7 #10
  state 34: #1 #2 #3 #4 #7 #10
	<var> state 35
	<var>::int state 39
	<var>::matrix state 43
  state 35: #2 #4 #7 #10
	<var> state 36
	<var>::int state 37
	<var>::matrix state 38
  state 36: #7 #10
  state 37: #4 #7 #10
  state 38: #2 #7 #10
  state 39: #2 #3 #4 #7 #10
	<var> state 40
	<var>::int state 41
	<var>::matrix state 42
  state 40: #3 #7 #10
  state 41: #3 #4 #7 #10
  state 42: #2 #3 #7 #10
  state 43: #1 #2 #4 #7 #10
	<var> state 44
	<var>::int state 45
	<var>::matrix state 46
  state 44: #1 #7 #10
  state 45: #1 #4 #7 #10
  state 46: #1 #2 #7 #10
  state 47: #0 #1 #2 #3 #4 #5 #6 #10
	<var> state 48
	<var>::matrix state 49
	<app> state 50
  state 48: #6 #10
  state 49: #0 #6 #10
  state 50: #1 #2 #3 #4 #5 #6 #10
	<var> state 51
	<app> state 53
  state 51: #6 #10
	<var> state 52
  state 52: #6 #10
  state 53: #1 #2 #3 #4 #5 #6 #10
	<var> state 54
	, state 57
  state 54: #6 #10
	<var> state 55
  state 55: #6 #10
	<var> state 56
  state 56: #6 #10
  state 57: #1 #2 #3 #4 #5 #6 #10
	<var> state 58
	<var>::int state 62
	<var>::matrix state 66
  state 58: #2 #4 #5 #6 #10
	<var> state 59
	<var>::int state 60
	<var>::matrix state 61
  state 59: #5 #6 #10
  state 60: #4 #5 #6 #10
  state 61: #2 #5 #6 #10
  state 62: #2 #3 #4 #5 #6 #10
	<var> state 63
	<var>::int state 64
	<var>::matrix state 65
  state 63: #3 #5 #6 #10
  state 64: #3 #4 #5 #6 #10
  state 65: #2 #3 #5 #6 #10
  state 66: #1 #2 #4 #5 #6 #10
	<var> state 67
	<var>::int state 68
	<var>::matrix state 69
  state 67: #1 #5 #6 #10
  state 68: #1 #4 #5 #6 #10
  state 69: #1 #2 #5 #6 #10
  state 70: #0 #1 #2 #3 #4 #9 #10
	<var> state 71
	<app> state 95
  state 71: #0 #1 #2 #3 #4 #10
	<var> state 72
  state 72: #0 #1 #2 #3 #4 #10
	<var> state 73
	<var>::matrix state 74
	<app> state 75
  state 73: #10
  state 74: #0 #10
  state 75: #1 #2 #3 #4 #10
	<var> state 76
	<app> state 78
  state 76: #10
	<var> state 77
  state 77: #10
  state 78: #1 #2 #3 #4 #10
	<var> state 79
	, state 82
  state 79: #10
	<var> state 80
  state 80: #10
	<var> state 81
  state 81: #10
  state 82: #1 #2 #3 #4 #10
	<var> state 83
	<var>::int state 87
	<var>::matrix state 91
  state 83: #2 #4 #10
	<var> state 84
	<var>::int state 85
	<var>::matrix state 86
  state 84: #10
  state 85: #4 #10
  state 86: #2 #10
  state 87: #2 #3 #4 #10
	<var> state 88
	<var>::int state 89
	<var>::matrix state 90
  state 88: #3 #10
  state 89: #3 #4 #10
  state 90: #2 #3 #10
  state 91: #1 #2 #4 #10
	<var> state 92
	<var>::int state 93
	<var>::matrix state 94
  state 92: #1 #10
  state 93: #1 #4 #10
  state 94: #1 #2 #10
  state 95: #0 #1 #2 #3 #4 #9 #10
	<var> state 96
	, state 121
  state 96: #0 #1 #2 #3 #4 #10
	<var> state 97
  state 97: #0 #1 #2 #3 #4 #10
	<var> state 98
  state 98: #0 #1 #2 #3 #4 #10
	<var> state 99
	<var>::matrix state 100
	<app> state 101
  state 99: #10
  state 100: #0 #10
  state 101: #1 #2 #3 #4 #10
	<var> state 102
	<app> state 104
  state 102: #10
	<var> state 103
  state 103: #10
  state 104: #1 #2 #3 #4 #10
	<var> state 105
	, state 108
  state 105: #10
	<var> state 106
  state 106: #10
	<var> state 107
  state 107: #10
  state 108: #1 #2 #3 #4 #10
	<var> state 109
	<var>::int state 113
	<var>::matrix state 117
  state 109: #2 #4 #10
	<var> state 110
	<var>::int state 111
	<var>::matrix state 112
  state 110: #10
  state 111: #4 #10
  state 112: #2 #10
  state 113: #2 #3 #4 #10
	<var> state 114
	<var>::int state 115
	<var>::matrix state 116
  state 114: #3 #10
  state 115: #3 #4 #10
  state 116: #2 #3 #10
  state 117: #1 #2 #4 #10
	<var> state 118
	<var>::int state 119
	<var>::matrix state 120
  state 118: #1 #10
  state 119: #1 #4 #10
  state 120: #1 #2 #10
  state 121: #0 #1 #2 #3 #4 #9 #10
	<var> state 122
  state 122: #0 #1 #2 #3 #4 #9 #10
	<var> state 123
  state 123: #0 #1 #2 #3 #4 #9 #10
	<var> state 124
	<var>::matrix state 125
	<app> state 126
  state 124: #9 #10
  state 125: #0 #9 #10
  state 126: #1 #2 #3 #4 #9 #10
	<var> state 127
	<app> state 129
  state 127: #9 #10
	<var> state 128
  state 128: #9 #10
  state 129: #1 #2 #3 #4 #9 #10
	<var> state 130
	, state 133
  state 130: #9 #10
	<var> state 131
  state 131: #9 #10
	<var> state 132
  state 132: #9 #10
  state 133: #1 #2 #3 #4 #9 #10
	<var> state 134
	<var>::int state 138
	<var>::matrix state 142
  state 134: #2 #4 #9 #10
	<var> state 135
	<var>::int state 136
	<var>::matrix state 137
  state 135: #9 #10
  state 136: #4 #9 #10
  state 137: #2 #9 #10
  state 138: #2 #3 #4 #9 #10
	<var> state 139
	<var>::int state 140
	<var>::matrix state 141
  state 139: #3 #9 #10
  state 140: #3 #4 #9 #10
  state 141: #2 #3 #9 #10
  state 142: #1 #2 #4 #9 #10
	<var> state 143
	<var>::int state 144
	<var>::matrix state 145
  state 143: #1 #9 #10
  state 144: #1 #4 #9 #10
  state 145: #1 #2 #9 #10
  state 146: #0 #1 #2 #3 #4 #8 #10
	<var> state 147
	<var>::matrix state 148
	<app> state 149
  state 147: #8 #10
  state 148: #0 #8 #10
  state 149: #1 #2 #3 #4 #8 #10
	<var> state 150
	<app> state 152
  state 150: #8 #10
	<var> state 151
  state 151: #8 #10
  state 152: #1 #2 #3 #4 #8 #10
	<var> state 153
	, state 156
  state 153: #8 #10
	<var> state 154
  state 154: #8 #10
	<var> state 155
  state 155: #8 #10
  state 156: #1 #2 #3 #4 #8 #10
	<var> state 157
	<var>::int state 161
	<var>::matrix state 165
  state 157: #2 #4 #8 #10
	<var> state 158
	<var>::int state 159
	<var>::matrix state 160
  state 158: #8 #10
  state 159: #4 #8 #10
  state 160: #2 #8 #10
  state 161: #2 #3 #4 #8 #10
	<var> state 162
	<var>::int state 163
	<var>::matrix state 164
  state 162: #3 #8 #10
  state 163: #3 #4 #8 #10
  state 164: #2 #3 #8 #10
  state 165: #1 #2 #4 #8 #10
	<var> state 166
	<var>::int state 167
	<var>::matrix state 168
  state 166: #1 #8 #10
  state 167: #1 #4 #8 #10
  state 168: #1 #2 #8 #10
}
{
  rule #0: (f.g) x = f (g x)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}
{
  rule #0: val (x=>v) = v
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	=> state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}
{
  rule #0: list x::matrix = listmap (\i -> x!i) (0..#x-1)
  rule #1: list s::string = chars s
  rule #2: list () = []
  rule #3: list (x,xs) = accum [x] xs with accum ys (x,xs) = accum (x:ys) xs; accum ys x = reverse (x:ys) end
  rule #4: list [] = []
  rule #5: list (x:xs) = accum [x] xs with accum ys (x:xs) = accum (x:ys) xs; accum ys [] = reverse ys; accum ys xs = throw (bad_list_value xs) end
  state 0: #0 #1 #2 #3 #4 #5
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
	[] state 11
	() state 12
  state 1: #1
  state 2: #0
  state 3: #3 #5
	<app> state 4
  state 4: #3 #5
	: state 5
	, state 8
  state 5: #5
	<var> state 6
  state 6: #5
	<var> state 7
  state 7: #5
  state 8: #3
	<var> state 9
  state 9: #3
	<var> state 10
  state 10: #3
  state 11: #4
  state 12: #2
}
{
  rule #0: tuple x::matrix = tuple (list x)
  rule #1: tuple s::string = tuple (chars s)
  rule #2: tuple [] = ()
  rule #3: tuple (x:xs) = accum (t x) xs with t x@(_,_) = reverse x; t x = x; accum ys (x:xs) = accum (t x,ys) xs; accum ys [] = t ys; accum ys xs = throw (bad_list_value xs) end
  rule #4: tuple x@() = x
  rule #5: tuple x@(_,_) = x
  state 0: #0 #1 #2 #3 #4 #5
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
	[] state 11
	() state 12
  state 1: #1
  state 2: #0
  state 3: #3 #5
	<app> state 4
  state 4: #3 #5
	: state 5
	, state 8
  state 5: #3
	<var> state 6
  state 6: #3
	<var> state 7
  state 7: #3
  state 8: #5
	<var> state 9
  state 9: #5
	<var> state 10
  state 10: #5
  state 11: #2
  state 12: #4
}
{
  rule #0: null x::pointer = x===#<pointer 0> if __C::pure_pointer_equal (get_ptrtag x)===#<pointer 0>
  rule #1: null x::matrix = #x==0
  rule #2: null s::string = __C::string_null s
  rule #3: null () = 1
  rule #4: null (x,xs) = 0
  rule #5: null [] = 1
  rule #6: null (x:xs) = 0
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var>::string state 1
	<var>::pointer state 2
	<var>::matrix state 3
	<app> state 4
	[] state 12
	() state 13
  state 1: #2
  state 2: #0
  state 3: #1
  state 4: #4 #6
	<app> state 5
  state 5: #4 #6
	: state 6
	, state 9
  state 6: #6
	<var> state 7
  state 7: #6
	<var> state 8
  state 8: #6
  state 9: #4
	<var> state 10
  state 10: #4
	<var> state 11
  state 11: #4
  state 12: #5
  state 13: #3
}
{
  rule #0: all p x::matrix = __C::matrix_all p x
  rule #1: all p s::string = all p (chars s)
  rule #2: all p [] = 1
  rule #3: all p (x:xs) = p x&&all p xs
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: any p x::matrix = __C::matrix_any p x
  rule #1: any p s::string = any p (chars s)
  rule #2: any p [] = 0
  rule #3: any p (x:xs) = p x||any p xs
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: cat [] = []
  rule #1: cat xs@(_:_) = foldr (tick []) [] xs with foldr f a [] = a; foldr f a xs@(_:_) = tick [] xs with tick zs (x:xs) = tack (x:zs) (foldr f a xs&) if thunkp xs; tick zs (x:xs) = tick (x:zs) xs; tick zs [] = tack zs a; tick zs xs = tack zs (foldr f a xs); tack (x:xs) y = tack xs (f x y); tack [] y = y end; foldr (tick _) [] x = cat x; tick zs (x:xs) ys = tack (x:zs) (tick [] xs ys&) if thunkp xs; tick zs (x:xs) ys = tick (x:zs) xs ys; tick zs [] ys = tack zs ys; tick zs xs ys = tack zs (xs+ys); tack (x:xs) ys = tack xs (x:ys); tack [] ys = ys end
  state 0: #0 #1
	<app> state 1
	[] state 6
  state 1: #1
	<app> state 2
  state 2: #1
	: state 3
  state 3: #1
	<var> state 4
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0
}
{
  rule #0: cst x y = x
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: do f x::matrix = __C::matrix_do f x
  rule #1: do f s::string = do f (chars s)
  rule #2: do f [] = ()
  rule #3: do f (x:xs) = f x$$do f xs
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: map f x::matrix = __C::matrix_map f x
  rule #1: map f s::string = map f (chars s)
  rule #2: map f [] = []
  rule #3: map f xs@(_:_) = tick [] xs with tick zs (x:xs) = tack (f x:zs) (map f xs&) if thunkp xs; tick zs (x:xs) = tick (f x:zs) xs; tick zs [] = tack zs []; tick zs xs = tack zs (map f xs); tack (x:xs) ys = tack xs (x:ys); tack [] ys = ys end
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: reverse x::matrix = rowrev (colrev x)
  rule #1: reverse s::string = strcat (reverse (chars s))
  rule #2: reverse () = ()
  rule #3: reverse (x,xs) = accum x xs with accum ys (x,xs) = accum (x,ys) xs; accum ys x = x,ys end
  rule #4: reverse [] = []
  rule #5: reverse (x:xs) = accum [x] xs with accum ys (x:xs) = accum (x:ys) xs; accum ys [] = ys; accum ys xs = throw (bad_list_value xs) end
  state 0: #0 #1 #2 #3 #4 #5
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
	[] state 11
	() state 12
  state 1: #1
  state 2: #0
  state 3: #3 #5
	<app> state 4
  state 4: #3 #5
	: state 5
	, state 8
  state 5: #5
	<var> state 6
  state 6: #5
	<var> state 7
  state 7: #5
  state 8: #3
	<var> state 9
  state 9: #3
	<var> state 10
  state 10: #3
  state 11: #4
  state 12: #2
}
{
  rule #0: uncurry f (x,y) = f x y
  state 0: #0
	<var> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
}
{
  rule #0: uncurry3 f (x,y,z) = f x y z
  state 0: #0
	<var> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	<app> state 7
  state 7: #0
	, state 8
  state 8: #0
	<var> state 9
  state 9: #0
	<var> state 10
  state 10: #0
}
{
  rule #0: subseq x::matrix a::int b::int = __C::matrix_slice (rowvector x) 0 a 0 b
  rule #1: subseq s::string a::int b::int = substr s a (b-a+1)
  rule #2: subseq [] a::int b::int = []
  rule #3: subseq xs@(_:_) a::int b::int = take (b-a+1) (drop a xs) with take n::int [] = []; take n::int xs@(_:_) = tick n [] xs; tick n::int zs xs = tack zs [] if n<=0; tick n::int zs xs = case xs of [] = tack zs []; x:xs = tick (n-1) (x:zs) xs; _ = tack zs (take n xs) end; tack (x:xs) ys = tack xs (x:ys); tack [] ys = ys end
  rule #4: subseq x a b = slice x (a..b)
  state 0: #0 #1 #2 #3 #4
	<var> state 1
	<var>::string state 4
	<var>::matrix state 10
	<app> state 16
	[] state 35
  state 1: #4
	<var> state 2
  state 2: #4
	<var> state 3
  state 3: #4
  state 4: #1 #4
	<var> state 5
	<var>::int state 7
  state 5: #4
	<var> state 6
  state 6: #4
  state 7: #1 #4
	<var> state 8
	<var>::int state 9
  state 8: #4
  state 9: #1 #4
  state 10: #0 #4
	<var> state 11
	<var>::int state 13
  state 11: #4
	<var> state 12
  state 12: #4
  state 13: #0 #4
	<var> state 14
	<var>::int state 15
  state 14: #4
  state 15: #0 #4
  state 16: #3 #4
	<var> state 17
	<app> state 21
  state 17: #4
	<var> state 18
  state 18: #4
	<var> state 19
  state 19: #4
	<var> state 20
  state 20: #4
  state 21: #3 #4
	<var> state 22
	: state 27
  state 22: #4
	<var> state 23
  state 23: #4
	<var> state 24
  state 24: #4
	<var> state 25
  state 25: #4
	<var> state 26
  state 26: #4
  state 27: #3 #4
	<var> state 28
  state 28: #3 #4
	<var> state 29
  state 29: #3 #4
	<var> state 30
	<var>::int state 32
  state 30: #4
	<var> state 31
  state 31: #4
  state 32: #3 #4
	<var> state 33
	<var>::int state 34
  state 33: #4
  state 34: #3 #4
  state 35: #2 #4
	<var> state 36
	<var>::int state 38
  state 36: #4
	<var> state 37
  state 37: #4
  state 38: #2 #4
	<var> state 39
	<var>::int state 40
  state 39: #4
  state 40: #2 #4
}
{
  rule #0: cycle x::matrix = cycle (list x)
  rule #1: cycle s::string = cycle (chars s)
  rule #2: cycle ys@(x:xs) = x:(xs+cycle ys)&
  state 0: #0 #1 #2
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
  state 1: #1
  state 2: #0
  state 3: #2
	<app> state 4
  state 4: #2
	: state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
}
{
  rule #0: cyclen n::int x::matrix = cyclen n (list x) if ~null x
  rule #1: cyclen n::int s::string = cyclen n (chars s) if ~null s
  rule #2: cyclen n::int (x:xs) = [] if n<=0
  rule #3: cyclen n::int (x:xs) = accum [] n with accum ys n::int = cat ys+take n xs if n<=m; accum ys n::int = accum (xs:ys) (n-m) end when xs = x:xs; m::int = #xs end if rlistp xs
  state 0: #0 #1 #2 #3
	<var>::int state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
  state 2: #1
  state 3: #0
  state 4: #2 #3
	<app> state 5
  state 5: #2 #3
	: state 6
  state 6: #2 #3
	<var> state 7
  state 7: #2 #3
	<var> state 8
  state 8: #2 #3
}
{
  rule #0: drop k::int x::matrix = x!!(k..#x-1)
  rule #1: drop n::int s::string = substr s n (#s-n)
  rule #2: drop n::int [] = []
  rule #3: drop n::int ys@(x:xs) = drop (n-1) xs if n>1
  rule #4: drop n::int ys@(x:xs) = xs if n==1
  rule #5: drop n::int ys@(x:xs) = ys
  state 0: #0 #1 #2 #3 #4 #5
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4 #5
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3 #4 #5
	<app> state 5
  state 5: #3 #4 #5
	: state 6
  state 6: #3 #4 #5
	<var> state 7
  state 7: #3 #4 #5
	<var> state 8
  state 8: #3 #4 #5
  state 9: #2
}
{
  rule #0: dropwhile p x::matrix = __C::matrix_dropwhile p x
  rule #1: dropwhile p s::string = strcat (dropwhile p (chars s))
  rule #2: dropwhile p [] = []
  rule #3: dropwhile p ys@(x:xs) = dropwhile p xs if p x
  rule #4: dropwhile p ys@(x:xs) = ys
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3 #4
	<app> state 5
  state 5: #3 #4
	: state 6
  state 6: #3 #4
	<var> state 7
  state 7: #3 #4
	<var> state 8
  state 8: #3 #4
  state 9: #2
}
{
  rule #0: filter p x::matrix = __C::matrix_filter p x
  rule #1: filter p s::string = strcat (filter p (chars s))
  rule #2: filter p [] = []
  rule #3: filter p xs@(_:_) = tick [] xs with tick zs (x:xs) = tack (add p x zs) (filter p xs&) if thunkp xs; tick zs (x:xs) = tick (add p x zs) xs; tick zs [] = tack zs []; tick _ xs = throw (bad_list_value xs); tack (x:xs) ys = tack xs (x:ys); tack [] ys = ys; add p x xs = if p x then x:xs else xs end
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: foldl f a x::matrix = __C::matrix_foldl f a x
  rule #1: foldl f a s::string = foldl f a (chars s)
  rule #2: foldl f a [] = a
  rule #3: foldl f a (x:xs) = foldl f (f a x) xs
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
  state 2: #0 #1 #2 #3
	<var>::string state 3
	<var>::matrix state 4
	<app> state 5
	[] state 10
  state 3: #1
  state 4: #0
  state 5: #3
	<app> state 6
  state 6: #3
	: state 7
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #2
}
{
  rule #0: foldl1 f x::matrix = __C::matrix_foldl1 f x if ~null x
  rule #1: foldl1 f s::string = foldl1 f (chars s)
  rule #2: foldl1 f (x:xs) = foldl f x xs
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
  state 2: #1
  state 3: #0
  state 4: #2
	<app> state 5
  state 5: #2
	: state 6
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
}
{
  rule #0: foldr f a x::matrix = __C::matrix_foldr f a x
  rule #1: foldr f a s::string = foldr f a (chars s)
  rule #2: foldr f a [] = a
  rule #3: foldr f a xs@(_:_) = tick [] xs with tick zs (x:xs) = tack (x:zs) (foldr f a xs&) if thunkp xs; tick zs (x:xs) = tick (x:zs) xs; tick zs [] = tack zs a; tick zs xs = tack zs (foldr f a xs); tack (x:xs) y = tack xs (f x y); tack [] y = y end
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
  state 2: #0 #1 #2 #3
	<var>::string state 3
	<var>::matrix state 4
	<app> state 5
	[] state 10
  state 3: #1
  state 4: #0
  state 5: #3
	<app> state 6
  state 6: #3
	: state 7
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #2
}
{
  rule #0: foldr1 f x::matrix = __C::matrix_foldr1 f x if ~null x
  rule #1: foldr1 f s::string = foldr1 f (chars s)
  rule #2: foldr1 f [x] = x
  rule #3: foldr1 f xs@(_:_) = tick [] xs with tick zs ys@(_:xs) = tack zs (foldr1 f ys&) if thunkp xs; tick zs xs = case xs of [x] = tack zs x; x:xs = tick (x:zs) xs; _ = tack zs (foldr1 f xs) end; tack (x:xs) y = tack xs (f x y); tack [] y = y end
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
  state 2: #1
  state 3: #0
  state 4: #2 #3
	<app> state 5
  state 5: #2 #3
	: state 6
  state 6: #2 #3
	<var> state 7
  state 7: #2 #3
	<var> state 8
	[] state 9
  state 8: #3
  state 9: #2 #3
}
{
  rule #0: head x::matrix = x!0 if ~null x
  rule #1: head s::string = s!0 if ~null s
  rule #2: head (x:xs) = x
  state 0: #0 #1 #2
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
  state 1: #1
  state 2: #0
  state 3: #2
	<app> state 4
  state 4: #2
	: state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
}
{
  rule #0: init x::matrix = x!!(0..#x-2) if ~null x
  rule #1: init s::string = substr s 0 (#s-1) if ~null s
  rule #2: init [x] = []
  rule #3: init xs@(_:_) = tick [] xs with tick zs ys@(_:xs) = tack zs (init ys&) if thunkp xs; tick zs xs = case xs of [x] = tack zs []; x:xs = tick (x:zs) xs; _ = tack zs (init xs) end; tack (x:xs) ys = tack xs (x:ys); tack [] ys = ys end
  state 0: #0 #1 #2 #3
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
  state 1: #1
  state 2: #0
  state 3: #2 #3
	<app> state 4
  state 4: #2 #3
	: state 5
  state 5: #2 #3
	<var> state 6
  state 6: #2 #3
	<var> state 7
	[] state 8
  state 7: #3
  state 8: #2 #3
}
{
  rule #0: last x::matrix = x!(#x-1) if ~null x
  rule #1: last s::string = s!(#s-1) if ~null s
  rule #2: last [x] = x
  rule #3: last (x:xs) = last xs
  state 0: #0 #1 #2 #3
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
  state 1: #1
  state 2: #0
  state 3: #2 #3
	<app> state 4
  state 4: #2 #3
	: state 5
  state 5: #2 #3
	<var> state 6
  state 6: #2 #3
	<var> state 7
	[] state 8
  state 7: #3
  state 8: #2 #3
}
{
  rule #0: scanl f a x::matrix = __C::matrix_scanl f a x
  rule #1: scanl f a s::string = scanl f a (chars s)
  rule #2: scanl f a [] = [a]
  rule #3: scanl f a xs@(_:_) = tick a [] xs with tick a zs (x:xs) = tack (a:zs) (scanl f (f a x) xs&) if thunkp xs; tick a zs (x:xs) = tick (f a x) (a:zs) xs; tick a zs [] = tack zs [a]; tick a zs xs = tack zs (scanl f a xs); tack (x:xs) ys = tack xs (x:ys); tack [] ys = ys end
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
  state 2: #0 #1 #2 #3
	<var>::string state 3
	<var>::matrix state 4
	<app> state 5
	[] state 10
  state 3: #1
  state 4: #0
  state 5: #3
	<app> state 6
  state 6: #3
	: state 7
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #2
}
{
  rule #0: scanl1 f x::matrix = __C::matrix_scanl1 f x
  rule #1: scanl1 f s::string = scanl1 f (chars s)
  rule #2: scanl1 f [] = []
  rule #3: scanl1 f (x:xs) = scanl f x xs
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: scanr f a x::matrix = __C::matrix_scanr f a x
  rule #1: scanr f a s::string = scanr f a (chars s)
  rule #2: scanr f a [] = [a]
  rule #3: scanr f a xs@(_:_) = tick [] xs with tick zs (x:xs) = tack zs us when ys = scanr f a xs&; y = (case ys of y:_ = y; scanr _ _ ys = throw (bad_list_value ys); _ = throw (bad_list_value ys) end)&; us = f x y:ys end if thunkp xs; tick zs (x:xs) = tack zs (f x (y when y:_ = ys end)&:ys when ys = scanr f a xs& end) if thunkp xs; tick zs (x:xs) = tick (x:zs) xs; tick zs [] = tack zs [a]; tick zs xs = throw (bad_list_value xs); tack (x:xs) ys = tack xs (f x y:ys) when y:_ = ys end; tack [] ys = ys end
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
  state 2: #0 #1 #2 #3
	<var>::string state 3
	<var>::matrix state 4
	<app> state 5
	[] state 10
  state 3: #1
  state 4: #0
  state 5: #3
	<app> state 6
  state 6: #3
	: state 7
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #2
}
{
  rule #0: scanr1 f x::matrix = __C::matrix_scanr1 f x
  rule #1: scanr1 f s::string = scanr1 f (chars s)
  rule #2: scanr1 f [] = []
  rule #3: scanr1 f [x] = [x]
  rule #4: scanr1 f xs@(_:_) = tick [] xs with tick zs (x:xs) = tack zs us when ys = scanr1 f xs&; y = (case ys of y:_ = y; scanr1 _ ys = throw (bad_list_value ys); _ = throw (bad_list_value ys) end)&; us = f x y:ys end if thunkp xs; tick zs xs = case xs of [x] = tack zs [x]; x:xs = tick (x:zs) xs; _ = throw (bad_list_value xs) end; tack (x:xs) ys = tack xs (f x y:ys) when y:_ = ys end; tack [] ys = ys end
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 10
  state 2: #1
  state 3: #0
  state 4: #3 #4
	<app> state 5
  state 5: #3 #4
	: state 6
  state 6: #3 #4
	<var> state 7
  state 7: #3 #4
	<var> state 8
	[] state 9
  state 8: #4
  state 9: #3 #4
  state 10: #2
}
{
  rule #0: take k::int x::matrix = x!!(0..k-1)
  rule #1: take n::int s::string = substr s 0 n
  rule #2: take n::int [] = []
  rule #3: take n::int xs@(_:_) = tick n [] xs with tick n::int zs xs = tack zs [] if n<=0; tick n::int zs xs = tack zs (take n xs&) if thunkp xs; tick n::int zs xs = case xs of [] = tack zs []; x:xs = tick (n-1) (x:zs) xs; _ = tack zs (take n xs) end; tack (x:xs) ys = tack xs (x:ys); tack [] ys = ys end
  state 0: #0 #1 #2 #3
	<var>::int state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: takewhile p x::matrix = __C::matrix_takewhile p x
  rule #1: takewhile p s::string = strcat (takewhile p (chars s))
  rule #2: takewhile p [] = []
  rule #3: takewhile p xs@(_:_) = tick [] xs with tick zs xs = tack zs (takewhile p xs&) if thunkp xs; tick zs xs = case xs of [] = tack zs []; x:xs = tick (x:zs) xs if p x; x:xs = tack zs []; _ = tack zs (takewhile p xs) end; tack (x:xs) ys = tack xs (x:ys); tack [] ys = ys end
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: tail x::matrix = x!!(1..#x-1) if ~null x
  rule #1: tail s::string = substr s 1 (#s-1) if ~null s
  rule #2: tail (x:xs) = xs
  state 0: #0 #1 #2
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
  state 1: #1
  state 2: #0
  state 3: #2
	<app> state 4
  state 4: #2
	: state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
}
{
  rule #0: zipwith f x::matrix y::matrix = __C::matrix_zipwith f x y
  rule #1: zipwith f s::string t::string = zipwith f (chars s) (chars t)
  rule #2: zipwith f [] _ = []
  rule #3: zipwith f _ [] = []
  rule #4: zipwith f xs@(_:_) ys@(_:_) = tick [] xs ys with tick us (x:xs) (y:ys) = tack (f x y:us) (zipwith f xs ys&) if thunkp xs||thunkp ys; tick us (x:xs) (y:ys) = tick (f x y:us) xs ys; tick us [] _ = tack us []; tick us _ [] = tack us []; tick us xs ys = tack us (zipwith f xs ys); tack (u:us) vs = tack us (u:vs); tack [] vs = vs end
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<var>::string state 4
	<var>::matrix state 7
	<app> state 10
	[] state 28
  state 2: #3
	[] state 3
  state 3: #3
  state 4: #1 #3
	<var>::string state 5
	[] state 6
  state 5: #1
  state 6: #3
  state 7: #0 #3
	<var>::matrix state 8
	[] state 9
  state 8: #0
  state 9: #3
  state 10: #3 #4
	<var> state 11
	<app> state 14
  state 11: #3
	<var> state 12
  state 12: #3
	[] state 13
  state 13: #3
  state 14: #3 #4
	<var> state 15
	: state 19
  state 15: #3
	<var> state 16
  state 16: #3
	<var> state 17
  state 17: #3
	[] state 18
  state 18: #3
  state 19: #3 #4
	<var> state 20
  state 20: #3 #4
	<var> state 21
  state 21: #3 #4
	<app> state 22
	[] state 27
  state 22: #4
	<app> state 23
  state 23: #4
	: state 24
  state 24: #4
	<var> state 25
  state 25: #4
	<var> state 26
  state 26: #4
  state 27: #3
  state 28: #2 #3
	<var> state 29
	[] state 30
  state 29: #2
  state 30: #2 #3
}
{
  rule #0: zipwith3 f x::matrix y::matrix z::matrix = __C::matrix_zipwith3 f x y z
  rule #1: zipwith3 f s::string t::string u::string = zipwith3 f (chars s) (chars t) (chars u)
  rule #2: zipwith3 f [] _ _ = []
  rule #3: zipwith3 f _ [] _ = []
  rule #4: zipwith3 f _ _ [] = []
  rule #5: zipwith3 f xs@(_:_) ys@(_:_) zs@(_:_) = tick [] xs ys zs with tick us (x:xs) (y:ys) (z:zs) = tack (f x y z:us) (zipwith3 f xs ys zs&) if thunkp xs||thunkp ys||thunkp zs; tick us (x:xs) (y:ys) (z:zs) = tick (f x y z:us) xs ys zs; tick us [] _ _ = tack us []; tick us _ [] _ = tack us []; tick us _ _ [] = tack us []; tick us xs ys zs = tack us (zipwith3 f xs ys zs); tack (u:us) vs = tack us (u:vs); tack [] vs = vs end
  state 0: #0 #1 #2 #3 #4 #5
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5
	<var> state 2
	<var>::string state 8
	<var>::matrix state 17
	<app> state 26
	[] state 69
  state 2: #3 #4
	<var> state 3
	[] state 5
  state 3: #4
	[] state 4
  state 4: #4
  state 5: #3 #4
	<var> state 6
	[] state 7
  state 6: #3
  state 7: #3 #4
  state 8: #1 #3 #4
	<var> state 9
	<var>::string state 11
	[] state 14
  state 9: #4
	[] state 10
  state 10: #4
  state 11: #1 #4
	<var>::string state 12
	[] state 13
  state 12: #1
  state 13: #4
  state 14: #3 #4
	<var> state 15
	[] state 16
  state 15: #3
  state 16: #3 #4
  state 17: #0 #3 #4
	<var> state 18
	<var>::matrix state 20
	[] state 23
  state 18: #4
	[] state 19
  state 19: #4
  state 20: #0 #4
	<var>::matrix state 21
	[] state 22
  state 21: #0
  state 22: #4
  state 23: #3 #4
	<var> state 24
	[] state 25
  state 24: #3
  state 25: #3 #4
  state 26: #3 #4 #5
	<var> state 27
	<app> state 34
  state 27: #3 #4
	<var> state 28
  state 28: #3 #4
	<var> state 29
	[] state 31
  state 29: #4
	[] state 30
  state 30: #4
  state 31: #3 #4
	<var> state 32
	[] state 33
  state 32: #3
  state 33: #3 #4
  state 34: #3 #4 #5
	<var> state 35
	: state 43
  state 35: #3 #4
	<var> state 36
  state 36: #3 #4
	<var> state 37
  state 37: #3 #4
	<var> state 38
	[] state 40
  state 38: #4
	[] state 39
  state 39: #4
  state 40: #3 #4
	<var> state 41
	[] state 42
  state 41: #3
  state 42: #3 #4
  state 43: #3 #4 #5
	<var> state 44
  state 44: #3 #4 #5
	<var> state 45
  state 45: #3 #4 #5
	<var> state 46
	<app> state 48
	[] state 66
  state 46: #4
	[] state 47
  state 47: #4
  state 48: #4 #5
	<var> state 49
	<app> state 52
  state 49: #4
	<var> state 50
  state 50: #4
	[] state 51
  state 51: #4
  state 52: #4 #5
	<var> state 53
	: state 57
  state 53: #4
	<var> state 54
  state 54: #4
	<var> state 55
  state 55: #4
	[] state 56
  state 56: #4
  state 57: #4 #5
	<var> state 58
  state 58: #4 #5
	<var> state 59
  state 59: #4 #5
	<app> state 60
	[] state 65
  state 60: #5
	<app> state 61
  state 61: #5
	: state 62
  state 62: #5
	<var> state 63
  state 63: #5
	<var> state 64
  state 64: #5
  state 65: #4
  state 66: #3 #4
	<var> state 67
	[] state 68
  state 67: #3
  state 68: #3 #4
  state 69: #2 #3 #4
	<var> state 70
	[] state 73
  state 70: #2 #4
	<var> state 71
	[] state 72
  state 71: #2
  state 72: #2 #4
  state 73: #2 #3 #4
	<var> state 74
	[] state 75
  state 74: #2 #3
  state 75: #2 #3 #4
}
{
  rule #0: zip x::matrix y::matrix = zipwith (,) x y
  rule #1: zip s::string t::string = zip (chars s) (chars t)
  rule #2: zip [] _ = []
  rule #3: zip _ [] = []
  rule #4: zip xs@(_:_) ys@(_:_) = tick [] xs ys with tick us (x:xs) (y:ys) = tack ((x,y):us) (zip xs ys&) if thunkp xs||thunkp ys; tick us (x:xs) (y:ys) = tick ((x,y):us) xs ys; tick us [] _ = tack us []; tick us _ [] = tack us []; tick us xs ys = tack us (zip xs ys); tack (u:us) vs = tack us (u:vs); tack [] vs = vs end
  state 0: #0 #1 #2 #3 #4
	<var> state 1
	<var>::string state 3
	<var>::matrix state 6
	<app> state 9
	[] state 27
  state 1: #3
	[] state 2
  state 2: #3
  state 3: #1 #3
	<var>::string state 4
	[] state 5
  state 4: #1
  state 5: #3
  state 6: #0 #3
	<var>::matrix state 7
	[] state 8
  state 7: #0
  state 8: #3
  state 9: #3 #4
	<var> state 10
	<app> state 13
  state 10: #3
	<var> state 11
  state 11: #3
	[] state 12
  state 12: #3
  state 13: #3 #4
	<var> state 14
	: state 18
  state 14: #3
	<var> state 15
  state 15: #3
	<var> state 16
  state 16: #3
	[] state 17
  state 17: #3
  state 18: #3 #4
	<var> state 19
  state 19: #3 #4
	<var> state 20
  state 20: #3 #4
	<app> state 21
	[] state 26
  state 21: #4
	<app> state 22
  state 22: #4
	: state 23
  state 23: #4
	<var> state 24
  state 24: #4
	<var> state 25
  state 25: #4
  state 26: #3
  state 27: #2 #3
	<var> state 28
	[] state 29
  state 28: #2
  state 29: #2 #3
}
{
  rule #0: zip3 x::matrix y::matrix z::matrix = zipwith3 (\x y z -> x,y,z) x y z
  rule #1: zip3 s::string t::string u::string = zip3 (chars s) (chars t) (chars u)
  rule #2: zip3 [] _ _ = []
  rule #3: zip3 _ [] _ = []
  rule #4: zip3 _ _ [] = []
  rule #5: zip3 xs@(_:_) ys@(_:_) zs@(_:_) = tick [] xs ys zs with tick us (x:xs) (y:ys) (z:zs) = tack ((x,y,z):us) (zip3 xs ys zs&) if thunkp xs||thunkp ys||thunkp zs; tick us (x:xs) (y:ys) (z:zs) = tick ((x,y,z):us) xs ys zs; tick us [] _ _ = tack us []; tick us _ [] _ = tack us []; tick us _ _ [] = tack us []; tick us xs ys zs = tack us (zip3 xs ys zs); tack (u:us) vs = tack us (u:vs); tack [] vs = vs end
  state 0: #0 #1 #2 #3 #4 #5
	<var> state 1
	<var>::string state 7
	<var>::matrix state 16
	<app> state 25
	[] state 68
  state 1: #3 #4
	<var> state 2
	[] state 4
  state 2: #4
	[] state 3
  state 3: #4
  state 4: #3 #4
	<var> state 5
	[] state 6
  state 5: #3
  state 6: #3 #4
  state 7: #1 #3 #4
	<var> state 8
	<var>::string state 10
	[] state 13
  state 8: #4
	[] state 9
  state 9: #4
  state 10: #1 #4
	<var>::string state 11
	[] state 12
  state 11: #1
  state 12: #4
  state 13: #3 #4
	<var> state 14
	[] state 15
  state 14: #3
  state 15: #3 #4
  state 16: #0 #3 #4
	<var> state 17
	<var>::matrix state 19
	[] state 22
  state 17: #4
	[] state 18
  state 18: #4
  state 19: #0 #4
	<var>::matrix state 20
	[] state 21
  state 20: #0
  state 21: #4
  state 22: #3 #4
	<var> state 23
	[] state 24
  state 23: #3
  state 24: #3 #4
  state 25: #3 #4 #5
	<var> state 26
	<app> state 33
  state 26: #3 #4
	<var> state 27
  state 27: #3 #4
	<var> state 28
	[] state 30
  state 28: #4
	[] state 29
  state 29: #4
  state 30: #3 #4
	<var> state 31
	[] state 32
  state 31: #3
  state 32: #3 #4
  state 33: #3 #4 #5
	<var> state 34
	: state 42
  state 34: #3 #4
	<var> state 35
  state 35: #3 #4
	<var> state 36
  state 36: #3 #4
	<var> state 37
	[] state 39
  state 37: #4
	[] state 38
  state 38: #4
  state 39: #3 #4
	<var> state 40
	[] state 41
  state 40: #3
  state 41: #3 #4
  state 42: #3 #4 #5
	<var> state 43
  state 43: #3 #4 #5
	<var> state 44
  state 44: #3 #4 #5
	<var> state 45
	<app> state 47
	[] state 65
  state 45: #4
	[] state 46
  state 46: #4
  state 47: #4 #5
	<var> state 48
	<app> state 51
  state 48: #4
	<var> state 49
  state 49: #4
	[] state 50
  state 50: #4
  state 51: #4 #5
	<var> state 52
	: state 56
  state 52: #4
	<var> state 53
  state 53: #4
	<var> state 54
  state 54: #4
	[] state 55
  state 55: #4
  state 56: #4 #5
	<var> state 57
  state 57: #4 #5
	<var> state 58
  state 58: #4 #5
	<app> state 59
	[] state 64
  state 59: #5
	<app> state 60
  state 60: #5
	: state 61
  state 61: #5
	<var> state 62
  state 62: #5
	<var> state 63
  state 63: #5
  state 64: #4
  state 65: #3 #4
	<var> state 66
	[] state 67
  state 66: #3
  state 67: #3 #4
  state 68: #2 #3 #4
	<var> state 69
	[] state 72
  state 69: #2 #4
	<var> state 70
	[] state 71
  state 70: #2
  state 71: #2 #4
  state 72: #2 #3 #4
	<var> state 73
	[] state 74
  state 73: #2 #3
  state 74: #2 #3 #4
}
{
  rule #0: dowith f x::matrix y::matrix = do (uncurry f) (zip x y)
  rule #1: dowith f s::string t::string = dowith f (chars s) (chars t)
  rule #2: dowith f (x:xs) (y:ys) = f x y$$dowith f xs ys
  rule #3: dowith f _ _ = ()
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<var>::string state 4
	<var>::matrix state 7
	<app> state 10
  state 2: #3
	<var> state 3
  state 3: #3
  state 4: #1 #3
	<var> state 5
	<var>::string state 6
  state 5: #3
  state 6: #1 #3
  state 7: #0 #3
	<var> state 8
	<var>::matrix state 9
  state 8: #3
  state 9: #0 #3
  state 10: #2 #3
	<var> state 11
	<app> state 14
  state 11: #3
	<var> state 12
  state 12: #3
	<var> state 13
  state 13: #3
  state 14: #2 #3
	<var> state 15
	: state 19
  state 15: #3
	<var> state 16
  state 16: #3
	<var> state 17
  state 17: #3
	<var> state 18
  state 18: #3
  state 19: #2 #3
	<var> state 20
  state 20: #2 #3
	<var> state 21
  state 21: #2 #3
	<var> state 22
	<app> state 23
  state 22: #3
  state 23: #2 #3
	<var> state 24
	<app> state 26
  state 24: #3
	<var> state 25
  state 25: #3
  state 26: #2 #3
	<var> state 27
	: state 30
  state 27: #3
	<var> state 28
  state 28: #3
	<var> state 29
  state 29: #3
  state 30: #2 #3
	<var> state 31
  state 31: #2 #3
	<var> state 32
  state 32: #2 #3
}
{
  rule #0: dowith3 f x::matrix y::matrix z::matrix = do (uncurry3 f) (zip3 x y z)
  rule #1: dowith3 f s::string t::string u::string = dowith3 f (chars s) (chars t) (chars u)
  rule #2: dowith3 f (x:xs) (y:ys) (z:zs) = f x y z$$dowith3 f xs ys zs
  rule #3: dowith3 f _ _ _ = ()
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<var>::string state 5
	<var>::matrix state 11
	<app> state 17
  state 2: #3
	<var> state 3
  state 3: #3
	<var> state 4
  state 4: #3
  state 5: #1 #3
	<var> state 6
	<var>::string state 8
  state 6: #3
	<var> state 7
  state 7: #3
  state 8: #1 #3
	<var> state 9
	<var>::string state 10
  state 9: #3
  state 10: #1 #3
  state 11: #0 #3
	<var> state 12
	<var>::matrix state 14
  state 12: #3
	<var> state 13
  state 13: #3
  state 14: #0 #3
	<var> state 15
	<var>::matrix state 16
  state 15: #3
  state 16: #0 #3
  state 17: #2 #3
	<var> state 18
	<app> state 22
  state 18: #3
	<var> state 19
  state 19: #3
	<var> state 20
  state 20: #3
	<var> state 21
  state 21: #3
  state 22: #2 #3
	<var> state 23
	: state 28
  state 23: #3
	<var> state 24
  state 24: #3
	<var> state 25
  state 25: #3
	<var> state 26
  state 26: #3
	<var> state 27
  state 27: #3
  state 28: #2 #3
	<var> state 29
  state 29: #2 #3
	<var> state 30
  state 30: #2 #3
	<var> state 31
	<app> state 33
  state 31: #3
	<var> state 32
  state 32: #3
  state 33: #2 #3
	<var> state 34
	<app> state 37
  state 34: #3
	<var> state 35
  state 35: #3
	<var> state 36
  state 36: #3
  state 37: #2 #3
	<var> state 38
	: state 42
  state 38: #3
	<var> state 39
  state 39: #3
	<var> state 40
  state 40: #3
	<var> state 41
  state 41: #3
  state 42: #2 #3
	<var> state 43
  state 43: #2 #3
	<var> state 44
  state 44: #2 #3
	<var> state 45
	<app> state 46
  state 45: #3
  state 46: #2 #3
	<var> state 47
	<app> state 49
  state 47: #3
	<var> state 48
  state 48: #3
  state 49: #2 #3
	<var> state 50
	: state 53
  state 50: #3
	<var> state 51
  state 51: #3
	<var> state 52
  state 52: #3
  state 53: #2 #3
	<var> state 54
  state 54: #2 #3
	<var> state 55
  state 55: #2 #3
}
{
  rule #0: unzip x::matrix = colmap (\(u,_) -> u) x,colmap (\(_,v) -> v) x if all check x with check (_,_) = 1; check x = throw (bad_tuple_value x) end
  rule #1: unzip [] = [],[]
  rule #2: unzip us@(_:_) = foldr accum ([],[]) us with check us@(_,_) = us; check (foldr _ _ us) = throw (bad_list_value us); check us = throw (bad_tuple_value us); accum u@(x,y) us = x:(xs when xs,_ = check us end)&,y:(ys when _,ys = check us end)& if thunkp us; accum u@(x,y) us = x:xs,y:ys when xs,ys = check us end; accum u _ = throw (bad_tuple_value u) end
  state 0: #0 #1 #2
	<var>::matrix state 1
	<app> state 2
	[] state 7
  state 1: #0
  state 2: #2
	<app> state 3
  state 3: #2
	: state 4
  state 4: #2
	<var> state 5
  state 5: #2
	<var> state 6
  state 6: #2
  state 7: #1
}
{
  rule #0: unzip3 x::matrix = colmap (\(u,_) -> u) x,colmap (\(_,v,_) -> v) x,colmap (\(_,_,w) -> w) x if all check x with check (_,_,_) = 1; check x = throw (bad_tuple_value x) end
  rule #1: unzip3 [] = [],[],[]
  rule #2: unzip3 us@(_:_) = foldr accum ([],[],[]) us with check us@(_,_,_) = us; check (foldr _ _ us) = throw (bad_list_value us); check us = throw (bad_tuple_value us); accum u@(x,y,z) us = x:(xs when xs,_,_ = check us end)&,y:(ys when _,ys,_ = check us end)&,z:(zs when _,_,zs = check us end)& if thunkp us; accum u@(x,y,z) us = x:xs,y:ys,z:zs when xs,ys,zs = check us end; accum u _ = throw (bad_tuple_value u) end
  state 0: #0 #1 #2
	<var>::matrix state 1
	<app> state 2
	[] state 7
  state 1: #0
  state 2: #2
	<app> state 3
  state 3: #2
	: state 4
  state 4: #2
	<var> state 5
  state 5: #2
	<var> state 6
  state 6: #2
  state 7: #1
}
{
  rule #0: index s::string u::string = __C::string_index s u
  rule #1: index [] _ = -1
  rule #2: index (x:xs) y = search 0 (x:xs) with search _ [] = -1; search n::int (x:xs) = n if x==y; search n::int (x:xs) = search (n+1) xs; search _ xs = index xs y end
  state 0: #0 #1 #2
	<var>::string state 1
	<app> state 3
	[] state 9
  state 1: #0
	<var>::string state 2
  state 2: #0
  state 3: #2
	<app> state 4
  state 4: #2
	: state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1
	<var> state 10
  state 10: #1
}
{
  rule #0: stream s::string = stream (chars s)
  rule #1: stream [] = []
  rule #2: stream (x:xs) = x:xs if thunkp xs
  rule #3: stream (x:xs) = x:stream xs&
  rule #4: stream () = []
  rule #5: stream xs@(_,_) = stream (list xs)
  state 0: #0 #1 #2 #3 #4 #5
	<var>::string state 1
	<app> state 2
	[] state 10
	() state 11
  state 1: #0
  state 2: #2 #3 #5
	<app> state 3
  state 3: #2 #3 #5
	: state 4
	, state 7
  state 4: #2 #3
	<var> state 5
  state 5: #2 #3
	<var> state 6
  state 6: #2 #3
  state 7: #5
	<var> state 8
  state 8: #5
	<var> state 9
  state 9: #5
  state 10: #1
  state 11: #4
}
{
  rule #0: void _ = ()
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: id x = x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: curry f x y = f (x,y)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}
{
  rule #0: curry3 f x y z = f (x,y,z)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
	<var> state 4
  state 4: #0
}
{
  rule #0: fix f = f (fix f&)
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: key (x=>v) = x
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	=> state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}
{
  rule #0: iterate f x = x:iterate f (f x)&
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: iterwhile p f x = accum [] p f x with accum xs p f x = accum (x:xs) p f (f x) if p x; accum xs p f x = reverse xs end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}
{
  rule #0: repeat x = x:repeat x&
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: iteraten n::int f x = [] if n<=0
  rule #1: iteraten n::int f x = accum [] n f x with accum xs n::int f x = reverse (x:xs) if n==1; accum xs n::int f x = accum (x:xs) (n-1) f (f x) end
  state 0: #0 #1
	<var>::int state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
	<var> state 3
  state 3: #0 #1
}
{
  rule #0: repeatn n::int x = accum [] n x with accum xs n::int x = xs if n<=0; accum xs n::int x = accum (x:xs) (n-1) x end
  state 0: #0
	<var>::int state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
const __std__::__voidfun__ = void;
def __std__::__voidchk__ x/*0:1*/ = __std__::__voidchk2__ x/*0:1*/;
def __std__::__voidchk2__ x/*0:01*/ y/*0:1*/ = __std__::__voidfun__ y/*0:1*/;
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(listmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(rowmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(colmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(catmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(rowcatmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(colcatmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ z/*0:1101*/ [])) = __std__::__do__$__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ (void z/*0:1101*/) ());
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ z/*0:1101*/ {})) = __std__::__do__$__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ (void z/*0:1101*/) ());
def __std__::__do__ (__lambda__ [x/*0:10101*/] (void y/*0:111*/)) = __std__::__do__ (__lambda__ [x/*0:10101*/] y/*0:111*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__std__::__voidfun__ y/*0:111*/)) = __std__::__do__ (__lambda__ [x/*0:10101*/] y/*0:111*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ (void z/*0:11011*/) ())) = __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ z/*0:11011*/ ()));
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ (__std__::__voidfun__ z/*0:11011*/) ())) = __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ z/*0:11011*/ ()));
def __std__::__do__ f/*0:1*/ = do f/*0:1*/;
__C::pure_quoted_symbol s/*0:1*/ :: string = __C::pure_quoted_symbol id/*0:*/ if id/*0:*/>0 when id/*0:*/ :: int = __C::pure_getsym s/*0:1*/ {
  rule #0: id::int = __C::pure_getsym s
  state 0: #0
	<var>::int state 1
  state 1: #0
} end;
globsym pat/*0:01*/ :: string level/*0:1*/ :: int = uniq/*2*/ (catmap descr/*2*/ info/*0:*/) when res/*0:*/ = evalcmd ("show -gst"+str level/*0:1*/+" "+pat/*0:01*/); stringp res/*0:*/||throw evalcmd; info/*0:*/ = init (init (split "\n" res/*0:*/)) {
  rule #0: info = init (init (split "\n" res))
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: _ = stringp res||throw evalcmd
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: res = evalcmd ("show -gst"+str level+" "+pat)
  state 0: #0
	<var> state 1
  state 1: #0
} end with uniq (x/*0:101*/:xs@(y/*0:1101*/:_/*0:111*/)) = if x/*0:101*/===y/*0:1101*/ then uniq/*1*/ xs/*0:11*/ else x/*0:101*/:uniq/*1*/ xs/*0:11*/; uniq xs/*0:1*/ = xs/*0:1*/ {
  rule #0: uniq (x:xs@(y:_)) = if x===y then uniq xs else x:uniq xs
  rule #1: uniq xs = xs
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	: state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
	<app> state 12
  state 11: #1
  state 12: #0 #1
	<var> state 13
	<app> state 15
  state 13: #1
	<var> state 14
  state 14: #1
  state 15: #0 #1
	<var> state 16
	: state 19
  state 16: #1
	<var> state 17
  state 17: #1
	<var> state 18
  state 18: #1
  state 19: #0 #1
	<var> state 20
  state 20: #0 #1
	<var> state 21
  state 21: #0 #1
}; descr s/*0:1*/ :: string = case filter (flip (~=) "") (split " " s/*0:1*/) of sym/*0:01*/:_/*0:1*/ = if any (flip (==) sym/*0:01*/) ["extern","private","infix","infixl","infixr","prefix","postfix","outfix","nonfix"] then [] else catmap (\x/*0:1*/ -> if symbolp x/*0:1*/ then [x/*0:1*/] else [] {
  rule #0: _ x = if symbolp x then [x] else []
  state 0: #0
	<var> state 1
  state 1: #0
}) [__C::pure_quoted_symbol sym/*0:01*/]; _/*0:*/ = [] {
  rule #0: sym:_ = if any (flip (==) sym) ["extern","private","infix","infixl","infixr","prefix","postfix","outfix","nonfix"] then [] else catmap (\x -> if symbolp x then [x] else []) [__C::pure_quoted_symbol sym]
  rule #1: _ = []
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	: state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
} end {
  rule #0: descr s::string = case filter (flip (~=) "") (split " " s) of sym:_ = if any (flip (==) sym) ["extern","private","infix","infixl","infixr","prefix","postfix","outfix","nonfix"] then [] else catmap (\x -> if symbolp x then [x] else []) [__C::pure_quoted_symbol sym]; _ = [] end
  state 0: #0
	<var>::string state 1
  state 1: #0
} end;
clearsym sym/*0:01*/ :: string level/*0:1*/ :: int = () when res/*0:*/ = evalcmd ("clear -t"+str level/*0:1*/+" "+sym/*0:01*/); stringp res/*0:*/||throw evalcmd {
  rule #0: _ = stringp res||throw evalcmd
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: res = evalcmd ("clear -t"+str level+" "+sym)
  state 0: #0
	<var> state 1
  state 1: #0
} end;
clearsym sym/*0:01*/ :: symbol level/*0:1*/ :: int = clearsym sym/*0:*/ level/*2:1*/ when sym/*0:*/ = str sym/*0:01*/; sym/*0:*/ = if sym/*0:*/!0=="(" then substr sym/*0:*/ 2 (#sym/*0:*/-2) else sym/*0:*/ {
  rule #0: sym = if sym!0=="(" then substr sym 2 (#sym-2) else sym
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: sym = str sym
  state 0: #0
	<var> state 1
  state 1: #0
} end;
