const false,true = 0,1;
slice x/*0:01*/ y/*0:1*/ = x/*0:01*/!!y/*0:1*/;
{
  rule #0: slice x y = x!!y
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
f/*0:01*/$x/*0:1*/ = f/*0:01*/ x/*0:1*/;
(f/*0:001*/.g/*0:01*/) x/*0:1*/ = f/*0:001*/ (g/*0:01*/ x/*0:1*/);
void _/*0:1*/ = ();
id x/*0:1*/ = x/*0:1*/;
cst x/*0:01*/ y/*0:1*/ = x/*0:01*/;
flip f/*0:001*/ x/*0:01*/ y/*0:1*/ = f/*0:001*/ y/*0:1*/ x/*0:01*/;
curry f/*0:001*/ x/*0:01*/ y/*0:1*/ = f/*0:001*/ (x/*0:01*/,y/*0:1*/);
curry3 f/*0:0001*/ x/*0:001*/ y/*0:01*/ z/*0:1*/ = f/*0:0001*/ (x/*0:001*/,y/*0:01*/,z/*0:1*/);
uncurry f/*0:01*/ (x/*0:101*/,y/*0:11*/) = f/*0:01*/ x/*0:101*/ y/*0:11*/;
uncurry3 f/*0:01*/ (x/*0:101*/,y/*0:1101*/,z/*0:111*/) = f/*0:01*/ x/*0:101*/ y/*0:1101*/ z/*0:111*/;
fix f/*0:1*/ = f/*0:1*/ (fix f/*1:1*/&);
def f/*0:01*/$x/*0:1*/ = f/*0:01*/ x/*0:1*/;
def (f/*0:001*/.g/*0:01*/) x/*0:1*/ = f/*0:001*/ (g/*0:01*/ x/*0:1*/);
def void () = ();
def void [] = ();
def void {} = ();
def void [x/*0:101*/] = void x/*0:101*/;
def void {x/*0:100*/} = void x/*0:100*/;
(x/*0:0101*/=>v/*0:011*/)==(y/*0:101*/=>w/*0:11*/) = x/*0:0101*/==y/*0:101*/&&v/*0:011*/==w/*0:11*/;
(x/*0:0101*/=>v/*0:011*/)~=(y/*0:101*/=>w/*0:11*/) = x/*0:0101*/~=y/*0:101*/||v/*0:011*/~=w/*0:11*/;
key (x/*0:101*/=>v/*0:11*/) = x/*0:101*/;
val (x/*0:101*/=>v/*0:11*/) = v/*0:11*/;
tuple2 x/*0:01*/ y/*0:1*/ = 'comma/*0:*/ x/*1:01*/ y/*1:1*/ when comma/*0:*/ = (,) {
  rule #0: comma = (,)
  state 0: #0
	<var> state 1
  state 1: #0
} end;
tuple3 x/*0:001*/ y/*0:01*/ z/*0:1*/ = 'comma/*0:*/ x/*1:001*/ (comma/*0:*/ y/*1:01*/ z/*1:1*/) when comma/*0:*/ = (,) {
  rule #0: comma = (,)
  state 0: #0
	<var> state 1
  state 1: #0
} end;
x/*0:01*/,y/*0:1*/ = flatten/*0*/ x/*0:01*/ y/*0:1*/ with flatten () (x/*0:101*/,y/*0:11*/) = flatten/*1*/ x/*0:101*/ y/*0:11*/; flatten (x/*0:0101*/,y/*0:011*/) () = flatten/*1*/ x/*0:0101*/ y/*0:011*/; flatten () x/*0:1*/ = x/*0:1*/; flatten x/*0:01*/ () = x/*0:01*/; flatten (x/*0:0101*/,y/*0:011*/) z/*0:1*/ = flatten/*1*/ x/*0:0101*/ (flatten/*1*/ y/*0:011*/ z/*0:1*/); flatten x/*0:01*/ (y/*0:101*/,z/*0:11*/) = tuple2 x/*0:01*/ (flatten/*1*/ y/*0:101*/ z/*0:11*/); flatten x/*0:01*/ z/*0:1*/ = tuple2 x/*0:01*/ z/*0:1*/ {
  rule #0: flatten () (x,y) = flatten x y
  rule #1: flatten (x,y) () = flatten x y
  rule #2: flatten () x = x
  rule #3: flatten x () = x
  rule #4: flatten (x,y) z = flatten x (flatten y z)
  rule #5: flatten x (y,z) = tuple2 x (flatten y z)
  rule #6: flatten x z = tuple2 x z
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var> state 1
	<app> state 14
	() state 60
  state 1: #3 #5 #6
	<var> state 2
	<app> state 3
	() state 13
  state 2: #6
  state 3: #5 #6
	<var> state 4
	<app> state 6
  state 4: #6
	<var> state 5
  state 5: #6
  state 6: #5 #6
	<var> state 7
	, state 10
  state 7: #6
	<var> state 8
  state 8: #6
	<var> state 9
  state 9: #6
  state 10: #5 #6
	<var> state 11
  state 11: #5 #6
	<var> state 12
  state 12: #5 #6
  state 13: #3 #6
  state 14: #1 #3 #4 #5 #6
	<var> state 15
	<app> state 29
  state 15: #3 #5 #6
	<var> state 16
  state 16: #3 #5 #6
	<var> state 17
	<app> state 18
	() state 28
  state 17: #6
  state 18: #5 #6
	<var> state 19
	<app> state 21
  state 19: #6
	<var> state 20
  state 20: #6
  state 21: #5 #6
	<var> state 22
	, state 25
  state 22: #6
	<var> state 23
  state 23: #6
	<var> state 24
  state 24: #6
  state 25: #5 #6
	<var> state 26
  state 26: #5 #6
	<var> state 27
  state 27: #5 #6
  state 28: #3 #6
  state 29: #1 #3 #4 #5 #6
	<var> state 30
	, state 45
  state 30: #3 #5 #6
	<var> state 31
  state 31: #3 #5 #6
	<var> state 32
  state 32: #3 #5 #6
	<var> state 33
	<app> state 34
	() state 44
  state 33: #6
  state 34: #5 #6
	<var> state 35
	<app> state 37
  state 35: #6
	<var> state 36
  state 36: #6
  state 37: #5 #6
	<var> state 38
	, state 41
  state 38: #6
	<var> state 39
  state 39: #6
	<var> state 40
  state 40: #6
  state 41: #5 #6
	<var> state 42
  state 42: #5 #6
	<var> state 43
  state 43: #5 #6
  state 44: #3 #6
  state 45: #1 #3 #4 #5 #6
	<var> state 46
  state 46: #1 #3 #4 #5 #6
	<var> state 47
  state 47: #1 #3 #4 #5 #6
	<var> state 48
	<app> state 49
	() state 59
  state 48: #4 #6
  state 49: #4 #5 #6
	<var> state 50
	<app> state 52
  state 50: #4 #6
	<var> state 51
  state 51: #4 #6
  state 52: #4 #5 #6
	<var> state 53
	, state 56
  state 53: #4 #6
	<var> state 54
  state 54: #4 #6
	<var> state 55
  state 55: #4 #6
  state 56: #4 #5 #6
	<var> state 57
  state 57: #4 #5 #6
	<var> state 58
  state 58: #4 #5 #6
  state 59: #1 #3 #4 #6
  state 60: #0 #2 #3 #5 #6
	<var> state 61
	<app> state 62
	() state 72
  state 61: #2 #6
  state 62: #0 #2 #5 #6
	<var> state 63
	<app> state 65
  state 63: #2 #6
	<var> state 64
  state 64: #2 #6
  state 65: #0 #2 #5 #6
	<var> state 66
	, state 69
  state 66: #2 #6
	<var> state 67
  state 67: #2 #6
	<var> state 68
  state 68: #2 #6
  state 69: #0 #2 #5 #6
	<var> state 70
  state 70: #0 #2 #5 #6
	<var> state 71
  state 71: #0 #2 #5 #6
  state 72: #2 #3 #6
} end;
mapfst f/*0:01*/ (a/*0:101*/,b/*0:11*/) = tuple2 (f/*0:01*/ a/*0:101*/) b/*0:11*/;
mapsnd f/*0:01*/ (a/*0:101*/,b/*0:11*/) = tuple2 a/*0:101*/ (f/*0:01*/ b/*0:11*/);
maptrd f/*0:01*/ (a/*0:101*/,b/*0:1101*/,c/*0:111*/) = tuple3 a/*0:101*/ b/*0:1101*/ (f/*0:01*/ c/*0:111*/);
fst _/*0:01*/ (a/*0:101*/,_/*0:11*/) = a/*0:101*/;
snd _/*0:01*/ (_/*0:101*/,a/*0:11*/) = a/*0:11*/;
trd _/*0:01*/ (_/*0:101*/,_/*0:1101*/,a/*0:111*/) = a/*0:111*/;
fst none/*0:01*/ () = none/*0:01*/;
snd none/*0:01*/ () = none/*0:01*/;
trd none/*0:01*/ () = none/*0:01*/;
()==() = 1;
(x/*0:0101*/,xs/*0:011*/)==(y/*0:101*/,ys/*0:11*/) = x/*0:0101*/==y/*0:101*/&&xs/*0:011*/==ys/*0:11*/;
(x/*0:0101*/,xs/*0:011*/)==_/*0:1*/ = 0;
()==_/*0:1*/ = 0;
_/*0:01*/==(x/*0:101*/,xs/*0:11*/) = 0;
_/*0:01*/==() = 0;
()~=() = 0;
(x/*0:0101*/,xs/*0:011*/)~=(y/*0:101*/,ys/*0:11*/) = x/*0:0101*/~=y/*0:101*/||xs/*0:011*/~=ys/*0:11*/;
(x/*0:0101*/,xs/*0:011*/)~=_/*0:1*/ = 1;
()~=_/*0:1*/ = 1;
_/*0:01*/~=(x/*0:101*/,xs/*0:11*/) = 1;
_/*0:01*/~=() = 1;
null () = 1;
null (x/*0:101*/,xs/*0:11*/) = 0;
#() = 0;
#(x/*0:101*/,xs/*0:11*/) = accum/*0*/ 1 xs/*0:11*/ with accum n/*0:01*/ :: int (x/*0:101*/,xs/*0:11*/) = accum/*1*/ (n/*0:01*/+1) xs/*0:11*/; accum n/*0:01*/ :: int x/*0:1*/ = n/*0:01*/+1 {
  rule #0: accum n::int (x,xs) = accum (n+1) xs
  rule #1: accum n::int x = n+1
  state 0: #0 #1
	<var>::int state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	, state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
} end;
(x/*0:0101*/,xs/*0:011*/)!n/*0:1*/ :: int = throw out_of_bounds if n/*0:1*/<0;
(x/*0:0101*/,xs/*0:011*/)!0 = x/*0:0101*/;
(x/*0:0101*/,y/*0:01101*/,xs/*0:0111*/)!n/*0:1*/ :: int = (y/*0:01101*/,xs/*0:0111*/)!(n/*0:1*/-1);
(x/*0:0101*/,y/*0:011*/)!1 = y/*0:011*/;
(x/*0:0101*/,y/*0:011*/)!n/*0:1*/ :: int = throw out_of_bounds;
()!n/*0:1*/ :: int = throw out_of_bounds;
xs@()!!ns/*0:1*/ = tuple (list xs/*0:01*/!!ns/*0:1*/);
xs@(_/*0:0101*/,_/*0:011*/)!!ns/*0:1*/ = tuple (list xs/*0:01*/!!ns/*0:1*/);
reverse () = ();
reverse (x/*0:101*/,xs/*0:11*/) = accum/*0*/ x/*0:101*/ xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/,xs/*0:11*/) = accum/*1*/ (x/*0:101*/,ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ x/*0:1*/ = x/*0:1*/,ys/*0:01*/ {
  rule #0: accum ys (x,xs) = accum (x,ys) xs
  rule #1: accum ys x = x,ys
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	, state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
} end;
[]==[] = 1;
x/*0:0101*/:xs/*0:011*/==[] = 0;
[]==x/*0:101*/:xs/*0:11*/ = 0;
x/*0:0101*/:xs/*0:011*/==y/*0:101*/:ys/*0:11*/ = x/*0:0101*/==y/*0:101*/&&xs/*0:011*/==ys/*0:11*/;
[]~=[] = 0;
x/*0:0101*/:xs/*0:011*/~=[] = 1;
[]~=x/*0:101*/:xs/*0:11*/ = 1;
x/*0:0101*/:xs/*0:011*/~=y/*0:101*/:ys/*0:11*/ = x/*0:0101*/~=y/*0:101*/||xs/*0:011*/~=ys/*0:11*/;
null [] = 1;
null (x/*0:101*/:xs/*0:11*/) = 0;
#[] = 0;
#(x/*0:101*/:xs/*0:11*/) = accum/*0*/ 1 xs/*0:11*/ with accum n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (n/*0:01*/+1) xs/*0:11*/; accum n/*0:01*/ :: int [] = n/*0:01*/; accum n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/+#xs/*0:1*/ {
  rule #0: accum n::int (x:xs) = accum (n+1) xs
  rule #1: accum n::int [] = n
  rule #2: accum n::int xs = n+#xs
  state 0: #0 #1 #2
	<var>::int state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
[]!n/*0:1*/ :: int = throw out_of_bounds;
(x/*0:0101*/:xs/*0:011*/)!0 = x/*0:0101*/;
(x/*0:0101*/:xs/*0:011*/)!n/*0:1*/ :: int = xs/*0:011*/!(n/*0:1*/-1) if n/*0:1*/>0;
(x/*0:0101*/:xs/*0:011*/)!n/*0:1*/ :: int = throw out_of_bounds;
list1 x/*0:1*/ = [x/*0:1*/];
{
  rule #0: x,y = flatten x y with flatten () (x,y) = flatten x y; flatten (x,y) () = flatten x y; flatten () x = x; flatten x () = x; flatten (x,y) z = flatten x (flatten y z); flatten x (y,z) = tuple2 x (flatten y z); flatten x z = tuple2 x z end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: flip f x y = f y x
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}
{
  rule #0: x::int==y::int = x==y
  rule #1: x::double==y::double = x==y
  rule #2: x::int==y::double = x==y
  rule #3: x::double==y::int = x==y
  rule #4: x::bigint==y::bigint = __C::bigint_cmp x y==0
  rule #5: x::int==y::bigint = bigint x==y
  rule #6: x::bigint==y::int = x==bigint y
  rule #7: x::bigint==y::double = double x==y
  rule #8: x::double==y::bigint = x==double y
  rule #9: x::matrix==y::matrix = x===y if nmatrixp x&&matrix_type x==matrix_type y
  rule #10: x::matrix==y::matrix = cmatrix x===y if nmatrixp x&&cmatrixp y
  rule #11: x::matrix==y::matrix = x===cmatrix y if cmatrixp x&&nmatrixp y
  rule #12: x::matrix==y::matrix = dmatrix x===y if imatrixp x&&dmatrixp y
  rule #13: x::matrix==y::matrix = x===dmatrix y if dmatrixp x&&imatrixp y
  rule #14: x::matrix==y::matrix = 0 if dim x~=dim y
  rule #15: x::matrix==y::matrix = compare 0 with compare i::int = 1 if i>=n; compare i::int = 0 if x!i~=y!i; compare i::int = compare (i+1) end when n::int = #x end
  rule #16: x::string==y::string = __C::strcmp x y==0
  rule #17: (x=>v)==(y=>w) = x==y&&v==w
  rule #18: ()==() = 1
  rule #19: (x,xs)==(y,ys) = x==y&&xs==ys
  rule #20: (x,xs)==_ = 0
  rule #21: ()==_ = 0
  rule #22: _==(x,xs) = 0
  rule #23: _==() = 0
  rule #24: []==[] = 1
  rule #25: x:xs==[] = 0
  rule #26: []==x:xs = 0
  rule #27: x:xs==y:ys = x==y&&xs==ys
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16 #17 #18 #19 #20 #21 #22 #23 #24 #25 #26 #27
	<var> state 1
	<var>::int state 8
	<var>::bigint state 18
	<var>::double state 28
	<var>::string state 38
	<var>::matrix state 46
	<app> state 54
	[] state 113
	() state 124
  state 1: #22 #23
	<app> state 2
	() state 7
  state 2: #22
	<app> state 3
  state 3: #22
	, state 4
  state 4: #22
	<var> state 5
  state 5: #22
	<var> state 6
  state 6: #22
  state 7: #23
  state 8: #0 #2 #5 #22 #23
	<var>::int state 9
	<var>::bigint state 10
	<var>::double state 11
	<app> state 12
	() state 17
  state 9: #0
  state 10: #5
  state 11: #2
  state 12: #22
	<app> state 13
  state 13: #22
	, state 14
  state 14: #22
	<var> state 15
  state 15: #22
	<var> state 16
  state 16: #22
  state 17: #23
  state 18: #4 #6 #7 #22 #23
	<var>::int state 19
	<var>::bigint state 20
	<var>::double state 21
	<app> state 22
	() state 27
  state 19: #6
  state 20: #4
  state 21: #7
  state 22: #22
	<app> state 23
  state 23: #22
	, state 24
  state 24: #22
	<var> state 25
  state 25: #22
	<var> state 26
  state 26: #22
  state 27: #23
  state 28: #1 #3 #8 #22 #23
	<var>::int state 29
	<var>::bigint state 30
	<var>::double state 31
	<app> state 32
	() state 37
  state 29: #3
  state 30: #8
  state 31: #1
  state 32: #22
	<app> state 33
  state 33: #22
	, state 34
  state 34: #22
	<var> state 35
  state 35: #22
	<var> state 36
  state 36: #22
  state 37: #23
  state 38: #16 #22 #23
	<var>::string state 39
	<app> state 40
	() state 45
  state 39: #16
  state 40: #22
	<app> state 41
  state 41: #22
	, state 42
  state 42: #22
	<var> state 43
  state 43: #22
	<var> state 44
  state 44: #22
  state 45: #23
  state 46: #9 #10 #11 #12 #13 #14 #15 #22 #23
	<var>::matrix state 47
	<app> state 48
	() state 53
  state 47: #9 #10 #11 #12 #13 #14 #15
  state 48: #22
	<app> state 49
  state 49: #22
	, state 50
  state 50: #22
	<var> state 51
  state 51: #22
	<var> state 52
  state 52: #22
  state 53: #23
  state 54: #17 #19 #20 #22 #23 #25 #27
	<var> state 55
	<app> state 63
  state 55: #22 #23
	<var> state 56
  state 56: #22 #23
	<app> state 57
	() state 62
  state 57: #22
	<app> state 58
  state 58: #22
	, state 59
  state 59: #22
	<var> state 60
  state 60: #22
	<var> state 61
  state 61: #22
  state 62: #23
  state 63: #17 #19 #20 #22 #23 #25 #27
	<var> state 64
	: state 73
	, state 86
	=> state 101
  state 64: #22 #23
	<var> state 65
  state 65: #22 #23
	<var> state 66
  state 66: #22 #23
	<app> state 67
	() state 72
  state 67: #22
	<app> state 68
  state 68: #22
	, state 69
  state 69: #22
	<var> state 70
  state 70: #22
	<var> state 71
  state 71: #22
  state 72: #23
  state 73: #22 #23 #25 #27
	<var> state 74
  state 74: #22 #23 #25 #27
	<var> state 75
  state 75: #22 #23 #25 #27
	<app> state 76
	[] state 84
	() state 85
  state 76: #22 #27
	<app> state 77
  state 77: #22 #27
	: state 78
	, state 81
  state 78: #27
	<var> state 79
  state 79: #27
	<var> state 80
  state 80: #27
  state 81: #22
	<var> state 82
  state 82: #22
	<var> state 83
  state 83: #22
  state 84: #25
  state 85: #23
  state 86: #19 #20 #22 #23
	<var> state 87
  state 87: #19 #20 #22 #23
	<var> state 88
  state 88: #19 #20 #22 #23
	<var> state 89
	<app> state 90
	() state 100
  state 89: #20
  state 90: #19 #20 #22
	<var> state 91
	<app> state 93
  state 91: #20
	<var> state 92
  state 92: #20
  state 93: #19 #20 #22
	<var> state 94
	, state 97
  state 94: #20
	<var> state 95
  state 95: #20
	<var> state 96
  state 96: #20
  state 97: #19 #20 #22
	<var> state 98
  state 98: #19 #20 #22
	<var> state 99
  state 99: #19 #20 #22
  state 100: #20 #23
  state 101: #17 #22 #23
	<var> state 102
  state 102: #17 #22 #23
	<var> state 103
  state 103: #17 #22 #23
	<app> state 104
	() state 112
  state 104: #17 #22
	<app> state 105
  state 105: #17 #22
	, state 106
	=> state 109
  state 106: #22
	<var> state 107
  state 107: #22
	<var> state 108
  state 108: #22
  state 109: #17
	<var> state 110
  state 110: #17
	<var> state 111
  state 111: #17
  state 112: #23
  state 113: #22 #23 #24 #26
	<app> state 114
	[] state 122
	() state 123
  state 114: #22 #26
	<app> state 115
  state 115: #22 #26
	: state 116
	, state 119
  state 116: #26
	<var> state 117
  state 117: #26
	<var> state 118
  state 118: #26
  state 119: #22
	<var> state 120
  state 120: #22
	<var> state 121
  state 121: #22
  state 122: #24
  state 123: #23
  state 124: #18 #21 #22 #23
	<var> state 125
	<app> state 126
	() state 136
  state 125: #21
  state 126: #21 #22
	<var> state 127
	<app> state 129
  state 127: #21
	<var> state 128
  state 128: #21
  state 129: #21 #22
	<var> state 130
	, state 133
  state 130: #21
	<var> state 131
  state 131: #21
	<var> state 132
  state 132: #21
  state 133: #21 #22
	<var> state 134
  state 134: #21 #22
	<var> state 135
  state 135: #21 #22
  state 136: #18 #21 #23
}
{
  rule #0: x::int~=y::int = x~=y
  rule #1: x::double~=y::double = x~=y
  rule #2: x::int~=y::double = x~=y
  rule #3: x::double~=y::int = x~=y
  rule #4: x::bigint~=y::bigint = __C::bigint_cmp x y~=0
  rule #5: x::int~=y::bigint = bigint x~=y
  rule #6: x::bigint~=y::int = x~=bigint y
  rule #7: x::bigint~=y::double = double x~=y
  rule #8: x::double~=y::bigint = x~=double y
  rule #9: x::matrix~=y::matrix = ~x==y
  rule #10: x::string~=y::string = __C::strcmp x y~=0
  rule #11: (x=>v)~=(y=>w) = x~=y||v~=w
  rule #12: ()~=() = 0
  rule #13: (x,xs)~=(y,ys) = x~=y||xs~=ys
  rule #14: (x,xs)~=_ = 1
  rule #15: ()~=_ = 1
  rule #16: _~=(x,xs) = 1
  rule #17: _~=() = 1
  rule #18: []~=[] = 0
  rule #19: x:xs~=[] = 1
  rule #20: []~=x:xs = 1
  rule #21: x:xs~=y:ys = x~=y||xs~=ys
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16 #17 #18 #19 #20 #21
	<var> state 1
	<var>::int state 8
	<var>::bigint state 18
	<var>::double state 28
	<var>::string state 38
	<var>::matrix state 46
	<app> state 54
	[] state 113
	() state 124
  state 1: #16 #17
	<app> state 2
	() state 7
  state 2: #16
	<app> state 3
  state 3: #16
	, state 4
  state 4: #16
	<var> state 5
  state 5: #16
	<var> state 6
  state 6: #16
  state 7: #17
  state 8: #0 #2 #5 #16 #17
	<var>::int state 9
	<var>::bigint state 10
	<var>::double state 11
	<app> state 12
	() state 17
  state 9: #0
  state 10: #5
  state 11: #2
  state 12: #16
	<app> state 13
  state 13: #16
	, state 14
  state 14: #16
	<var> state 15
  state 15: #16
	<var> state 16
  state 16: #16
  state 17: #17
  state 18: #4 #6 #7 #16 #17
	<var>::int state 19
	<var>::bigint state 20
	<var>::double state 21
	<app> state 22
	() state 27
  state 19: #6
  state 20: #4
  state 21: #7
  state 22: #16
	<app> state 23
  state 23: #16
	, state 24
  state 24: #16
	<var> state 25
  state 25: #16
	<var> state 26
  state 26: #16
  state 27: #17
  state 28: #1 #3 #8 #16 #17
	<var>::int state 29
	<var>::bigint state 30
	<var>::double state 31
	<app> state 32
	() state 37
  state 29: #3
  state 30: #8
  state 31: #1
  state 32: #16
	<app> state 33
  state 33: #16
	, state 34
  state 34: #16
	<var> state 35
  state 35: #16
	<var> state 36
  state 36: #16
  state 37: #17
  state 38: #10 #16 #17
	<var>::string state 39
	<app> state 40
	() state 45
  state 39: #10
  state 40: #16
	<app> state 41
  state 41: #16
	, state 42
  state 42: #16
	<var> state 43
  state 43: #16
	<var> state 44
  state 44: #16
  state 45: #17
  state 46: #9 #16 #17
	<var>::matrix state 47
	<app> state 48
	() state 53
  state 47: #9
  state 48: #16
	<app> state 49
  state 49: #16
	, state 50
  state 50: #16
	<var> state 51
  state 51: #16
	<var> state 52
  state 52: #16
  state 53: #17
  state 54: #11 #13 #14 #16 #17 #19 #21
	<var> state 55
	<app> state 63
  state 55: #16 #17
	<var> state 56
  state 56: #16 #17
	<app> state 57
	() state 62
  state 57: #16
	<app> state 58
  state 58: #16
	, state 59
  state 59: #16
	<var> state 60
  state 60: #16
	<var> state 61
  state 61: #16
  state 62: #17
  state 63: #11 #13 #14 #16 #17 #19 #21
	<var> state 64
	: state 73
	, state 86
	=> state 101
  state 64: #16 #17
	<var> state 65
  state 65: #16 #17
	<var> state 66
  state 66: #16 #17
	<app> state 67
	() state 72
  state 67: #16
	<app> state 68
  state 68: #16
	, state 69
  state 69: #16
	<var> state 70
  state 70: #16
	<var> state 71
  state 71: #16
  state 72: #17
  state 73: #16 #17 #19 #21
	<var> state 74
  state 74: #16 #17 #19 #21
	<var> state 75
  state 75: #16 #17 #19 #21
	<app> state 76
	[] state 84
	() state 85
  state 76: #16 #21
	<app> state 77
  state 77: #16 #21
	: state 78
	, state 81
  state 78: #21
	<var> state 79
  state 79: #21
	<var> state 80
  state 80: #21
  state 81: #16
	<var> state 82
  state 82: #16
	<var> state 83
  state 83: #16
  state 84: #19
  state 85: #17
  state 86: #13 #14 #16 #17
	<var> state 87
  state 87: #13 #14 #16 #17
	<var> state 88
  state 88: #13 #14 #16 #17
	<var> state 89
	<app> state 90
	() state 100
  state 89: #14
  state 90: #13 #14 #16
	<var> state 91
	<app> state 93
  state 91: #14
	<var> state 92
  state 92: #14
  state 93: #13 #14 #16
	<var> state 94
	, state 97
  state 94: #14
	<var> state 95
  state 95: #14
	<var> state 96
  state 96: #14
  state 97: #13 #14 #16
	<var> state 98
  state 98: #13 #14 #16
	<var> state 99
  state 99: #13 #14 #16
  state 100: #14 #17
  state 101: #11 #16 #17
	<var> state 102
  state 102: #11 #16 #17
	<var> state 103
  state 103: #11 #16 #17
	<app> state 104
	() state 112
  state 104: #11 #16
	<app> state 105
  state 105: #11 #16
	, state 106
	=> state 109
  state 106: #16
	<var> state 107
  state 107: #16
	<var> state 108
  state 108: #16
  state 109: #11
	<var> state 110
  state 110: #11
	<var> state 111
  state 111: #11
  state 112: #17
  state 113: #16 #17 #18 #20
	<app> state 114
	[] state 122
	() state 123
  state 114: #16 #20
	<app> state 115
  state 115: #16 #20
	: state 116
	, state 119
  state 116: #20
	<var> state 117
  state 117: #20
	<var> state 118
  state 118: #20
  state 119: #16
	<var> state 120
  state 120: #16
	<var> state 121
  state 121: #16
  state 122: #18
  state 123: #17
  state 124: #12 #15 #16 #17
	<var> state 125
	<app> state 126
	() state 136
  state 125: #15
  state 126: #15 #16
	<var> state 127
	<app> state 129
  state 127: #15
	<var> state 128
  state 128: #15
  state 129: #15 #16
	<var> state 130
	, state 133
  state 130: #15
	<var> state 131
  state 131: #15
	<var> state 132
  state 132: #15
  state 133: #15 #16
	<var> state 134
  state 134: #15 #16
	<var> state 135
  state 135: #15 #16
  state 136: #12 #15 #17
}
{
  rule #0: f$x = f x
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: #p::pointer = blob_size p if blobp p
  rule #1: #x::matrix = __C::matrix_size x
  rule #2: #s::string = __C::string_size s
  rule #3: #() = 0
  rule #4: #(x,xs) = accum 1 xs with accum n::int (x,xs) = accum (n+1) xs; accum n::int x = n+1 end
  rule #5: #[] = 0
  rule #6: #(x:xs) = accum 1 xs with accum n::int (x:xs) = accum (n+1) xs; accum n::int [] = n; accum n::int xs = n+#xs end
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var>::string state 1
	<var>::pointer state 2
	<var>::matrix state 3
	<app> state 4
	[] state 12
	() state 13
  state 1: #2
  state 2: #0
  state 3: #1
  state 4: #4 #6
	<app> state 5
  state 5: #4 #6
	: state 6
	, state 9
  state 6: #6
	<var> state 7
  state 7: #6
	<var> state 8
  state 8: #6
  state 9: #4
	<var> state 10
  state 10: #4
	<var> state 11
  state 11: #4
  state 12: #5
  state 13: #3
}
{
  rule #0: x::matrix!i::int = __C::matrix_elem_at x i if i>=0&&i<#x
  rule #1: x::matrix!i::int = throw out_of_bounds
  rule #2: x::matrix!(i::int,j::int) = __C::matrix_elem_at2 x i j if (i>=0&&i<n&&j>=0&&j<m when n::int,m::int = dim x end)
  rule #3: x::matrix!(i::int,j::int) = throw out_of_bounds
  rule #4: x::matrix!y = __C::record_elem_at x y if recordp x
  rule #5: s::string!n::int = __C::string_char_at s n if n>=0&&n<#s
  rule #6: s::string!n::int = throw out_of_bounds
  rule #7: (x,xs)!n::int = throw out_of_bounds if n<0
  rule #8: (x,xs)!0 = x
  rule #9: (x,y,xs)!n::int = (y,xs)!(n-1)
  rule #10: (x,y)!1 = y
  rule #11: (x,y)!n::int = throw out_of_bounds
  rule #12: ()!n::int = throw out_of_bounds
  rule #13: []!n::int = throw out_of_bounds
  rule #14: (x:xs)!0 = x
  rule #15: (x:xs)!n::int = xs!(n-1) if n>0
  rule #16: (x:xs)!n::int = throw out_of_bounds
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16
	<var>::string state 1
	<var>::matrix state 3
	<app> state 19
	[] state 51
	() state 53
  state 1: #5 #6
	<var>::int state 2
  state 2: #5 #6
  state 3: #0 #1 #2 #3 #4
	<var> state 4
	<var>::int state 5
	<app> state 6
  state 4: #4
  state 5: #0 #1 #4
  state 6: #2 #3 #4
	<var> state 7
	<app> state 9
  state 7: #4
	<var> state 8
  state 8: #4
  state 9: #2 #3 #4
	<var> state 10
	, state 13
  state 10: #4
	<var> state 11
  state 11: #4
	<var> state 12
  state 12: #4
  state 13: #2 #3 #4
	<var> state 14
	<var>::int state 16
  state 14: #4
	<var> state 15
  state 15: #4
  state 16: #2 #3 #4
	<var> state 17
	<var>::int state 18
  state 17: #4
  state 18: #2 #3 #4
  state 19: #7 #8 #9 #10 #11 #14 #15 #16
	<app> state 20
  state 20: #7 #8 #9 #10 #11 #14 #15 #16
	: state 21
	, state 26
  state 21: #14 #15 #16
	<var> state 22
  state 22: #14 #15 #16
	<var> state 23
  state 23: #14 #15 #16
	<var>::int state 24
	0::int state 25
  state 24: #15 #16
  state 25: #14 #15 #16
  state 26: #7 #8 #9 #10 #11
	<var> state 27
  state 27: #7 #8 #9 #10 #11
	<var> state 28
	<app> state 32
  state 28: #7 #8 #10 #11
	<var>::int state 29
	0::int state 30
	1::int state 31
  state 29: #7 #11
  state 30: #7 #8 #11
  state 31: #7 #10 #11
  state 32: #7 #8 #9 #10 #11
	<var> state 33
	<app> state 38
  state 33: #7 #8 #10 #11
	<var> state 34
  state 34: #7 #8 #10 #11
	<var>::int state 35
	0::int state 36
	1::int state 37
  state 35: #7 #11
  state 36: #7 #8 #11
  state 37: #7 #10 #11
  state 38: #7 #8 #9 #10 #11
	<var> state 39
	, state 45
  state 39: #7 #8 #10 #11
	<var> state 40
  state 40: #7 #8 #10 #11
	<var> state 41
  state 41: #7 #8 #10 #11
	<var>::int state 42
	0::int state 43
	1::int state 44
  state 42: #7 #11
  state 43: #7 #8 #11
  state 44: #7 #10 #11
  state 45: #7 #8 #9 #10 #11
	<var> state 46
  state 46: #7 #8 #9 #10 #11
	<var> state 47
  state 47: #7 #8 #9 #10 #11
	<var>::int state 48
	0::int state 49
	1::int state 50
  state 48: #7 #9 #11
  state 49: #7 #8 #9 #11
  state 50: #7 #9 #10 #11
  state 51: #13
	<var>::int state 52
  state 52: #13
  state 53: #12
	<var>::int state 54
  state 54: #12
}
{
  rule #0: x!!ns::matrix = x!!list ns
  rule #1: x!!(ns::matrix,ms) = x!!(list ns,ms) if ~tuplep ms
  rule #2: x!!(ns,ms::matrix) = x!!(ns,list ms)
  rule #3: x!!(ns::int,ms) = x!!([ns],ms) if ~tuplep ms
  rule #4: x!!(ns,ms::int) = x!!(ns,[ms])
  rule #5: x::matrix!!(ns,ms) = case ns,ms of ns@(n:_),ms@(m:_) = submat x (n,m) (#ns,#ms) if cont ns&&cont ms; _ = colcatmap (mth (rowcatmap (nth x) ns)) ms end with cont [n::int] = 1; cont (n::int:ns@(m::int:_)) = cont ns if m==n+1; cont _ = 0; mth x m = catch (cst {}) (col x m); nth x n = catch (cst {}) (row x n) end
  rule #6: x::matrix!!ns = if all intp ns&&packed x then rowvector x!!([0],ns) else colcatmap (nth x) ns with nth x n = catch (cst {}) {x!n} end
  rule #7: s::string!!ns = case ns of ns@(n:_) = substr s n (count ns) if cont ns; _ = string (chars s!!ns) end with cont [n::int] = 1; cont (n::int:ns@(m::int:_)) = cont ns if m==n+1; cont _ = 0; count ns = #dropwhile (\n::int -> n<0) ns end
  rule #8: xs@()!!ns = tuple (list xs!!ns)
  rule #9: xs@(_,_)!!ns = tuple (list xs!!ns)
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9
	<var> state 1
	<var>::string state 17
	<var>::matrix state 40
	<app> state 63
	() state 125
  state 1: #0 #1 #2 #3 #4
	<var>::matrix state 2
	<app> state 3
  state 2: #0
  state 3: #1 #2 #3 #4
	<app> state 4
  state 4: #1 #2 #3 #4
	, state 5
  state 5: #1 #2 #3 #4
	<var> state 6
	<var>::int state 9
	<var>::matrix state 13
  state 6: #2 #4
	<var>::int state 7
	<var>::matrix state 8
  state 7: #4
  state 8: #2
  state 9: #2 #3 #4
	<var> state 10
	<var>::int state 11
	<var>::matrix state 12
  state 10: #3
  state 11: #3 #4
  state 12: #2 #3
  state 13: #1 #2 #4
	<var> state 14
	<var>::int state 15
	<var>::matrix state 16
  state 14: #1
  state 15: #1 #4
  state 16: #1 #2
  state 17: #0 #1 #2 #3 #4 #7
	<var> state 18
	<var>::matrix state 19
	<app> state 20
  state 18: #7
  state 19: #0 #7
  state 20: #1 #2 #3 #4 #7
	<var> state 21
	<app> state 23
  state 21: #7
	<var> state 22
  state 22: #7
  state 23: #1 #2 #3 #4 #7
	<var> state 24
	, state 27
  state 24: #7
	<var> state 25
  state 25: #7
	<var> state 26
  state 26: #7
  state 27: #1 #2 #3 #4 #7
	<var> state 28
	<var>::int state 32
	<var>::matrix state 36
  state 28: #2 #4 #7
	<var> state 29
	<var>::int state 30
	<var>::matrix state 31
  state 29: #7
  state 30: #4 #7
  state 31: #2 #7
  state 32: #2 #3 #4 #7
	<var> state 33
	<var>::int state 34
	<var>::matrix state 35
  state 33: #3 #7
  state 34: #3 #4 #7
  state 35: #2 #3 #7
  state 36: #1 #2 #4 #7
	<var> state 37
	<var>::int state 38
	<var>::matrix state 39
  state 37: #1 #7
  state 38: #1 #4 #7
  state 39: #1 #2 #7
  state 40: #0 #1 #2 #3 #4 #5 #6
	<var> state 41
	<var>::matrix state 42
	<app> state 43
  state 41: #6
  state 42: #0 #6
  state 43: #1 #2 #3 #4 #5 #6
	<var> state 44
	<app> state 46
  state 44: #6
	<var> state 45
  state 45: #6
  state 46: #1 #2 #3 #4 #5 #6
	<var> state 47
	, state 50
  state 47: #6
	<var> state 48
  state 48: #6
	<var> state 49
  state 49: #6
  state 50: #1 #2 #3 #4 #5 #6
	<var> state 51
	<var>::int state 55
	<var>::matrix state 59
  state 51: #2 #4 #5 #6
	<var> state 52
	<var>::int state 53
	<var>::matrix state 54
  state 52: #5 #6
  state 53: #4 #5 #6
  state 54: #2 #5 #6
  state 55: #2 #3 #4 #5 #6
	<var> state 56
	<var>::int state 57
	<var>::matrix state 58
  state 56: #3 #5 #6
  state 57: #3 #4 #5 #6
  state 58: #2 #3 #5 #6
  state 59: #1 #2 #4 #5 #6
	<var> state 60
	<var>::int state 61
	<var>::matrix state 62
  state 60: #1 #5 #6
  state 61: #1 #4 #5 #6
  state 62: #1 #2 #5 #6
  state 63: #0 #1 #2 #3 #4 #9
	<var> state 64
	<app> state 81
  state 64: #0 #1 #2 #3 #4
	<var> state 65
  state 65: #0 #1 #2 #3 #4
	<var>::matrix state 66
	<app> state 67
  state 66: #0
  state 67: #1 #2 #3 #4
	<app> state 68
  state 68: #1 #2 #3 #4
	, state 69
  state 69: #1 #2 #3 #4
	<var> state 70
	<var>::int state 73
	<var>::matrix state 77
  state 70: #2 #4
	<var>::int state 71
	<var>::matrix state 72
  state 71: #4
  state 72: #2
  state 73: #2 #3 #4
	<var> state 74
	<var>::int state 75
	<var>::matrix state 76
  state 74: #3
  state 75: #3 #4
  state 76: #2 #3
  state 77: #1 #2 #4
	<var> state 78
	<var>::int state 79
	<var>::matrix state 80
  state 78: #1
  state 79: #1 #4
  state 80: #1 #2
  state 81: #0 #1 #2 #3 #4 #9
	<var> state 82
	, state 100
  state 82: #0 #1 #2 #3 #4
	<var> state 83
  state 83: #0 #1 #2 #3 #4
	<var> state 84
  state 84: #0 #1 #2 #3 #4
	<var>::matrix state 85
	<app> state 86
  state 85: #0
  state 86: #1 #2 #3 #4
	<app> state 87
  state 87: #1 #2 #3 #4
	, state 88
  state 88: #1 #2 #3 #4
	<var> state 89
	<var>::int state 92
	<var>::matrix state 96
  state 89: #2 #4
	<var>::int state 90
	<var>::matrix state 91
  state 90: #4
  state 91: #2
  state 92: #2 #3 #4
	<var> state 93
	<var>::int state 94
	<var>::matrix state 95
  state 93: #3
  state 94: #3 #4
  state 95: #2 #3
  state 96: #1 #2 #4
	<var> state 97
	<var>::int state 98
	<var>::matrix state 99
  state 97: #1
  state 98: #1 #4
  state 99: #1 #2
  state 100: #0 #1 #2 #3 #4 #9
	<var> state 101
  state 101: #0 #1 #2 #3 #4 #9
	<var> state 102
  state 102: #0 #1 #2 #3 #4 #9
	<var> state 103
	<var>::matrix state 104
	<app> state 105
  state 103: #9
  state 104: #0 #9
  state 105: #1 #2 #3 #4 #9
	<var> state 106
	<app> state 108
  state 106: #9
	<var> state 107
  state 107: #9
  state 108: #1 #2 #3 #4 #9
	<var> state 109
	, state 112
  state 109: #9
	<var> state 110
  state 110: #9
	<var> state 111
  state 111: #9
  state 112: #1 #2 #3 #4 #9
	<var> state 113
	<var>::int state 117
	<var>::matrix state 121
  state 113: #2 #4 #9
	<var> state 114
	<var>::int state 115
	<var>::matrix state 116
  state 114: #9
  state 115: #4 #9
  state 116: #2 #9
  state 117: #2 #3 #4 #9
	<var> state 118
	<var>::int state 119
	<var>::matrix state 120
  state 118: #3 #9
  state 119: #3 #4 #9
  state 120: #2 #3 #9
  state 121: #1 #2 #4 #9
	<var> state 122
	<var>::int state 123
	<var>::matrix state 124
  state 122: #1 #9
  state 123: #1 #4 #9
  state 124: #1 #2 #9
  state 125: #0 #1 #2 #3 #4 #8
	<var> state 126
	<var>::matrix state 127
	<app> state 128
  state 126: #8
  state 127: #0 #8
  state 128: #1 #2 #3 #4 #8
	<var> state 129
	<app> state 131
  state 129: #8
	<var> state 130
  state 130: #8
  state 131: #1 #2 #3 #4 #8
	<var> state 132
	, state 135
  state 132: #8
	<var> state 133
  state 133: #8
	<var> state 134
  state 134: #8
  state 135: #1 #2 #3 #4 #8
	<var> state 136
	<var>::int state 140
	<var>::matrix state 144
  state 136: #2 #4 #8
	<var> state 137
	<var>::int state 138
	<var>::matrix state 139
  state 137: #8
  state 138: #4 #8
  state 139: #2 #8
  state 140: #2 #3 #4 #8
	<var> state 141
	<var>::int state 142
	<var>::matrix state 143
  state 141: #3 #8
  state 142: #3 #4 #8
  state 143: #2 #3 #8
  state 144: #1 #2 #4 #8
	<var> state 145
	<var>::int state 146
	<var>::matrix state 147
  state 145: #1 #8
  state 146: #1 #4 #8
  state 147: #1 #2 #8
}
{
  rule #0: (f.g) x = f (g x)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}
{
  rule #0: val (x=>v) = v
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	=> state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}
{
  rule #0: null x::pointer = x===#<pointer 0> if __C::pure_pointer_equal (get_ptrtag x)===#<pointer 0>
  rule #1: null x::matrix = #x==0
  rule #2: null s::string = __C::string_null s
  rule #3: null () = 1
  rule #4: null (x,xs) = 0
  rule #5: null [] = 1
  rule #6: null (x:xs) = 0
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var>::string state 1
	<var>::pointer state 2
	<var>::matrix state 3
	<app> state 4
	[] state 12
	() state 13
  state 1: #2
  state 2: #0
  state 3: #1
  state 4: #4 #6
	<app> state 5
  state 5: #4 #6
	: state 6
	, state 9
  state 6: #6
	<var> state 7
  state 7: #6
	<var> state 8
  state 8: #6
  state 9: #4
	<var> state 10
  state 10: #4
	<var> state 11
  state 11: #4
  state 12: #5
  state 13: #3
}
{
  rule #0: cst x y = x
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: reverse x::matrix = rowrev (colrev x)
  rule #1: reverse s::string = strcat (reverse (chars s))
  rule #2: reverse () = ()
  rule #3: reverse (x,xs) = accum x xs with accum ys (x,xs) = accum (x,ys) xs; accum ys x = x,ys end
  state 0: #0 #1 #2 #3
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
	() state 8
  state 1: #1
  state 2: #0
  state 3: #3
	<app> state 4
  state 4: #3
	, state 5
  state 5: #3
	<var> state 6
  state 6: #3
	<var> state 7
  state 7: #3
  state 8: #2
}
{
  rule #0: uncurry f (x,y) = f x y
  state 0: #0
	<var> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
}
{
  rule #0: uncurry3 f (x,y,z) = f x y z
  state 0: #0
	<var> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	<app> state 7
  state 7: #0
	, state 8
  state 8: #0
	<var> state 9
  state 9: #0
	<var> state 10
  state 10: #0
}
{
  rule #0: void _ = ()
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: id x = x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: curry f x y = f (x,y)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}
{
  rule #0: curry3 f x y z = f (x,y,z)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
	<var> state 4
  state 4: #0
}
{
  rule #0: fix f = f (fix f&)
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: key (x=>v) = x
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	=> state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}
{
  rule #0: tuple2 x y = 'comma x y when comma = (,) end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: tuple3 x y z = 'comma x (comma y z) when comma = (,) end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}
{
  rule #0: mapfst f (a,b) = tuple2 (f a) b
  state 0: #0
	<var> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
}
{
  rule #0: mapsnd f (a,b) = tuple2 a (f b)
  state 0: #0
	<var> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
}
{
  rule #0: maptrd f (a,b,c) = tuple3 a b (f c)
  state 0: #0
	<var> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	<app> state 7
  state 7: #0
	, state 8
  state 8: #0
	<var> state 9
  state 9: #0
	<var> state 10
  state 10: #0
}
{
  rule #0: fst _ (a,_) = a
  rule #1: fst none () = none
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<app> state 2
	() state 7
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
}
{
  rule #0: snd _ (_,a) = a
  rule #1: snd none () = none
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<app> state 2
	() state 7
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
}
{
  rule #0: trd _ (_,_,a) = a
  rule #1: trd none () = none
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<app> state 2
	() state 11
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	<app> state 7
  state 7: #0
	, state 8
  state 8: #0
	<var> state 9
  state 9: #0
	<var> state 10
  state 10: #0
  state 11: #1
}
{
  rule #0: list1 x = [x]
  state 0: #0
	<var> state 1
  state 1: #0
}
xs/*0:01*/!!ns/*0:1*/ = ys/*0:*/ if ok/*1*/ ys/*0:*/ when ys/*0:*/ = case ns/*0:1*/ of ns@(n/*0:01*/ :: int:_/*0:1*/) = list (take (count/*1*/ ns/*0:*/) (drop n/*0:01*/ xs/*1:01*/)) if listp xs/*1:01*/&&cont/*1*/ ns/*0:*/; _/*0:*/ = catmap (nth/*1*/ xs/*1:01*/) ns/*1:1*/ {
  rule #0: ns@(n::int:_) = list (take (count ns) (drop n xs)) if listp xs&&cont ns
  rule #1: _ = catmap (nth xs) ns
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	: state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
	<var>::int state 12
  state 10: #1
	<var> state 11
  state 11: #1
  state 12: #0 #1
	<var> state 13
  state 13: #0 #1
} end {
  rule #0: ys = case ns of ns@(n::int:_) = list (take (count ns) (drop n xs)) if listp xs&&cont ns; _ = catmap (nth xs) ns end
  state 0: #0
	<var> state 1
  state 1: #0
} end with ok (catmap (nth _/*0:1011*/) _/*0:11*/) = 0; ok _/*0:1*/ = 1 {
  rule #0: ok (catmap (nth _) _) = 0
  rule #1: ok _ = 1
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	catmap state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #1
	<var> state 11
  state 11: #1
  state 12: #0 #1
	<var> state 13
	nth state 16
  state 13: #1
	<var> state 14
  state 14: #1
	<var> state 15
  state 15: #1
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
}; cont (n/*0:101*/ :: int:ns/*0:11*/) = ~thunkp ns/*0:11*/&&(case ns/*0:11*/ of [] = 1; m/*0:01*/ :: int:_/*0:1*/ = cont/*2*/ ns/*1:11*/ if m/*0:01*/==n/*1:101*/+1; _/*0:*/ = 0 {
  rule #0: [] = 1
  rule #1: m::int:_ = cont ns if m==n+1
  rule #2: _ = 0
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
	[] state 14
  state 1: #2
  state 2: #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
	<var>::int state 12
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #1 #2
	<var> state 13
  state 13: #1 #2
  state 14: #0 #2
} end) {
  rule #0: cont (n::int:ns) = ~thunkp ns&&(case ns of [] = 1; m::int:_ = cont ns if m==n+1; _ = 0 end)
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var>::int state 4
  state 4: #0
	<var> state 5
  state 5: #0
}; nth xs/*0:01*/ n/*0:1*/ = catch (cst []) [xs/*1:01*/!n/*1:1*/] {
  rule #0: nth xs n = catch (cst []) [xs!n]
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}; count ns/*0:1*/ = #dropwhile (\n/*0:1*/ :: int -> n/*0:1*/<0 {
  rule #0: _ n::int = n<0
  state 0: #0
	<var>::int state 1
  state 1: #0
}) ns/*0:1*/ {
  rule #0: count ns = #dropwhile (\n::int -> n<0) ns
  state 0: #0
	<var> state 1
  state 1: #0
} end;
subseq [] a/*0:01*/ :: int b/*0:1*/ :: int = [];
subseq xs@(_/*0:00101*/:_/*0:0011*/) a/*0:01*/ :: int b/*0:1*/ :: int = take/*0*/ (b/*0:1*/-a/*0:01*/+1) (drop a/*0:01*/ xs/*0:001*/) with take 0 xs/*0:1*/ = []; take m/*0:01*/ :: int xs/*0:1*/ = take_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with take_pre 0 _/*0:1*/ = front_tail/*1:1*/; take_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:take_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/ {
  rule #0: take_pre 0 _ = front_tail
  rule #1: take_pre n::int (x:xs) = x:take_pre (n-1) xs
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ front_tail/*0:1*/ = skip_ahead/*1*/ m/*0:01*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ front_tail = skip_ahead m 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: take 0 xs = []
  rule #1: take m::int xs = take_pre len_pre xs with take_pre 0 _ = front_tail; take_pre n::int (x:xs) = x:take_pre (n-1) xs end when len_pre@_ front_tail = skip_ahead m 0 xs end
  state 0: #0 #1
	<var>::int state 1
	0::int state 3
  state 1: #1
	<var> state 2
  state 2: #1
  state 3: #0 #1
	<var> state 4
  state 4: #0 #1
}; skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ [] if m/*0:001*/<=0||xs/*0:1*/===[]; skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = skip_ahead/*1*/ (m/*0:001*/-1) (n/*0:01*/+1) xs/*0:11*/ if n/*0:01*/<4096; skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (take/*1*/ m/*0:001*/ xs/*0:1*/) {
  rule #0: skip_ahead m::int n::int xs = n [] if m<=0||xs===[]
  rule #1: skip_ahead m::int n::int (x:xs) = skip_ahead (m-1) (n+1) xs if n<4096
  rule #2: skip_ahead m::int n::int xs = n (take m xs)
  state 0: #0 #1 #2
	<var>::int state 1
  state 1: #0 #1 #2
	<var>::int state 2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 4
  state 3: #0 #2
  state 4: #0 #1 #2
	<var> state 5
	<app> state 7
  state 5: #0 #2
	<var> state 6
  state 6: #0 #2
  state 7: #0 #1 #2
	<var> state 8
	: state 11
  state 8: #0 #2
	<var> state 9
  state 9: #0 #2
	<var> state 10
  state 10: #0 #2
  state 11: #0 #1 #2
	<var> state 12
  state 12: #0 #1 #2
	<var> state 13
  state 13: #0 #1 #2
} end;
subseq x/*0:001*/ a/*0:01*/ b/*0:1*/ = slice x/*0:001*/ (a/*0:01*/..b/*0:1*/);
def x/*0:01*/!!(a/*0:101*/..b/*0:11*/) = subseq x/*0:01*/ a/*0:101*/ b/*0:11*/;
list () = [];
list (x/*0:101*/,xs/*0:11*/) = accum/*0*/ [x/*0:101*/] xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/,xs/*0:11*/) = accum/*1*/ (x/*0:101*/:ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ x/*0:1*/ = __std__::reverse_onto [] (x/*0:1*/:ys/*0:01*/) {
  rule #0: accum ys (x,xs) = accum (x:ys) xs
  rule #1: accum ys x = __std__::reverse_onto [] (x:ys)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	, state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
} end;
tuple [] = ();
tuple (x/*0:101*/:xs/*0:11*/) = accum/*0*/ (t/*0*/ x/*0:101*/) xs/*0:11*/ with t x@(_/*0:101*/,_/*0:11*/) = reverse x/*0:1*/; t x/*0:1*/ = x/*0:1*/ {
  rule #0: t x@(_,_) = reverse x
  rule #1: t x = x
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	, state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
}; accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (t/*1*/ x/*0:101*/,ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ [] = t/*1*/ ys/*0:01*/; accum ys/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: accum ys (x:xs) = accum (t x,ys) xs
  rule #1: accum ys [] = t ys
  rule #2: accum ys xs = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
tuple x@() = x/*0:1*/;
tuple x@(_/*0:101*/,_/*0:11*/) = x/*0:1*/;
list [] = [];
list (x/*0:101*/:xs/*0:11*/) = accum/*0*/ [x/*0:101*/] xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (x/*0:101*/:ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ [] = __std__::reverse_onto [] ys/*0:01*/; accum ys/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: accum ys (x:xs) = accum (x:ys) xs
  rule #1: accum ys [] = __std__::reverse_onto [] ys
  rule #2: accum ys xs = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
stream [] = [];
stream (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:xs/*0:11*/ if thunkp xs/*0:11*/;
stream (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:stream xs/*1:11*/&;
stream () = [];
stream xs@(_/*0:101*/,_/*0:11*/) = stream (list xs/*0:1*/);
catstream [] = [];
catstream ((x/*0:10101*/:xs/*0:1011*/):yss/*0:11*/) = x/*0:10101*/:catstream (xs/*1:1011*/:yss/*1:11*/)&;
catstream ([]:yss/*0:11*/) = catstream yss/*0:11*/;
catstream (xs/*0:101*/ :: string:yss/*0:11*/) = catstream (chars xs/*0:101*/:yss/*0:11*/);
catstream (xs/*0:101*/:yss/*0:11*/) = xs/*0:101*/+catstream yss/*0:11*/;
x/*0:01*/ :: smatrix==?y/*0:1*/ :: matrix = 0 if dim x/*0:01*/~=dim y/*0:1*/;
x/*0:01*/ :: matrix==?y/*0:1*/ :: smatrix = 0 if dim x/*0:01*/~=dim y/*0:1*/;
x/*0:01*/ :: smatrix==?y/*0:1*/ :: matrix = compare/*0*/ 0 with compare i/*0:1*/ :: int = 1 if i/*0:1*/>=n/*1:*/; compare i/*0:1*/ :: int = 0 if x/*2:01*/!i/*0:1*/~=?y/*2:1*/!i/*0:1*/; compare i/*0:1*/ :: int = compare/*1*/ (i/*0:1*/+1) {
  rule #0: compare i::int = 1 if i>=n
  rule #1: compare i::int = 0 if x!i~=?y!i
  rule #2: compare i::int = compare (i+1)
  state 0: #0 #1 #2
	<var>::int state 1
  state 1: #0 #1 #2
} end when n/*0:*/ :: int = #x/*0:01*/ {
  rule #0: n::int = #x
  state 0: #0
	<var>::int state 1
  state 1: #0
} end;
x/*0:01*/ :: matrix==?y/*0:1*/ :: smatrix = compare/*0*/ 0 with compare i/*0:1*/ :: int = 1 if i/*0:1*/>=n/*1:*/; compare i/*0:1*/ :: int = 0 if x/*2:01*/!i/*0:1*/~=?y/*2:1*/!i/*0:1*/; compare i/*0:1*/ :: int = compare/*1*/ (i/*0:1*/+1) {
  rule #0: compare i::int = 1 if i>=n
  rule #1: compare i::int = 0 if x!i~=?y!i
  rule #2: compare i::int = compare (i+1)
  state 0: #0 #1 #2
	<var>::int state 1
  state 1: #0 #1 #2
} end when n/*0:*/ :: int = #x/*0:01*/ {
  rule #0: n::int = #x
  state 0: #0
	<var>::int state 1
  state 1: #0
} end;
x/*0:01*/ :: smatrix~=?y/*0:1*/ :: matrix = ~x/*0:01*/==?y/*0:1*/;
x/*0:01*/ :: matrix~=?y/*0:1*/ :: smatrix = ~x/*0:01*/==?y/*0:1*/;
(x/*0:0101*/=>v/*0:011*/)==?(y/*0:101*/=>w/*0:11*/) = x/*0:0101*/==?y/*0:101*/&&v/*0:011*/==?w/*0:11*/;
(x/*0:0101*/=>v/*0:011*/)~=?(y/*0:101*/=>w/*0:11*/) = x/*0:0101*/~=?y/*0:101*/||v/*0:011*/~=?w/*0:11*/;
(x/*0:0101*/,xs/*0:011*/)==?(y/*0:101*/,ys/*0:11*/) = x/*0:0101*/==?y/*0:101*/&&xs/*0:011*/==?ys/*0:11*/;
(x/*0:0101*/,xs/*0:011*/)~=?(y/*0:101*/,ys/*0:11*/) = x/*0:0101*/~=?y/*0:101*/||xs/*0:011*/~=?ys/*0:11*/;
x/*0:0101*/:xs/*0:011*/==?y/*0:101*/:ys/*0:11*/ = x/*0:0101*/==?y/*0:101*/&&xs/*0:011*/==?ys/*0:11*/;
x/*0:0101*/:xs/*0:011*/~=?y/*0:101*/:ys/*0:11*/ = x/*0:0101*/~=?y/*0:101*/||xs/*0:011*/~=?ys/*0:11*/;
x/*0:01*/==?y/*0:1*/ = case x/*0:01*/==y/*0:1*/ of res/*0:*/ :: int = res/*0:*/; _/*0:*/ = case x/*1:01*/:y/*1:1*/ of xh@_/*0:010*/ xv/*0:011*/:yh@_/*0:10*/ yv/*0:11*/ = xh/*0:010*/==?yh/*0:10*/&&xv/*0:011*/==?yv/*0:11*/; x/*0:01*/:x/*0:1*/ = 1; _/*0:*/ = 0 {
  rule #0: xh@_ xv:yh@_ yv = xh==?yh&&xv==?yv
  rule #1: x:x = 1
  rule #2: _ = 0
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #1 #2
	<var> state 10
	<app> state 12
  state 10: #1 #2
	<var> state 11
  state 11: #1 #2
  state 12: #0 #1 #2
	<var> state 13
  state 13: #0 #1 #2
	<var> state 14
  state 14: #0 #1 #2
	<var> state 15
	<app> state 16
  state 15: #1 #2
  state 16: #0 #1 #2
	<var> state 17
  state 17: #0 #1 #2
	<var> state 18
  state 18: #0 #1 #2
} end {
  rule #0: res::int = res
  rule #1: _ = case x:y of xh@_ xv:yh@_ yv = xh==?yh&&xv==?yv; x:x = 1; _ = 0 end
  state 0: #0 #1
	<var> state 1
	<var>::int state 2
  state 1: #1
  state 2: #0 #1
} end;
x/*0:01*/~=?y/*0:1*/ = case x/*0:01*/==y/*0:1*/ of res/*0:*/ :: int = res/*0:*/==0; _/*0:*/ = case x/*1:01*/:y/*1:1*/ of xh@_/*0:010*/ xv/*0:011*/:yh@_/*0:10*/ yv/*0:11*/ = xh/*0:010*/~=?yh/*0:10*/||xv/*0:011*/~=?yv/*0:11*/; x/*0:01*/:x/*0:1*/ = 0; _/*0:*/ = 1 {
  rule #0: xh@_ xv:yh@_ yv = xh~=?yh||xv~=?yv
  rule #1: x:x = 0
  rule #2: _ = 1
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #1 #2
	<var> state 10
	<app> state 12
  state 10: #1 #2
	<var> state 11
  state 11: #1 #2
  state 12: #0 #1 #2
	<var> state 13
  state 13: #0 #1 #2
	<var> state 14
  state 14: #0 #1 #2
	<var> state 15
	<app> state 16
  state 15: #1 #2
  state 16: #0 #1 #2
	<var> state 17
  state 17: #0 #1 #2
	<var> state 18
  state 18: #0 #1 #2
} end {
  rule #0: res::int = res==0
  rule #1: _ = case x:y of xh@_ xv:yh@_ yv = xh~=?yh||xv~=?yv; x:x = 0; _ = 1 end
  state 0: #0 #1
	<var> state 1
	<var>::int state 2
  state 1: #1
  state 2: #0 #1
} end;
def void (catmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (listmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (rowcatmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (colcatmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (rowmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (colmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void x/*0:1*/ = __std__::__voidchk__ x/*0:1*/ x/*0:1*/;
def __std__::__voidchk__ (__ifelse__ y/*0:1001*/ z/*0:101*/ []) = __std__::__voidchk1__ (__ifelse__ y/*0:1001*/ (void z/*0:101*/) ());
def __std__::__voidchk__ (__ifelse__ y/*0:1001*/ z/*0:101*/ {}) = __std__::__voidchk1__ (__ifelse__ y/*0:1001*/ (void z/*0:101*/) ());
def __std__::__voidchk1__ x/*0:01*/ y/*0:1*/ = x/*0:01*/;
{
  rule #0: x::smatrix==?y::matrix = 0 if dim x~=dim y
  rule #1: x::matrix==?y::smatrix = 0 if dim x~=dim y
  rule #2: x::smatrix==?y::matrix = compare 0 with compare i::int = 1 if i>=n; compare i::int = 0 if x!i~=?y!i; compare i::int = compare (i+1) end when n::int = #x end
  rule #3: x::matrix==?y::smatrix = compare 0 with compare i::int = 1 if i>=n; compare i::int = 0 if x!i~=?y!i; compare i::int = compare (i+1) end when n::int = #x end
  rule #4: (x=>v)==?(y=>w) = x==?y&&v==?w
  rule #5: (x,xs)==?(y,ys) = x==?y&&xs==?ys
  rule #6: x:xs==?y:ys = x==?y&&xs==?ys
  rule #7: x==?y = case x==y of res::int = res; _ = case x:y of xh@_ xv:yh@_ yv = xh==?yh&&xv==?yv; x:x = 1; _ = 0 end end
  state 0: #0 #1 #2 #3 #4 #5 #6 #7
	<var> state 1
	<var>::matrix state 4
	<app> state 7
  state 1: #0 #2 #7
	<var> state 2
	<var>::matrix state 3
  state 2: #7
  state 3: #0 #2 #7
  state 4: #0 #1 #2 #3 #7
	<var> state 5
	<var>::matrix state 6
  state 5: #1 #3 #7
  state 6: #0 #1 #2 #3 #7
  state 7: #0 #2 #4 #5 #6 #7
	<var> state 8
	<app> state 12
  state 8: #0 #2 #7
	<var> state 9
  state 9: #0 #2 #7
	<var> state 10
	<var>::matrix state 11
  state 10: #7
  state 11: #0 #2 #7
  state 12: #0 #2 #4 #5 #6 #7
	<var> state 13
	: state 18
	, state 33
	=> state 48
  state 13: #0 #2 #7
	<var> state 14
  state 14: #0 #2 #7
	<var> state 15
  state 15: #0 #2 #7
	<var> state 16
	<var>::matrix state 17
  state 16: #7
  state 17: #0 #2 #7
  state 18: #0 #2 #6 #7
	<var> state 19
  state 19: #0 #2 #6 #7
	<var> state 20
  state 20: #0 #2 #6 #7
	<var> state 21
	<var>::matrix state 22
	<app> state 23
  state 21: #7
  state 22: #0 #2 #7
  state 23: #6 #7
	<var> state 24
	<app> state 26
  state 24: #7
	<var> state 25
  state 25: #7
  state 26: #6 #7
	<var> state 27
	: state 30
  state 27: #7
	<var> state 28
  state 28: #7
	<var> state 29
  state 29: #7
  state 30: #6 #7
	<var> state 31
  state 31: #6 #7
	<var> state 32
  state 32: #6 #7
  state 33: #0 #2 #5 #7
	<var> state 34
  state 34: #0 #2 #5 #7
	<var> state 35
  state 35: #0 #2 #5 #7
	<var> state 36
	<var>::matrix state 37
	<app> state 38
  state 36: #7
  state 37: #0 #2 #7
  state 38: #5 #7
	<var> state 39
	<app> state 41
  state 39: #7
	<var> state 40
  state 40: #7
  state 41: #5 #7
	<var> state 42
	, state 45
  state 42: #7
	<var> state 43
  state 43: #7
	<var> state 44
  state 44: #7
  state 45: #5 #7
	<var> state 46
  state 46: #5 #7
	<var> state 47
  state 47: #5 #7
  state 48: #0 #2 #4 #7
	<var> state 49
  state 49: #0 #2 #4 #7
	<var> state 50
  state 50: #0 #2 #4 #7
	<var> state 51
	<var>::matrix state 52
	<app> state 53
  state 51: #7
  state 52: #0 #2 #7
  state 53: #4 #7
	<var> state 54
	<app> state 56
  state 54: #7
	<var> state 55
  state 55: #7
  state 56: #4 #7
	<var> state 57
	=> state 60
  state 57: #7
	<var> state 58
  state 58: #7
	<var> state 59
  state 59: #7
  state 60: #4 #7
	<var> state 61
  state 61: #4 #7
	<var> state 62
  state 62: #4 #7
}
{
  rule #0: x::smatrix~=?y::matrix = ~x==?y
  rule #1: x::matrix~=?y::smatrix = ~x==?y
  rule #2: (x=>v)~=?(y=>w) = x~=?y||v~=?w
  rule #3: (x,xs)~=?(y,ys) = x~=?y||xs~=?ys
  rule #4: x:xs~=?y:ys = x~=?y||xs~=?ys
  rule #5: x~=?y = case x==y of res::int = res==0; _ = case x:y of xh@_ xv:yh@_ yv = xh~=?yh||xv~=?yv; x:x = 0; _ = 1 end end
  state 0: #0 #1 #2 #3 #4 #5
	<var> state 1
	<var>::matrix state 4
	<app> state 7
  state 1: #0 #5
	<var> state 2
	<var>::matrix state 3
  state 2: #5
  state 3: #0 #5
  state 4: #0 #1 #5
	<var> state 5
	<var>::matrix state 6
  state 5: #1 #5
  state 6: #0 #1 #5
  state 7: #0 #2 #3 #4 #5
	<var> state 8
	<app> state 12
  state 8: #0 #5
	<var> state 9
  state 9: #0 #5
	<var> state 10
	<var>::matrix state 11
  state 10: #5
  state 11: #0 #5
  state 12: #0 #2 #3 #4 #5
	<var> state 13
	: state 18
	, state 33
	=> state 48
  state 13: #0 #5
	<var> state 14
  state 14: #0 #5
	<var> state 15
  state 15: #0 #5
	<var> state 16
	<var>::matrix state 17
  state 16: #5
  state 17: #0 #5
  state 18: #0 #4 #5
	<var> state 19
  state 19: #0 #4 #5
	<var> state 20
  state 20: #0 #4 #5
	<var> state 21
	<var>::matrix state 22
	<app> state 23
  state 21: #5
  state 22: #0 #5
  state 23: #4 #5
	<var> state 24
	<app> state 26
  state 24: #5
	<var> state 25
  state 25: #5
  state 26: #4 #5
	<var> state 27
	: state 30
  state 27: #5
	<var> state 28
  state 28: #5
	<var> state 29
  state 29: #5
  state 30: #4 #5
	<var> state 31
  state 31: #4 #5
	<var> state 32
  state 32: #4 #5
  state 33: #0 #3 #5
	<var> state 34
  state 34: #0 #3 #5
	<var> state 35
  state 35: #0 #3 #5
	<var> state 36
	<var>::matrix state 37
	<app> state 38
  state 36: #5
  state 37: #0 #5
  state 38: #3 #5
	<var> state 39
	<app> state 41
  state 39: #5
	<var> state 40
  state 40: #5
  state 41: #3 #5
	<var> state 42
	, state 45
  state 42: #5
	<var> state 43
  state 43: #5
	<var> state 44
  state 44: #5
  state 45: #3 #5
	<var> state 46
  state 46: #3 #5
	<var> state 47
  state 47: #3 #5
  state 48: #0 #2 #5
	<var> state 49
  state 49: #0 #2 #5
	<var> state 50
  state 50: #0 #2 #5
	<var> state 51
	<var>::matrix state 52
	<app> state 53
  state 51: #5
  state 52: #0 #5
  state 53: #2 #5
	<var> state 54
	<app> state 56
  state 54: #5
	<var> state 55
  state 55: #5
  state 56: #2 #5
	<var> state 57
	=> state 60
  state 57: #5
	<var> state 58
  state 58: #5
	<var> state 59
  state 59: #5
  state 60: #2 #5
	<var> state 61
  state 61: #2 #5
	<var> state 62
  state 62: #2 #5
}
{
  rule #0: x!!ns::matrix = x!!list ns
  rule #1: x!!(ns::matrix,ms) = x!!(list ns,ms) if ~tuplep ms
  rule #2: x!!(ns,ms::matrix) = x!!(ns,list ms)
  rule #3: x!!(ns::int,ms) = x!!([ns],ms) if ~tuplep ms
  rule #4: x!!(ns,ms::int) = x!!(ns,[ms])
  rule #5: x::matrix!!(ns,ms) = case ns,ms of ns@(n:_),ms@(m:_) = submat x (n,m) (#ns,#ms) if cont ns&&cont ms; _ = colcatmap (mth (rowcatmap (nth x) ns)) ms end with cont [n::int] = 1; cont (n::int:ns@(m::int:_)) = cont ns if m==n+1; cont _ = 0; mth x m = catch (cst {}) (col x m); nth x n = catch (cst {}) (row x n) end
  rule #6: x::matrix!!ns = if all intp ns&&packed x then rowvector x!!([0],ns) else colcatmap (nth x) ns with nth x n = catch (cst {}) {x!n} end
  rule #7: s::string!!ns = case ns of ns@(n:_) = substr s n (count ns) if cont ns; _ = string (chars s!!ns) end with cont [n::int] = 1; cont (n::int:ns@(m::int:_)) = cont ns if m==n+1; cont _ = 0; count ns = #dropwhile (\n::int -> n<0) ns end
  rule #8: xs@()!!ns = tuple (list xs!!ns)
  rule #9: xs@(_,_)!!ns = tuple (list xs!!ns)
  rule #10: xs!!ns = ys if ok ys when ys = case ns of ns@(n::int:_) = list (take (count ns) (drop n xs)) if listp xs&&cont ns; _ = catmap (nth xs) ns end end with ok (catmap (nth _) _) = 0; ok _ = 1; cont (n::int:ns) = ~thunkp ns&&(case ns of [] = 1; m::int:_ = cont ns if m==n+1; _ = 0 end); nth xs n = catch (cst []) [xs!n]; count ns = #dropwhile (\n::int -> n<0) ns end
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10
	<var> state 1
	<var>::string state 24
	<var>::matrix state 47
	<app> state 70
	() state 146
  state 1: #0 #1 #2 #3 #4 #10
	<var> state 2
	<var>::matrix state 3
	<app> state 4
  state 2: #10
  state 3: #0 #10
  state 4: #1 #2 #3 #4 #10
	<var> state 5
	<app> state 7
  state 5: #10
	<var> state 6
  state 6: #10
  state 7: #1 #2 #3 #4 #10
	<var> state 8
	, state 11
  state 8: #10
	<var> state 9
  state 9: #10
	<var> state 10
  state 10: #10
  state 11: #1 #2 #3 #4 #10
	<var> state 12
	<var>::int state 16
	<var>::matrix state 20
  state 12: #2 #4 #10
	<var> state 13
	<var>::int state 14
	<var>::matrix state 15
  state 13: #10
  state 14: #4 #10
  state 15: #2 #10
  state 16: #2 #3 #4 #10
	<var> state 17
	<var>::int state 18
	<var>::matrix state 19
  state 17: #3 #10
  state 18: #3 #4 #10
  state 19: #2 #3 #10
  state 20: #1 #2 #4 #10
	<var> state 21
	<var>::int state 22
	<var>::matrix state 23
  state 21: #1 #10
  state 22: #1 #4 #10
  state 23: #1 #2 #10
  state 24: #0 #1 #2 #3 #4 #7 #10
	<var> state 25
	<var>::matrix state 26
	<app> state 27
  state 25: #7 #10
  state 26: #0 #7 #10
  state 27: #1 #2 #3 #4 #7 #10
	<var> state 28
	<app> state 30
  state 28: #7 #10
	<var> state 29
  state 29: #7 #10
  state 30: #1 #2 #3 #4 #7 #10
	<var> state 31
	, state 34
  state 31: #7 #10
	<var> state 32
  state 32: #7 #10
	<var> state 33
  state 33: #7 #10
  state 34: #1 #2 #3 #4 #7 #10
	<var> state 35
	<var>::int state 39
	<var>::matrix state 43
  state 35: #2 #4 #7 #10
	<var> state 36
	<var>::int state 37
	<var>::matrix state 38
  state 36: #7 #10
  state 37: #4 #7 #10
  state 38: #2 #7 #10
  state 39: #2 #3 #4 #7 #10
	<var> state 40
	<var>::int state 41
	<var>::matrix state 42
  state 40: #3 #7 #10
  state 41: #3 #4 #7 #10
  state 42: #2 #3 #7 #10
  state 43: #1 #2 #4 #7 #10
	<var> state 44
	<var>::int state 45
	<var>::matrix state 46
  state 44: #1 #7 #10
  state 45: #1 #4 #7 #10
  state 46: #1 #2 #7 #10
  state 47: #0 #1 #2 #3 #4 #5 #6 #10
	<var> state 48
	<var>::matrix state 49
	<app> state 50
  state 48: #6 #10
  state 49: #0 #6 #10
  state 50: #1 #2 #3 #4 #5 #6 #10
	<var> state 51
	<app> state 53
  state 51: #6 #10
	<var> state 52
  state 52: #6 #10
  state 53: #1 #2 #3 #4 #5 #6 #10
	<var> state 54
	, state 57
  state 54: #6 #10
	<var> state 55
  state 55: #6 #10
	<var> state 56
  state 56: #6 #10
  state 57: #1 #2 #3 #4 #5 #6 #10
	<var> state 58
	<var>::int state 62
	<var>::matrix state 66
  state 58: #2 #4 #5 #6 #10
	<var> state 59
	<var>::int state 60
	<var>::matrix state 61
  state 59: #5 #6 #10
  state 60: #4 #5 #6 #10
  state 61: #2 #5 #6 #10
  state 62: #2 #3 #4 #5 #6 #10
	<var> state 63
	<var>::int state 64
	<var>::matrix state 65
  state 63: #3 #5 #6 #10
  state 64: #3 #4 #5 #6 #10
  state 65: #2 #3 #5 #6 #10
  state 66: #1 #2 #4 #5 #6 #10
	<var> state 67
	<var>::int state 68
	<var>::matrix state 69
  state 67: #1 #5 #6 #10
  state 68: #1 #4 #5 #6 #10
  state 69: #1 #2 #5 #6 #10
  state 70: #0 #1 #2 #3 #4 #9 #10
	<var> state 71
	<app> state 95
  state 71: #0 #1 #2 #3 #4 #10
	<var> state 72
  state 72: #0 #1 #2 #3 #4 #10
	<var> state 73
	<var>::matrix state 74
	<app> state 75
  state 73: #10
  state 74: #0 #10
  state 75: #1 #2 #3 #4 #10
	<var> state 76
	<app> state 78
  state 76: #10
	<var> state 77
  state 77: #10
  state 78: #1 #2 #3 #4 #10
	<var> state 79
	, state 82
  state 79: #10
	<var> state 80
  state 80: #10
	<var> state 81
  state 81: #10
  state 82: #1 #2 #3 #4 #10
	<var> state 83
	<var>::int state 87
	<var>::matrix state 91
  state 83: #2 #4 #10
	<var> state 84
	<var>::int state 85
	<var>::matrix state 86
  state 84: #10
  state 85: #4 #10
  state 86: #2 #10
  state 87: #2 #3 #4 #10
	<var> state 88
	<var>::int state 89
	<var>::matrix state 90
  state 88: #3 #10
  state 89: #3 #4 #10
  state 90: #2 #3 #10
  state 91: #1 #2 #4 #10
	<var> state 92
	<var>::int state 93
	<var>::matrix state 94
  state 92: #1 #10
  state 93: #1 #4 #10
  state 94: #1 #2 #10
  state 95: #0 #1 #2 #3 #4 #9 #10
	<var> state 96
	, state 121
  state 96: #0 #1 #2 #3 #4 #10
	<var> state 97
  state 97: #0 #1 #2 #3 #4 #10
	<var> state 98
  state 98: #0 #1 #2 #3 #4 #10
	<var> state 99
	<var>::matrix state 100
	<app> state 101
  state 99: #10
  state 100: #0 #10
  state 101: #1 #2 #3 #4 #10
	<var> state 102
	<app> state 104
  state 102: #10
	<var> state 103
  state 103: #10
  state 104: #1 #2 #3 #4 #10
	<var> state 105
	, state 108
  state 105: #10
	<var> state 106
  state 106: #10
	<var> state 107
  state 107: #10
  state 108: #1 #2 #3 #4 #10
	<var> state 109
	<var>::int state 113
	<var>::matrix state 117
  state 109: #2 #4 #10
	<var> state 110
	<var>::int state 111
	<var>::matrix state 112
  state 110: #10
  state 111: #4 #10
  state 112: #2 #10
  state 113: #2 #3 #4 #10
	<var> state 114
	<var>::int state 115
	<var>::matrix state 116
  state 114: #3 #10
  state 115: #3 #4 #10
  state 116: #2 #3 #10
  state 117: #1 #2 #4 #10
	<var> state 118
	<var>::int state 119
	<var>::matrix state 120
  state 118: #1 #10
  state 119: #1 #4 #10
  state 120: #1 #2 #10
  state 121: #0 #1 #2 #3 #4 #9 #10
	<var> state 122
  state 122: #0 #1 #2 #3 #4 #9 #10
	<var> state 123
  state 123: #0 #1 #2 #3 #4 #9 #10
	<var> state 124
	<var>::matrix state 125
	<app> state 126
  state 124: #9 #10
  state 125: #0 #9 #10
  state 126: #1 #2 #3 #4 #9 #10
	<var> state 127
	<app> state 129
  state 127: #9 #10
	<var> state 128
  state 128: #9 #10
  state 129: #1 #2 #3 #4 #9 #10
	<var> state 130
	, state 133
  state 130: #9 #10
	<var> state 131
  state 131: #9 #10
	<var> state 132
  state 132: #9 #10
  state 133: #1 #2 #3 #4 #9 #10
	<var> state 134
	<var>::int state 138
	<var>::matrix state 142
  state 134: #2 #4 #9 #10
	<var> state 135
	<var>::int state 136
	<var>::matrix state 137
  state 135: #9 #10
  state 136: #4 #9 #10
  state 137: #2 #9 #10
  state 138: #2 #3 #4 #9 #10
	<var> state 139
	<var>::int state 140
	<var>::matrix state 141
  state 139: #3 #9 #10
  state 140: #3 #4 #9 #10
  state 141: #2 #3 #9 #10
  state 142: #1 #2 #4 #9 #10
	<var> state 143
	<var>::int state 144
	<var>::matrix state 145
  state 143: #1 #9 #10
  state 144: #1 #4 #9 #10
  state 145: #1 #2 #9 #10
  state 146: #0 #1 #2 #3 #4 #8 #10
	<var> state 147
	<var>::matrix state 148
	<app> state 149
  state 147: #8 #10
  state 148: #0 #8 #10
  state 149: #1 #2 #3 #4 #8 #10
	<var> state 150
	<app> state 152
  state 150: #8 #10
	<var> state 151
  state 151: #8 #10
  state 152: #1 #2 #3 #4 #8 #10
	<var> state 153
	, state 156
  state 153: #8 #10
	<var> state 154
  state 154: #8 #10
	<var> state 155
  state 155: #8 #10
  state 156: #1 #2 #3 #4 #8 #10
	<var> state 157
	<var>::int state 161
	<var>::matrix state 165
  state 157: #2 #4 #8 #10
	<var> state 158
	<var>::int state 159
	<var>::matrix state 160
  state 158: #8 #10
  state 159: #4 #8 #10
  state 160: #2 #8 #10
  state 161: #2 #3 #4 #8 #10
	<var> state 162
	<var>::int state 163
	<var>::matrix state 164
  state 162: #3 #8 #10
  state 163: #3 #4 #8 #10
  state 164: #2 #3 #8 #10
  state 165: #1 #2 #4 #8 #10
	<var> state 166
	<var>::int state 167
	<var>::matrix state 168
  state 166: #1 #8 #10
  state 167: #1 #4 #8 #10
  state 168: #1 #2 #8 #10
}
{
  rule #0: list x::matrix = listmap (\i -> x!i) (0..#x-1)
  rule #1: list s::string = chars s
  rule #2: list () = []
  rule #3: list (x,xs) = accum [x] xs with accum ys (x,xs) = accum (x:ys) xs; accum ys x = __std__::reverse_onto [] (x:ys) end
  rule #4: list [] = []
  rule #5: list (x:xs) = accum [x] xs with accum ys (x:xs) = accum (x:ys) xs; accum ys [] = __std__::reverse_onto [] ys; accum ys xs = throw (bad_list_value xs) end
  state 0: #0 #1 #2 #3 #4 #5
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
	[] state 11
	() state 12
  state 1: #1
  state 2: #0
  state 3: #3 #5
	<app> state 4
  state 4: #3 #5
	: state 5
	, state 8
  state 5: #5
	<var> state 6
  state 6: #5
	<var> state 7
  state 7: #5
  state 8: #3
	<var> state 9
  state 9: #3
	<var> state 10
  state 10: #3
  state 11: #4
  state 12: #2
}
{
  rule #0: tuple x::matrix = tuple (list x)
  rule #1: tuple s::string = tuple (chars s)
  rule #2: tuple [] = ()
  rule #3: tuple (x:xs) = accum (t x) xs with t x@(_,_) = reverse x; t x = x; accum ys (x:xs) = accum (t x,ys) xs; accum ys [] = t ys; accum ys xs = throw (bad_list_value xs) end
  rule #4: tuple x@() = x
  rule #5: tuple x@(_,_) = x
  state 0: #0 #1 #2 #3 #4 #5
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
	[] state 11
	() state 12
  state 1: #1
  state 2: #0
  state 3: #3 #5
	<app> state 4
  state 4: #3 #5
	: state 5
	, state 8
  state 5: #3
	<var> state 6
  state 6: #3
	<var> state 7
  state 7: #3
  state 8: #5
	<var> state 9
  state 9: #5
	<var> state 10
  state 10: #5
  state 11: #2
  state 12: #4
}
{
  rule #0: subseq x::matrix a::int b::int = __C::matrix_slice (rowvector x) 0 a 0 b
  rule #1: subseq s::string a::int b::int = substr s a (b-a+1)
  rule #2: subseq [] a::int b::int = []
  rule #3: subseq xs@(_:_) a::int b::int = take (b-a+1) (drop a xs) with take 0 xs = []; take m::int xs = take_pre len_pre xs with take_pre 0 _ = front_tail; take_pre n::int (x:xs) = x:take_pre (n-1) xs end when len_pre@_ front_tail = skip_ahead m 0 xs end; skip_ahead m::int n::int xs = n [] if m<=0||xs===[]; skip_ahead m::int n::int (x:xs) = skip_ahead (m-1) (n+1) xs if n<4096; skip_ahead m::int n::int xs = n (take m xs) end
  rule #4: subseq x a b = slice x (a..b)
  state 0: #0 #1 #2 #3 #4
	<var> state 1
	<var>::string state 4
	<var>::matrix state 10
	<app> state 16
	[] state 35
  state 1: #4
	<var> state 2
  state 2: #4
	<var> state 3
  state 3: #4
  state 4: #1 #4
	<var> state 5
	<var>::int state 7
  state 5: #4
	<var> state 6
  state 6: #4
  state 7: #1 #4
	<var> state 8
	<var>::int state 9
  state 8: #4
  state 9: #1 #4
  state 10: #0 #4
	<var> state 11
	<var>::int state 13
  state 11: #4
	<var> state 12
  state 12: #4
  state 13: #0 #4
	<var> state 14
	<var>::int state 15
  state 14: #4
  state 15: #0 #4
  state 16: #3 #4
	<var> state 17
	<app> state 21
  state 17: #4
	<var> state 18
  state 18: #4
	<var> state 19
  state 19: #4
	<var> state 20
  state 20: #4
  state 21: #3 #4
	<var> state 22
	: state 27
  state 22: #4
	<var> state 23
  state 23: #4
	<var> state 24
  state 24: #4
	<var> state 25
  state 25: #4
	<var> state 26
  state 26: #4
  state 27: #3 #4
	<var> state 28
  state 28: #3 #4
	<var> state 29
  state 29: #3 #4
	<var> state 30
	<var>::int state 32
  state 30: #4
	<var> state 31
  state 31: #4
  state 32: #3 #4
	<var> state 33
	<var>::int state 34
  state 33: #4
  state 34: #3 #4
  state 35: #2 #4
	<var> state 36
	<var>::int state 38
  state 36: #4
	<var> state 37
  state 37: #4
  state 38: #2 #4
	<var> state 39
	<var>::int state 40
  state 39: #4
  state 40: #2 #4
}
{
  rule #0: stream s::string = stream (chars s)
  rule #1: stream [] = []
  rule #2: stream (x:xs) = x:xs if thunkp xs
  rule #3: stream (x:xs) = x:stream xs&
  rule #4: stream () = []
  rule #5: stream xs@(_,_) = stream (list xs)
  state 0: #0 #1 #2 #3 #4 #5
	<var>::string state 1
	<app> state 2
	[] state 10
	() state 11
  state 1: #0
  state 2: #2 #3 #5
	<app> state 3
  state 3: #2 #3 #5
	: state 4
	, state 7
  state 4: #2 #3
	<var> state 5
  state 5: #2 #3
	<var> state 6
  state 6: #2 #3
  state 7: #5
	<var> state 8
  state 8: #5
	<var> state 9
  state 9: #5
  state 10: #1
  state 11: #4
}
{
  rule #0: catstream [] = []
  rule #1: catstream ((x:xs):yss) = x:catstream (xs:yss)&
  rule #2: catstream ([]:yss) = catstream yss
  rule #3: catstream (xs::string:yss) = catstream (chars xs:yss)
  rule #4: catstream (xs:yss) = xs+catstream yss
  state 0: #0 #1 #2 #3 #4
	<app> state 1
	[] state 23
  state 1: #1 #2 #3 #4
	<app> state 2
  state 2: #1 #2 #3 #4
	: state 3
  state 3: #1 #2 #3 #4
	<var> state 4
	<var>::string state 6
	<app> state 8
	[] state 21
  state 4: #4
	<var> state 5
  state 5: #4
  state 6: #3 #4
	<var> state 7
  state 7: #3 #4
  state 8: #1 #4
	<var> state 9
	<app> state 12
  state 9: #4
	<var> state 10
  state 10: #4
	<var> state 11
  state 11: #4
  state 12: #1 #4
	<var> state 13
	: state 17
  state 13: #4
	<var> state 14
  state 14: #4
	<var> state 15
  state 15: #4
	<var> state 16
  state 16: #4
  state 17: #1 #4
	<var> state 18
  state 18: #1 #4
	<var> state 19
  state 19: #1 #4
	<var> state 20
  state 20: #1 #4
  state 21: #2 #4
	<var> state 22
  state 22: #2 #4
  state 23: #0
}
const __std__::__voidfun__ = void;
def __std__::__voidchk__ x/*0:1*/ = __std__::__voidchk2__ x/*0:1*/;
def __std__::__voidchk2__ x/*0:01*/ y/*0:1*/ = __std__::__voidfun__ y/*0:1*/;
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(listmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(rowmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(colmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(catmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(rowcatmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(colcatmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ z/*0:1101*/ [])) = __std__::__do__$__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ (void z/*0:1101*/) ());
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ z/*0:1101*/ {})) = __std__::__do__$__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ (void z/*0:1101*/) ());
def __std__::__do__ (__lambda__ [x/*0:10101*/] (void y/*0:111*/)) = __std__::__do__ (__lambda__ [x/*0:10101*/] y/*0:111*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__std__::__voidfun__ y/*0:111*/)) = __std__::__do__ (__lambda__ [x/*0:10101*/] y/*0:111*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ (void z/*0:11011*/) ())) = __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ z/*0:11011*/ ()));
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ (__std__::__voidfun__ z/*0:11011*/) ())) = __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ z/*0:11011*/ ()));
def __std__::__do__ f/*0:1*/ = do f/*0:1*/;
__C::pure_quoted_symbol s/*0:1*/ :: string = __C::pure_quoted_symbol id/*0:*/ if id/*0:*/>0 when id/*0:*/ :: int = __C::pure_getsym s/*0:1*/ {
  rule #0: id::int = __C::pure_getsym s
  state 0: #0
	<var>::int state 1
  state 1: #0
} end;
globsym pat/*0:01*/ :: string level/*0:1*/ :: int = uniq/*2*/ (catmap descr/*2*/ info/*0:*/) when res/*0:*/ = evalcmd ("show -gst"+str level/*0:1*/+" "+pat/*0:01*/); stringp res/*0:*/||throw evalcmd; info/*0:*/ = init (init (split "\n" res/*0:*/)) {
  rule #0: info = init (init (split "\n" res))
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: _ = stringp res||throw evalcmd
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: res = evalcmd ("show -gst"+str level+" "+pat)
  state 0: #0
	<var> state 1
  state 1: #0
} end with uniq (x/*0:101*/:xs@(y/*0:1101*/:_/*0:111*/)) = if x/*0:101*/===y/*0:1101*/ then uniq/*1*/ xs/*0:11*/ else x/*0:101*/:uniq/*1*/ xs/*0:11*/; uniq xs/*0:1*/ = xs/*0:1*/ {
  rule #0: uniq (x:xs@(y:_)) = if x===y then uniq xs else x:uniq xs
  rule #1: uniq xs = xs
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	: state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
	<app> state 12
  state 11: #1
  state 12: #0 #1
	<var> state 13
	<app> state 15
  state 13: #1
	<var> state 14
  state 14: #1
  state 15: #0 #1
	<var> state 16
	: state 19
  state 16: #1
	<var> state 17
  state 17: #1
	<var> state 18
  state 18: #1
  state 19: #0 #1
	<var> state 20
  state 20: #0 #1
	<var> state 21
  state 21: #0 #1
}; descr s/*0:1*/ :: string = case filter (flip (~=) "") (split " " s/*0:1*/) of sym/*0:01*/:_/*0:1*/ = if any (flip (==) sym/*0:01*/) ["extern","private","infix","infixl","infixr","prefix","postfix","outfix","nonfix"] then [] else catmap (\x/*0:1*/ -> if symbolp x/*0:1*/ then [x/*0:1*/] else [] {
  rule #0: _ x = if symbolp x then [x] else []
  state 0: #0
	<var> state 1
  state 1: #0
}) [__C::pure_quoted_symbol sym/*0:01*/]; _/*0:*/ = [] {
  rule #0: sym:_ = if any (flip (==) sym) ["extern","private","infix","infixl","infixr","prefix","postfix","outfix","nonfix"] then [] else catmap (\x -> if symbolp x then [x] else []) [__C::pure_quoted_symbol sym]
  rule #1: _ = []
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	: state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
} end {
  rule #0: descr s::string = case filter (flip (~=) "") (split " " s) of sym:_ = if any (flip (==) sym) ["extern","private","infix","infixl","infixr","prefix","postfix","outfix","nonfix"] then [] else catmap (\x -> if symbolp x then [x] else []) [__C::pure_quoted_symbol sym]; _ = [] end
  state 0: #0
	<var>::string state 1
  state 1: #0
} end;
clearsym sym/*0:01*/ :: string level/*0:1*/ :: int = () when res/*0:*/ = evalcmd ("clear -t"+str level/*0:1*/+" "+sym/*0:01*/); stringp res/*0:*/||throw evalcmd {
  rule #0: _ = stringp res||throw evalcmd
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: res = evalcmd ("clear -t"+str level+" "+sym)
  state 0: #0
	<var> state 1
  state 1: #0
} end;
clearsym sym/*0:01*/ :: symbol level/*0:1*/ :: int = clearsym sym/*0:*/ level/*2:1*/ when sym/*0:*/ = str sym/*0:01*/; sym/*0:*/ = if sym/*0:*/!0=="(" then substr sym/*0:*/ 2 (#sym/*0:*/-2) else sym/*0:*/ {
  rule #0: sym = if sym!0=="(" then substr sym 2 (#sym-2) else sym
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: sym = str sym
  state 0: #0
	<var> state 1
  state 1: #0
} end;
