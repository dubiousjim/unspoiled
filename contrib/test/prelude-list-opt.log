const false,true = 0,1;
slice x/*0:01*/ y/*0:1*/ = x/*0:01*/!!y/*0:1*/;
def reduce = reduce_with __locals__;
blobp _/*0:1*/ = 0;
#p/*0:1*/ :: pointer = blob_size p/*0:1*/ if blobp p/*0:1*/;
x/*0:01*/===y/*0:1*/ = same x/*0:01*/ y/*0:1*/;
x/*0:01*/~==y/*0:1*/ = ~same x/*0:01*/ y/*0:1*/;
intp x/*0:1*/ = case x/*0:1*/ of _/*0:*/ :: int = 1; _/*0:*/ = 0 {
  rule #0: _::int = 1
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::int state 2
  state 1: #1
  state 2: #0 #1
} end;
bigintp x/*0:1*/ = case x/*0:1*/ of _/*0:*/ :: bigint = 1; _/*0:*/ = 0 {
  rule #0: _::bigint = 1
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::bigint state 2
  state 1: #1
  state 2: #0 #1
} end;
doublep x/*0:1*/ = case x/*0:1*/ of _/*0:*/ :: double = 1; _/*0:*/ = 0 {
  rule #0: _::double = 1
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::double state 2
  state 1: #1
  state 2: #0 #1
} end;
stringp x/*0:1*/ = case x/*0:1*/ of _/*0:*/ :: string = 1; _/*0:*/ = 0 {
  rule #0: _::string = 1
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::string state 2
  state 1: #1
  state 2: #0 #1
} end;
pointerp x/*0:1*/ = case x/*0:1*/ of _/*0:*/ :: pointer = 1; _/*0:*/ = 0 {
  rule #0: _::pointer = 1
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::pointer state 2
  state 1: #1
  state 2: #0 #1
} end;
matrixp x/*0:1*/ = case x/*0:1*/ of _/*0:*/ :: matrix = 1; _/*0:*/ = 0 {
  rule #0: _::matrix = 1
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::matrix state 2
  state 1: #1
  state 2: #0 #1
} end;
type char x/*0:1*/ :: string = intp (ord x/*0:1*/);
charp x/*0:1*/ = typep ('char) x/*0:1*/;
type integer _/*0:1*/ :: int;
type integer _/*0:1*/ :: bigint;
type rational (x/*0:101*/ :: integer%y/*0:11*/ :: integer);
type real x/*0:1*/ :: integer;
type real x/*0:1*/ :: double;
type real (x/*0:101*/ :: real%y/*0:11*/ :: real);
type complex (x/*0:101*/ :: real+:y/*0:11*/ :: real);
type complex (x/*0:101*/ :: real<:y/*0:11*/ :: real);
type number x/*0:1*/ :: real;
type number x/*0:1*/ :: complex;
integerp x/*0:1*/ = typep ('integer) x/*0:1*/;
rationalp x/*0:1*/ = typep ('rational) x/*0:1*/;
realp x/*0:1*/ = typep ('real) x/*0:1*/;
complexp x/*0:1*/ = typep ('complex) x/*0:1*/;
numberp x/*0:1*/ = typep ('number) x/*0:1*/;
exactp x/*0:1*/ = case x/*0:1*/ of x/*0:01*/+:y/*0:1*/ = ~doublep x/*0:01*/&&~doublep y/*0:1*/; x/*0:01*/<:y/*0:1*/ = ~doublep x/*0:01*/&&~doublep y/*0:1*/; x/*0:01*/%y/*0:1*/ = ~doublep x/*0:01*/&&~doublep y/*0:1*/; _/*0:*/ = ~doublep x/*1:1*/ {
  rule #0: x+:y = ~doublep x&&~doublep y
  rule #1: x<:y = ~doublep x&&~doublep y
  rule #2: x%y = ~doublep x&&~doublep y
  rule #3: _ = ~doublep x
  state 0: #0 #1 #2 #3
	<var> state 1
	<app> state 2
  state 1: #3
  state 2: #0 #1 #2 #3
	<var> state 3
	<app> state 5
  state 3: #3
	<var> state 4
  state 4: #3
  state 5: #0 #1 #2 #3
	<var> state 6
	+: state 9
	<: state 12
	% state 15
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #0 #3
	<var> state 10
  state 10: #0 #3
	<var> state 11
  state 11: #0 #3
  state 12: #1 #3
	<var> state 13
  state 13: #1 #3
	<var> state 14
  state 14: #1 #3
  state 15: #2 #3
	<var> state 16
  state 16: #2 #3
	<var> state 17
  state 17: #2 #3
} end if numberp x/*0:1*/;
inexactp x/*0:1*/ = case x/*0:1*/ of x/*0:01*/+:y/*0:1*/ = doublep x/*0:01*/||doublep y/*0:1*/; x/*0:01*/<:y/*0:1*/ = doublep x/*0:01*/||doublep y/*0:1*/; x/*0:01*/%y/*0:1*/ = doublep x/*0:01*/||doublep y/*0:1*/; _/*0:*/ = doublep x/*1:1*/ {
  rule #0: x+:y = doublep x||doublep y
  rule #1: x<:y = doublep x||doublep y
  rule #2: x%y = doublep x||doublep y
  rule #3: _ = doublep x
  state 0: #0 #1 #2 #3
	<var> state 1
	<app> state 2
  state 1: #3
  state 2: #0 #1 #2 #3
	<var> state 3
	<app> state 5
  state 3: #3
	<var> state 4
  state 4: #3
  state 5: #0 #1 #2 #3
	<var> state 6
	+: state 9
	<: state 12
	% state 15
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #0 #3
	<var> state 10
  state 10: #0 #3
	<var> state 11
  state 11: #0 #3
  state 12: #1 #3
	<var> state 13
  state 13: #1 #3
	<var> state 14
  state 14: #1 #3
  state 15: #2 #3
	<var> state 16
  state 16: #2 #3
	<var> state 17
  state 17: #2 #3
} end if numberp x/*0:1*/;
closurep x/*0:1*/ = funp x/*0:1*/||lambdap x/*0:1*/;
type fun = funp;
type lambda = lambdap;
type thunk = thunkp;
type closure = closurep;
type symbol = symbolp;
type var = varp;
functionp x/*0:1*/ = nargs/*0*/ x/*0:1*/>0 with nargs (x@_/*0:10*/ _/*0:11*/) = nargs/*1*/ x/*0:10*/-1; nargs x/*0:1*/ = ::nargs x/*0:1*/ {
  rule #0: nargs (x@_ _) = nargs x-1
  rule #1: nargs x = ::nargs x
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
  state 3: #0 #1
	<var> state 4
  state 4: #0 #1
} end;
type function = functionp;
type appl (_/*0:10*/ _/*0:11*/);
type list [];
type list (_/*0:101*/:_/*0:11*/);
type tuple ();
type tuple (_/*0:101*/,_/*0:11*/);
applp x/*0:1*/ = typep ('appl) x/*0:1*/;
listp x/*0:1*/ = typep ('list) x/*0:1*/;
tuplep x/*0:1*/ = typep ('tuple) x/*0:1*/;
type rlist [];
type rlist (_/*0:101*/:_/*0:11*/ :: rlist);
rlistp x/*0:1*/ = typep ('rlist) x/*0:1*/;
int x/*0:1*/ :: int = x/*0:1*/;
int x/*0:1*/ :: bigint = __C::pure_intval x/*0:1*/;
int x/*0:1*/ :: double = __C::pure_intval x/*0:1*/;
bigint x/*0:1*/ :: bigint = x/*0:1*/;
bigint x/*0:1*/ :: int = __C::pure_bigintval x/*0:1*/;
bigint x/*0:1*/ :: double = __C::pure_bigintval x/*0:1*/;
double x/*0:1*/ :: double = x/*0:1*/;
double x/*0:1*/ :: int = __C::pure_dblval x/*0:1*/;
double x/*0:1*/ :: bigint = __C::pure_dblval x/*0:1*/;
pointer x/*0:1*/ :: pointer = x/*0:1*/;
pointer x/*0:1*/ :: int = __C::pure_pointerval x/*0:1*/;
pointer x/*0:1*/ :: bigint = __C::pure_pointerval x/*0:1*/;
pointer x/*0:1*/ :: string = __C::pure_pointerval x/*0:1*/;
type char {
  rule #0: char x::string = intp (ord x)
  state 0: #0
	<var>::string state 1
  state 1: #0
}
type integer {
  rule #0: integer _::int = 1
  rule #1: integer _::bigint = 1
  state 0: #0 #1
	<var>::int state 1
	<var>::bigint state 2
  state 1: #0
  state 2: #1
}
type rational {
  rule #0: rational (x::integer%y::integer) = 1
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	% state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}
type real {
  rule #0: real x::integer = 1
  rule #1: real x::double = 1
  rule #2: real (x::real%y::real) = 1
  state 0: #0 #1 #2
	<var> state 1
	<var>::double state 2
	<app> state 3
  state 1: #0
  state 2: #0 #1
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #0
	<var> state 5
  state 5: #0
  state 6: #0 #2
	<var> state 7
	% state 10
  state 7: #0
	<var> state 8
  state 8: #0
	<var> state 9
  state 9: #0
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
}
type complex {
  rule #0: complex (x::real+:y::real) = 1
  rule #1: complex (x::real<:y::real) = 1
  state 0: #0 #1
	<app> state 1
  state 1: #0 #1
	<app> state 2
  state 2: #0 #1
	+: state 3
	<: state 6
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
}
type number {
  rule #0: number x::real = 1
  rule #1: number x::complex = 1
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
}
type fun {
  rule #0: fun = funp
  state 0: #0
}
type lambda {
  rule #0: lambda = lambdap
  state 0: #0
}
type thunk {
  rule #0: thunk = thunkp
  state 0: #0
}
type closure {
  rule #0: closure = closurep
  state 0: #0
}
type symbol {
  rule #0: symbol = symbolp
  state 0: #0
}
type var {
  rule #0: var = varp
  state 0: #0
}
type function {
  rule #0: function = functionp
  state 0: #0
}
type appl {
  rule #0: appl (_ _) = 1
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}
type list {
  rule #0: list [] = 1
  rule #1: list (_:_) = 1
  state 0: #0 #1
	<app> state 1
	[] state 6
  state 1: #1
	<app> state 2
  state 2: #1
	: state 3
  state 3: #1
	<var> state 4
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0
}
type tuple {
  rule #0: tuple () = 1
  rule #1: tuple (_,_) = 1
  state 0: #0 #1
	<app> state 1
	() state 6
  state 1: #1
	<app> state 2
  state 2: #1
	, state 3
  state 3: #1
	<var> state 4
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0
}
type rlist {
  rule #0: rlist [] = 1
  rule #1: rlist (_:_::rlist) = 1
  state 0: #0 #1
	<app> state 1
	[] state 6
  state 1: #1
	<app> state 2
  state 2: #1
	: state 3
  state 3: #1
	<var> state 4
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0
}
{
  rule #0: int x::int = x
  rule #1: int x::bigint = __C::pure_intval x
  rule #2: int x::double = __C::pure_intval x
  state 0: #0 #1 #2
	<var>::int state 1
	<var>::bigint state 2
	<var>::double state 3
  state 1: #0
  state 2: #1
  state 3: #2
}
{
  rule #0: bigint x::bigint = x
  rule #1: bigint x::int = __C::pure_bigintval x
  rule #2: bigint x::double = __C::pure_bigintval x
  state 0: #0 #1 #2
	<var>::int state 1
	<var>::bigint state 2
	<var>::double state 3
  state 1: #1
  state 2: #0
  state 3: #2
}
{
  rule #0: double x::double = x
  rule #1: double x::int = __C::pure_dblval x
  rule #2: double x::bigint = __C::pure_dblval x
  state 0: #0 #1 #2
	<var>::int state 1
	<var>::bigint state 2
	<var>::double state 3
  state 1: #1
  state 2: #2
  state 3: #0
}
{
  rule #0: pointer x::pointer = x
  rule #1: pointer x::int = __C::pure_pointerval x
  rule #2: pointer x::bigint = __C::pure_pointerval x
  rule #3: pointer x::string = __C::pure_pointerval x
  state 0: #0 #1 #2 #3
	<var>::int state 1
	<var>::bigint state 2
	<var>::string state 3
	<var>::pointer state 4
  state 1: #1
  state 2: #2
  state 3: #3
  state 4: #0
}
{
  rule #0: x===y = same x y
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: x~==y = ~same x y
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: #p::pointer = blob_size p if blobp p
  state 0: #0
	<var>::pointer state 1
  state 1: #0
}
{
  rule #0: slice x y = x!!y
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: blobp _ = 0
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: intp x = case x of _::int = 1; _ = 0 end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: bigintp x = case x of _::bigint = 1; _ = 0 end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: doublep x = case x of _::double = 1; _ = 0 end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: stringp x = case x of _::string = 1; _ = 0 end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: pointerp x = case x of _::pointer = 1; _ = 0 end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: matrixp x = case x of _::matrix = 1; _ = 0 end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: charp x = typep ('char) x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: integerp x = typep ('integer) x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: rationalp x = typep ('rational) x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: realp x = typep ('real) x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: complexp x = typep ('complex) x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: numberp x = typep ('number) x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: exactp x = case x of x+:y = ~doublep x&&~doublep y; x<:y = ~doublep x&&~doublep y; x%y = ~doublep x&&~doublep y; _ = ~doublep x end if numberp x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: inexactp x = case x of x+:y = doublep x||doublep y; x<:y = doublep x||doublep y; x%y = doublep x||doublep y; _ = doublep x end if numberp x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: closurep x = funp x||lambdap x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: functionp x = nargs x>0 with nargs (x@_ _) = nargs x-1; nargs x = ::nargs x end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: applp x = typep ('appl) x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: listp x = typep ('list) x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: tuplep x = typep ('tuple) x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: rlistp x = typep ('rlist) x
  state 0: #0
	<var> state 1
  state 1: #0
}
const NULL = pointer 0;
null x/*0:1*/ :: pointer = x/*0:1*/===#<pointer 0> if __C::pure_pointer_equal (get_ptrtag x/*0:1*/)===#<pointer 0>;
ubyte x/*0:1*/ :: int = if x/*0:1*/>=0 then x/*0:1*/ else x/*0:1*/+256;
ushort x/*0:1*/ :: int = if x/*0:1*/>=0 then x/*0:1*/ else x/*0:1*/+65536;
uint x/*0:1*/ :: int = if x/*0:1*/>=0 then bigint x/*0:1*/ else x/*0:1*/+4294967296L;
uint64 x/*0:1*/ :: int = if x/*0:1*/>=0 then bigint x/*0:1*/ else x/*0:1*/+18446744073709551616L;
uint64 x/*0:1*/ :: bigint = if x/*0:1*/>=0 then bigint x/*0:1*/ else x/*0:1*/+18446744073709551616L;
ulong = uint64;
floor x/*0:1*/ :: int = x/*0:1*/;
floor x/*0:1*/ :: bigint = x/*0:1*/;
ceil x/*0:1*/ :: int = x/*0:1*/;
ceil x/*0:1*/ :: bigint = x/*0:1*/;
round x/*0:1*/ :: int = x/*0:1*/;
round x/*0:1*/ :: bigint = x/*0:1*/;
trunc x/*0:1*/ :: int = x/*0:1*/;
trunc x/*0:1*/ :: bigint = x/*0:1*/;
frac x/*0:1*/ :: int = x/*0:1*/-trunc x/*0:1*/;
frac x/*0:1*/ :: bigint = x/*0:1*/-trunc x/*0:1*/;
frac x/*0:1*/ :: double = x/*0:1*/-trunc x/*0:1*/;
abs x/*0:1*/ :: int = if x/*0:1*/>0 then x/*0:1*/ else -x/*0:1*/;
abs x/*0:1*/ :: bigint = if x/*0:1*/>0 then x/*0:1*/ else -x/*0:1*/;
abs x/*0:1*/ :: double = if x/*0:1*/>0 then x/*0:1*/ else -x/*0:1*/;
sgn x/*0:1*/ :: int = if x/*0:1*/>0 then 1 else if x/*0:1*/<0 then -1 else 0;
sgn x/*0:1*/ :: bigint = if x/*0:1*/>0 then 1 else if x/*0:1*/<0 then -1 else 0;
sgn x/*0:1*/ :: double = if x/*0:1*/>0 then 1 else if x/*0:1*/<0 then -1 else 0;
min x/*0:01*/ y/*0:1*/ = if x/*0:01*/<=y/*0:1*/ then x/*0:01*/ else y/*0:1*/;
max x/*0:01*/ y/*0:1*/ = if x/*0:01*/>=y/*0:1*/ then x/*0:01*/ else y/*0:1*/;
succ x/*0:1*/ = x/*0:1*/+1;
pred x/*0:1*/ = x/*0:1*/-1;
-x/*0:1*/ :: int = -x/*0:1*/;
~x/*0:1*/ :: int = ~x/*0:1*/;
not x/*0:1*/ :: int = not x/*0:1*/;
x/*0:01*/ :: int<<y/*0:1*/ :: int = x/*0:01*/<<y/*0:1*/;
x/*0:01*/ :: int>>y/*0:1*/ :: int = x/*0:01*/>>y/*0:1*/;
x/*0:01*/ :: int+y/*0:1*/ :: int = x/*0:01*/+y/*0:1*/;
x/*0:01*/ :: int-y/*0:1*/ :: int = x/*0:01*/-y/*0:1*/;
x/*0:01*/ :: int*y/*0:1*/ :: int = x/*0:01*/*y/*0:1*/;
x/*0:01*/ :: int/y/*0:1*/ :: int = x/*0:01*//y/*0:1*/;
x/*0:01*/ :: int div y/*0:1*/ :: int = x/*0:01*/ div y/*0:1*/;
x/*0:01*/ :: int mod y/*0:1*/ :: int = x/*0:01*/ mod y/*0:1*/;
x/*0:01*/ :: int or y/*0:1*/ :: int = x/*0:01*/ or y/*0:1*/;
x/*0:01*/ :: int and y/*0:1*/ :: int = x/*0:01*/ and y/*0:1*/;
x/*0:01*/ :: int<y/*0:1*/ :: int = x/*0:01*/<y/*0:1*/;
x/*0:01*/ :: int>y/*0:1*/ :: int = x/*0:01*/>y/*0:1*/;
x/*0:01*/ :: int<=y/*0:1*/ :: int = x/*0:01*/<=y/*0:1*/;
x/*0:01*/ :: int>=y/*0:1*/ :: int = x/*0:01*/>=y/*0:1*/;
x/*0:01*/ :: int==y/*0:1*/ :: int = x/*0:01*/==y/*0:1*/;
x/*0:01*/ :: int~=y/*0:1*/ :: int = x/*0:01*/~=y/*0:1*/;
-x/*0:1*/ :: double = -x/*0:1*/;
x/*0:01*/ :: double+y/*0:1*/ :: double = x/*0:01*/+y/*0:1*/;
x/*0:01*/ :: double-y/*0:1*/ :: double = x/*0:01*/-y/*0:1*/;
x/*0:01*/ :: double*y/*0:1*/ :: double = x/*0:01*/*y/*0:1*/;
x/*0:01*/ :: double/y/*0:1*/ :: double = x/*0:01*//y/*0:1*/;
x/*0:01*/ :: double<y/*0:1*/ :: double = x/*0:01*/<y/*0:1*/;
x/*0:01*/ :: double>y/*0:1*/ :: double = x/*0:01*/>y/*0:1*/;
x/*0:01*/ :: double<=y/*0:1*/ :: double = x/*0:01*/<=y/*0:1*/;
x/*0:01*/ :: double>=y/*0:1*/ :: double = x/*0:01*/>=y/*0:1*/;
x/*0:01*/ :: double==y/*0:1*/ :: double = x/*0:01*/==y/*0:1*/;
x/*0:01*/ :: double~=y/*0:1*/ :: double = x/*0:01*/~=y/*0:1*/;
x/*0:01*/ :: int+y/*0:1*/ :: double = x/*0:01*/+y/*0:1*/;
x/*0:01*/ :: int-y/*0:1*/ :: double = x/*0:01*/-y/*0:1*/;
x/*0:01*/ :: int*y/*0:1*/ :: double = x/*0:01*/*y/*0:1*/;
x/*0:01*/ :: int/y/*0:1*/ :: double = x/*0:01*//y/*0:1*/;
x/*0:01*/ :: int<y/*0:1*/ :: double = x/*0:01*/<y/*0:1*/;
x/*0:01*/ :: int>y/*0:1*/ :: double = x/*0:01*/>y/*0:1*/;
x/*0:01*/ :: int<=y/*0:1*/ :: double = x/*0:01*/<=y/*0:1*/;
x/*0:01*/ :: int>=y/*0:1*/ :: double = x/*0:01*/>=y/*0:1*/;
x/*0:01*/ :: int==y/*0:1*/ :: double = x/*0:01*/==y/*0:1*/;
x/*0:01*/ :: int~=y/*0:1*/ :: double = x/*0:01*/~=y/*0:1*/;
x/*0:01*/ :: double+y/*0:1*/ :: int = x/*0:01*/+y/*0:1*/;
x/*0:01*/ :: double-y/*0:1*/ :: int = x/*0:01*/-y/*0:1*/;
x/*0:01*/ :: double*y/*0:1*/ :: int = x/*0:01*/*y/*0:1*/;
x/*0:01*/ :: double/y/*0:1*/ :: int = x/*0:01*//y/*0:1*/;
x/*0:01*/ :: double<y/*0:1*/ :: int = x/*0:01*/<y/*0:1*/;
x/*0:01*/ :: double>y/*0:1*/ :: int = x/*0:01*/>y/*0:1*/;
x/*0:01*/ :: double<=y/*0:1*/ :: int = x/*0:01*/<=y/*0:1*/;
x/*0:01*/ :: double>=y/*0:1*/ :: int = x/*0:01*/>=y/*0:1*/;
x/*0:01*/ :: double==y/*0:1*/ :: int = x/*0:01*/==y/*0:1*/;
x/*0:01*/ :: double~=y/*0:1*/ :: int = x/*0:01*/~=y/*0:1*/;
x/*0:01*/ :: int&&y/*0:1*/ = x/*0:01*/&&y/*0:1*/;
x/*0:01*/ :: int||y/*0:1*/ = x/*0:01*/||y/*0:1*/;
x/*0:01*/$$y/*0:1*/ = y/*0:1*/;
x/*0:1*/& = x/*0:1*/;
'x/*0:1*/ = x/*0:1*/;
quote x/*0:1*/ = x/*0:1*/;
-x/*0:1*/ :: bigint = __C::bigint_neg x/*0:1*/;
not x/*0:1*/ :: bigint = __C::bigint_not x/*0:1*/;
x/*0:01*/ :: bigint<<y/*0:1*/ :: int = __C::bigint_shl x/*0:01*/ y/*0:1*/ if y/*0:1*/>=0;
x/*0:01*/ :: bigint<<y/*0:1*/ :: int = __C::bigint_shr x/*0:01*/ (-y/*0:1*/);
x/*0:01*/ :: bigint>>y/*0:1*/ :: int = __C::bigint_shr x/*0:01*/ y/*0:1*/ if y/*0:1*/>=0;
x/*0:01*/ :: bigint>>y/*0:1*/ :: int = __C::bigint_shl x/*0:01*/ (-y/*0:1*/);
x/*0:01*/ :: bigint+y/*0:1*/ :: bigint = __C::bigint_add x/*0:01*/ y/*0:1*/;
x/*0:01*/ :: bigint-y/*0:1*/ :: bigint = __C::bigint_sub x/*0:01*/ y/*0:1*/;
x/*0:01*/ :: bigint*y/*0:1*/ :: bigint = __C::bigint_mul x/*0:01*/ y/*0:1*/;
x/*0:01*/ :: bigint/y/*0:1*/ :: bigint = double x/*0:01*//double y/*0:1*/;
x/*0:01*/ :: bigint div y/*0:1*/ :: bigint = __C::bigint_div x/*0:01*/ y/*0:1*/;
x/*0:01*/ :: bigint mod y/*0:1*/ :: bigint = __C::bigint_mod x/*0:01*/ y/*0:1*/;
x/*0:01*/ :: bigint or y/*0:1*/ :: bigint = __C::bigint_or x/*0:01*/ y/*0:1*/;
x/*0:01*/ :: bigint and y/*0:1*/ :: bigint = __C::bigint_and x/*0:01*/ y/*0:1*/;
x/*0:01*/ :: bigint<y/*0:1*/ :: bigint = __C::bigint_cmp x/*0:01*/ y/*0:1*/<0;
x/*0:01*/ :: bigint>y/*0:1*/ :: bigint = __C::bigint_cmp x/*0:01*/ y/*0:1*/>0;
x/*0:01*/ :: bigint<=y/*0:1*/ :: bigint = __C::bigint_cmp x/*0:01*/ y/*0:1*/<=0;
x/*0:01*/ :: bigint>=y/*0:1*/ :: bigint = __C::bigint_cmp x/*0:01*/ y/*0:1*/>=0;
x/*0:01*/ :: bigint==y/*0:1*/ :: bigint = __C::bigint_cmp x/*0:01*/ y/*0:1*/==0;
x/*0:01*/ :: bigint~=y/*0:1*/ :: bigint = __C::bigint_cmp x/*0:01*/ y/*0:1*/~=0;
x/*0:01*/ :: int+y/*0:1*/ :: bigint = bigint x/*0:01*/+y/*0:1*/;
x/*0:01*/ :: int-y/*0:1*/ :: bigint = bigint x/*0:01*/-y/*0:1*/;
x/*0:01*/ :: int*y/*0:1*/ :: bigint = bigint x/*0:01*/*y/*0:1*/;
x/*0:01*/ :: int/y/*0:1*/ :: bigint = double x/*0:01*//y/*0:1*/;
x/*0:01*/ :: int div y/*0:1*/ :: bigint = bigint x/*0:01*/ div y/*0:1*/;
x/*0:01*/ :: int mod y/*0:1*/ :: bigint = bigint x/*0:01*/ mod y/*0:1*/;
x/*0:01*/ :: int or y/*0:1*/ :: bigint = bigint x/*0:01*/ or y/*0:1*/;
x/*0:01*/ :: int and y/*0:1*/ :: bigint = bigint x/*0:01*/ and y/*0:1*/;
x/*0:01*/ :: int<y/*0:1*/ :: bigint = bigint x/*0:01*/<y/*0:1*/;
x/*0:01*/ :: int>y/*0:1*/ :: bigint = bigint x/*0:01*/>y/*0:1*/;
x/*0:01*/ :: int<=y/*0:1*/ :: bigint = bigint x/*0:01*/<=y/*0:1*/;
x/*0:01*/ :: int>=y/*0:1*/ :: bigint = bigint x/*0:01*/>=y/*0:1*/;
x/*0:01*/ :: int==y/*0:1*/ :: bigint = bigint x/*0:01*/==y/*0:1*/;
x/*0:01*/ :: int~=y/*0:1*/ :: bigint = bigint x/*0:01*/~=y/*0:1*/;
x/*0:01*/ :: bigint+y/*0:1*/ :: int = x/*0:01*/+bigint y/*0:1*/;
x/*0:01*/ :: bigint-y/*0:1*/ :: int = x/*0:01*/-bigint y/*0:1*/;
x/*0:01*/ :: bigint*y/*0:1*/ :: int = x/*0:01*/*bigint y/*0:1*/;
x/*0:01*/ :: bigint/y/*0:1*/ :: int = x/*0:01*//double y/*0:1*/;
x/*0:01*/ :: bigint div y/*0:1*/ :: int = x/*0:01*/ div bigint y/*0:1*/;
x/*0:01*/ :: bigint mod y/*0:1*/ :: int = x/*0:01*/ mod bigint y/*0:1*/;
x/*0:01*/ :: bigint or y/*0:1*/ :: int = x/*0:01*/ or bigint y/*0:1*/;
x/*0:01*/ :: bigint and y/*0:1*/ :: int = x/*0:01*/ and bigint y/*0:1*/;
x/*0:01*/ :: bigint<y/*0:1*/ :: int = x/*0:01*/<bigint y/*0:1*/;
x/*0:01*/ :: bigint>y/*0:1*/ :: int = x/*0:01*/>bigint y/*0:1*/;
x/*0:01*/ :: bigint<=y/*0:1*/ :: int = x/*0:01*/<=bigint y/*0:1*/;
x/*0:01*/ :: bigint>=y/*0:1*/ :: int = x/*0:01*/>=bigint y/*0:1*/;
x/*0:01*/ :: bigint==y/*0:1*/ :: int = x/*0:01*/==bigint y/*0:1*/;
x/*0:01*/ :: bigint~=y/*0:1*/ :: int = x/*0:01*/~=bigint y/*0:1*/;
x/*0:01*/ :: bigint+y/*0:1*/ :: double = double x/*0:01*/+y/*0:1*/;
x/*0:01*/ :: bigint-y/*0:1*/ :: double = double x/*0:01*/-y/*0:1*/;
x/*0:01*/ :: bigint*y/*0:1*/ :: double = double x/*0:01*/*y/*0:1*/;
x/*0:01*/ :: bigint/y/*0:1*/ :: double = double x/*0:01*//y/*0:1*/;
x/*0:01*/ :: bigint<y/*0:1*/ :: double = double x/*0:01*/<y/*0:1*/;
x/*0:01*/ :: bigint>y/*0:1*/ :: double = double x/*0:01*/>y/*0:1*/;
x/*0:01*/ :: bigint<=y/*0:1*/ :: double = double x/*0:01*/<=y/*0:1*/;
x/*0:01*/ :: bigint>=y/*0:1*/ :: double = double x/*0:01*/>=y/*0:1*/;
x/*0:01*/ :: bigint==y/*0:1*/ :: double = double x/*0:01*/==y/*0:1*/;
x/*0:01*/ :: bigint~=y/*0:1*/ :: double = double x/*0:01*/~=y/*0:1*/;
x/*0:01*/ :: double+y/*0:1*/ :: bigint = x/*0:01*/+double y/*0:1*/;
x/*0:01*/ :: double-y/*0:1*/ :: bigint = x/*0:01*/-double y/*0:1*/;
x/*0:01*/ :: double*y/*0:1*/ :: bigint = x/*0:01*/*double y/*0:1*/;
x/*0:01*/ :: double/y/*0:1*/ :: bigint = x/*0:01*//double y/*0:1*/;
x/*0:01*/ :: double<y/*0:1*/ :: bigint = x/*0:01*/<double y/*0:1*/;
x/*0:01*/ :: double>y/*0:1*/ :: bigint = x/*0:01*/>double y/*0:1*/;
x/*0:01*/ :: double<=y/*0:1*/ :: bigint = x/*0:01*/<=double y/*0:1*/;
x/*0:01*/ :: double>=y/*0:1*/ :: bigint = x/*0:01*/>=double y/*0:1*/;
x/*0:01*/ :: double==y/*0:1*/ :: bigint = x/*0:01*/==double y/*0:1*/;
x/*0:01*/ :: double~=y/*0:1*/ :: bigint = x/*0:01*/~=double y/*0:1*/;
gcd x/*0:01*/ :: bigint y/*0:1*/ :: bigint = __C::bigint_gcd x/*0:01*/ y/*0:1*/;
lcm x/*0:01*/ :: bigint y/*0:1*/ :: bigint = __C::bigint_lcm x/*0:01*/ y/*0:1*/;
gcd x/*0:01*/ :: int y/*0:1*/ :: bigint = __C::bigint_gcd (bigint x/*0:01*/) y/*0:1*/;
gcd x/*0:01*/ :: bigint y/*0:1*/ :: int = __C::bigint_gcd x/*0:01*/ (bigint y/*0:1*/);
gcd x/*0:01*/ :: int y/*0:1*/ :: int = int (__C::bigint_gcd (bigint x/*0:01*/) (bigint y/*0:1*/));
lcm x/*0:01*/ :: int y/*0:1*/ :: bigint = __C::bigint_lcm (bigint x/*0:01*/) y/*0:1*/;
lcm x/*0:01*/ :: bigint y/*0:1*/ :: int = __C::bigint_lcm x/*0:01*/ (bigint y/*0:1*/);
lcm x/*0:01*/ :: int y/*0:1*/ :: int = int (__C::bigint_lcm (bigint x/*0:01*/) (bigint y/*0:1*/));
pow x/*0:01*/ :: int y/*0:1*/ :: int = __C::bigint_pow (bigint x/*0:01*/) y/*0:1*/ if y/*0:1*/>=0;
pow x/*0:01*/ :: bigint y/*0:1*/ :: bigint = __C::bigint_pow x/*0:01*/ y/*0:1*/ if y/*0:1*/>=0;
pow x/*0:01*/ :: int y/*0:1*/ :: bigint = __C::bigint_pow (bigint x/*0:01*/) y/*0:1*/ if y/*0:1*/>=0;
pow x/*0:01*/ :: bigint y/*0:1*/ :: int = __C::bigint_pow x/*0:01*/ y/*0:1*/ if y/*0:1*/>=0;
1.0^y/*0:1*/ :: double = 1.0;
(-1.0)^y/*0:1*/ :: double = 1.0 if infp y/*0:1*/;
x/*0:01*/ :: double^y/*0:1*/ :: double = __C::pow x/*0:01*/ y/*0:1*/;
x/*0:01*/ :: int^y/*0:1*/ :: int = double x/*0:01*/^double y/*0:1*/;
x/*0:01*/ :: bigint^y/*0:1*/ :: bigint = double x/*0:01*/^double y/*0:1*/;
x/*0:01*/ :: int^y/*0:1*/ :: bigint = double x/*0:01*/^double y/*0:1*/;
x/*0:01*/ :: bigint^y/*0:1*/ :: int = double x/*0:01*/^double y/*0:1*/;
x/*0:01*/ :: double^y/*0:1*/ :: int = x/*0:01*/^double y/*0:1*/;
x/*0:01*/ :: double^y/*0:1*/ :: bigint = x/*0:01*/^double y/*0:1*/;
x/*0:01*/ :: int^y/*0:1*/ :: double = double x/*0:01*/^y/*0:1*/;
x/*0:01*/ :: bigint^y/*0:1*/ :: double = double x/*0:01*/^y/*0:1*/;
{
  rule #0: -x::int = -x
  rule #1: -x::double = -x
  rule #2: -x::bigint = __C::bigint_neg x
  state 0: #0 #1 #2
	<var>::int state 1
	<var>::bigint state 2
	<var>::double state 3
  state 1: #0
  state 2: #2
  state 3: #1
}
{
  rule #0: ~x::int = ~x
  state 0: #0
	<var>::int state 1
  state 1: #0
}
{
  rule #0: not x::int = not x
  rule #1: not x::bigint = __C::bigint_not x
  state 0: #0 #1
	<var>::int state 1
	<var>::bigint state 2
  state 1: #0
  state 2: #1
}
{
  rule #0: x::int||y = x||y
  state 0: #0
	<var>::int state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: x::int&&y = x&&y
  state 0: #0
	<var>::int state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: x::int or y::int = x or y
  rule #1: x::bigint or y::bigint = __C::bigint_or x y
  rule #2: x::int or y::bigint = bigint x or y
  rule #3: x::bigint or y::int = x or bigint y
  state 0: #0 #1 #2 #3
	<var>::int state 1
	<var>::bigint state 4
  state 1: #0 #2
	<var>::int state 2
	<var>::bigint state 3
  state 2: #0
  state 3: #2
  state 4: #1 #3
	<var>::int state 5
	<var>::bigint state 6
  state 5: #3
  state 6: #1
}
{
  rule #0: x::int and y::int = x and y
  rule #1: x::bigint and y::bigint = __C::bigint_and x y
  rule #2: x::int and y::bigint = bigint x and y
  rule #3: x::bigint and y::int = x and bigint y
  state 0: #0 #1 #2 #3
	<var>::int state 1
	<var>::bigint state 4
  state 1: #0 #2
	<var>::int state 2
	<var>::bigint state 3
  state 2: #0
  state 3: #2
  state 4: #1 #3
	<var>::int state 5
	<var>::bigint state 6
  state 5: #3
  state 6: #1
}
{
  rule #0: x::int<<y::int = x<<y
  rule #1: x::bigint<<y::int = __C::bigint_shl x y if y>=0
  rule #2: x::bigint<<y::int = __C::bigint_shr x (-y)
  state 0: #0 #1 #2
	<var>::int state 1
	<var>::bigint state 3
  state 1: #0
	<var>::int state 2
  state 2: #0
  state 3: #1 #2
	<var>::int state 4
  state 4: #1 #2
}
{
  rule #0: x::int>>y::int = x>>y
  rule #1: x::bigint>>y::int = __C::bigint_shr x y if y>=0
  rule #2: x::bigint>>y::int = __C::bigint_shl x (-y)
  state 0: #0 #1 #2
	<var>::int state 1
	<var>::bigint state 3
  state 1: #0
	<var>::int state 2
  state 2: #0
  state 3: #1 #2
	<var>::int state 4
  state 4: #1 #2
}
{
  rule #0: x::int<y::int = x<y
  rule #1: x::double<y::double = x<y
  rule #2: x::int<y::double = x<y
  rule #3: x::double<y::int = x<y
  rule #4: x::bigint<y::bigint = __C::bigint_cmp x y<0
  rule #5: x::int<y::bigint = bigint x<y
  rule #6: x::bigint<y::int = x<bigint y
  rule #7: x::bigint<y::double = double x<y
  rule #8: x::double<y::bigint = x<double y
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
}
{
  rule #0: x::int>y::int = x>y
  rule #1: x::double>y::double = x>y
  rule #2: x::int>y::double = x>y
  rule #3: x::double>y::int = x>y
  rule #4: x::bigint>y::bigint = __C::bigint_cmp x y>0
  rule #5: x::int>y::bigint = bigint x>y
  rule #6: x::bigint>y::int = x>bigint y
  rule #7: x::bigint>y::double = double x>y
  rule #8: x::double>y::bigint = x>double y
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
}
{
  rule #0: x::int<=y::int = x<=y
  rule #1: x::double<=y::double = x<=y
  rule #2: x::int<=y::double = x<=y
  rule #3: x::double<=y::int = x<=y
  rule #4: x::bigint<=y::bigint = __C::bigint_cmp x y<=0
  rule #5: x::int<=y::bigint = bigint x<=y
  rule #6: x::bigint<=y::int = x<=bigint y
  rule #7: x::bigint<=y::double = double x<=y
  rule #8: x::double<=y::bigint = x<=double y
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
}
{
  rule #0: x::int>=y::int = x>=y
  rule #1: x::double>=y::double = x>=y
  rule #2: x::int>=y::double = x>=y
  rule #3: x::double>=y::int = x>=y
  rule #4: x::bigint>=y::bigint = __C::bigint_cmp x y>=0
  rule #5: x::int>=y::bigint = bigint x>=y
  rule #6: x::bigint>=y::int = x>=bigint y
  rule #7: x::bigint>=y::double = double x>=y
  rule #8: x::double>=y::bigint = x>=double y
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
}
{
  rule #0: x::int==y::int = x==y
  rule #1: x::double==y::double = x==y
  rule #2: x::int==y::double = x==y
  rule #3: x::double==y::int = x==y
  rule #4: x::bigint==y::bigint = __C::bigint_cmp x y==0
  rule #5: x::int==y::bigint = bigint x==y
  rule #6: x::bigint==y::int = x==bigint y
  rule #7: x::bigint==y::double = double x==y
  rule #8: x::double==y::bigint = x==double y
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
}
{
  rule #0: x::int~=y::int = x~=y
  rule #1: x::double~=y::double = x~=y
  rule #2: x::int~=y::double = x~=y
  rule #3: x::double~=y::int = x~=y
  rule #4: x::bigint~=y::bigint = __C::bigint_cmp x y~=0
  rule #5: x::int~=y::bigint = bigint x~=y
  rule #6: x::bigint~=y::int = x~=bigint y
  rule #7: x::bigint~=y::double = double x~=y
  rule #8: x::double~=y::bigint = x~=double y
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
}
{
  rule #0: x::int+y::int = x+y
  rule #1: x::double+y::double = x+y
  rule #2: x::int+y::double = x+y
  rule #3: x::double+y::int = x+y
  rule #4: x::bigint+y::bigint = __C::bigint_add x y
  rule #5: x::int+y::bigint = bigint x+y
  rule #6: x::bigint+y::int = x+bigint y
  rule #7: x::bigint+y::double = double x+y
  rule #8: x::double+y::bigint = x+double y
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
}
{
  rule #0: x::int-y::int = x-y
  rule #1: x::double-y::double = x-y
  rule #2: x::int-y::double = x-y
  rule #3: x::double-y::int = x-y
  rule #4: x::bigint-y::bigint = __C::bigint_sub x y
  rule #5: x::int-y::bigint = bigint x-y
  rule #6: x::bigint-y::int = x-bigint y
  rule #7: x::bigint-y::double = double x-y
  rule #8: x::double-y::bigint = x-double y
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
}
{
  rule #0: x::int*y::int = x*y
  rule #1: x::double*y::double = x*y
  rule #2: x::int*y::double = x*y
  rule #3: x::double*y::int = x*y
  rule #4: x::bigint*y::bigint = __C::bigint_mul x y
  rule #5: x::int*y::bigint = bigint x*y
  rule #6: x::bigint*y::int = x*bigint y
  rule #7: x::bigint*y::double = double x*y
  rule #8: x::double*y::bigint = x*double y
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
}
{
  rule #0: x::int/y::int = x/y
  rule #1: x::double/y::double = x/y
  rule #2: x::int/y::double = x/y
  rule #3: x::double/y::int = x/y
  rule #4: x::bigint/y::bigint = double x/double y
  rule #5: x::int/y::bigint = double x/y
  rule #6: x::bigint/y::int = x/double y
  rule #7: x::bigint/y::double = double x/y
  rule #8: x::double/y::bigint = x/double y
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
}
{
  rule #0: x::int div y::int = x div y
  rule #1: x::bigint div y::bigint = __C::bigint_div x y
  rule #2: x::int div y::bigint = bigint x div y
  rule #3: x::bigint div y::int = x div bigint y
  state 0: #0 #1 #2 #3
	<var>::int state 1
	<var>::bigint state 4
  state 1: #0 #2
	<var>::int state 2
	<var>::bigint state 3
  state 2: #0
  state 3: #2
  state 4: #1 #3
	<var>::int state 5
	<var>::bigint state 6
  state 5: #3
  state 6: #1
}
{
  rule #0: x::int mod y::int = x mod y
  rule #1: x::bigint mod y::bigint = __C::bigint_mod x y
  rule #2: x::int mod y::bigint = bigint x mod y
  rule #3: x::bigint mod y::int = x mod bigint y
  state 0: #0 #1 #2 #3
	<var>::int state 1
	<var>::bigint state 4
  state 1: #0 #2
	<var>::int state 2
	<var>::bigint state 3
  state 2: #0
  state 3: #2
  state 4: #1 #3
	<var>::int state 5
	<var>::bigint state 6
  state 5: #3
  state 6: #1
}
{
  rule #0: quote x = x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: x& = x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: 'x = x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: x$$y = y
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: 1.0^y::double = 1.0
  rule #1: (-1.0)^y::double = 1.0 if infp y
  rule #2: x::double^y::double = __C::pow x y
  rule #3: x::int^y::int = double x^double y
  rule #4: x::bigint^y::bigint = double x^double y
  rule #5: x::int^y::bigint = double x^double y
  rule #6: x::bigint^y::int = double x^double y
  rule #7: x::double^y::int = x^double y
  rule #8: x::double^y::bigint = x^double y
  rule #9: x::int^y::double = double x^y
  rule #10: x::bigint^y::double = double x^y
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
	1::double state 13
	-1::double state 17
  state 1: #3 #5 #9
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #3
  state 3: #5
  state 4: #9
  state 5: #4 #6 #10
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #10
  state 9: #2 #7 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #7
  state 11: #8
  state 12: #2
  state 13: #0 #2 #7 #8
	<var>::int state 14
	<var>::bigint state 15
	<var>::double state 16
  state 14: #7
  state 15: #8
  state 16: #0 #2
  state 17: #1 #2 #7 #8
	<var>::int state 18
	<var>::bigint state 19
	<var>::double state 20
  state 18: #7
  state 19: #8
  state 20: #1 #2
}
{
  rule #0: null x::pointer = x===#<pointer 0> if __C::pure_pointer_equal (get_ptrtag x)===#<pointer 0>
  state 0: #0
	<var>::pointer state 1
  state 1: #0
}
{
  rule #0: ubyte x::int = if x>=0 then x else x+256
  state 0: #0
	<var>::int state 1
  state 1: #0
}
{
  rule #0: ushort x::int = if x>=0 then x else x+65536
  state 0: #0
	<var>::int state 1
  state 1: #0
}
{
  rule #0: uint x::int = if x>=0 then bigint x else x+4294967296L
  state 0: #0
	<var>::int state 1
  state 1: #0
}
{
  rule #0: uint64 x::int = if x>=0 then bigint x else x+18446744073709551616L
  rule #1: uint64 x::bigint = if x>=0 then bigint x else x+18446744073709551616L
  state 0: #0 #1
	<var>::int state 1
	<var>::bigint state 2
  state 1: #0
  state 2: #1
}
{
  rule #0: ulong = uint64
  state 0: #0
}
{
  rule #0: floor x::int = x
  rule #1: floor x::bigint = x
  state 0: #0 #1
	<var>::int state 1
	<var>::bigint state 2
  state 1: #0
  state 2: #1
}
{
  rule #0: ceil x::int = x
  rule #1: ceil x::bigint = x
  state 0: #0 #1
	<var>::int state 1
	<var>::bigint state 2
  state 1: #0
  state 2: #1
}
{
  rule #0: round x::int = x
  rule #1: round x::bigint = x
  state 0: #0 #1
	<var>::int state 1
	<var>::bigint state 2
  state 1: #0
  state 2: #1
}
{
  rule #0: trunc x::int = x
  rule #1: trunc x::bigint = x
  state 0: #0 #1
	<var>::int state 1
	<var>::bigint state 2
  state 1: #0
  state 2: #1
}
{
  rule #0: frac x::int = x-trunc x
  rule #1: frac x::bigint = x-trunc x
  rule #2: frac x::double = x-trunc x
  state 0: #0 #1 #2
	<var>::int state 1
	<var>::bigint state 2
	<var>::double state 3
  state 1: #0
  state 2: #1
  state 3: #2
}
{
  rule #0: abs x::int = if x>0 then x else -x
  rule #1: abs x::bigint = if x>0 then x else -x
  rule #2: abs x::double = if x>0 then x else -x
  state 0: #0 #1 #2
	<var>::int state 1
	<var>::bigint state 2
	<var>::double state 3
  state 1: #0
  state 2: #1
  state 3: #2
}
{
  rule #0: sgn x::int = if x>0 then 1 else if x<0 then -1 else 0
  rule #1: sgn x::bigint = if x>0 then 1 else if x<0 then -1 else 0
  rule #2: sgn x::double = if x>0 then 1 else if x<0 then -1 else 0
  state 0: #0 #1 #2
	<var>::int state 1
	<var>::bigint state 2
	<var>::double state 3
  state 1: #0
  state 2: #1
  state 3: #2
}
{
  rule #0: min x y = if x<=y then x else y
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: max x y = if x>=y then x else y
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: succ x = x+1
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: pred x = x-1
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: gcd x::bigint y::bigint = __C::bigint_gcd x y
  rule #1: gcd x::int y::bigint = __C::bigint_gcd (bigint x) y
  rule #2: gcd x::bigint y::int = __C::bigint_gcd x (bigint y)
  rule #3: gcd x::int y::int = int (__C::bigint_gcd (bigint x) (bigint y))
  state 0: #0 #1 #2 #3
	<var>::int state 1
	<var>::bigint state 4
  state 1: #1 #3
	<var>::int state 2
	<var>::bigint state 3
  state 2: #3
  state 3: #1
  state 4: #0 #2
	<var>::int state 5
	<var>::bigint state 6
  state 5: #2
  state 6: #0
}
{
  rule #0: lcm x::bigint y::bigint = __C::bigint_lcm x y
  rule #1: lcm x::int y::bigint = __C::bigint_lcm (bigint x) y
  rule #2: lcm x::bigint y::int = __C::bigint_lcm x (bigint y)
  rule #3: lcm x::int y::int = int (__C::bigint_lcm (bigint x) (bigint y))
  state 0: #0 #1 #2 #3
	<var>::int state 1
	<var>::bigint state 4
  state 1: #1 #3
	<var>::int state 2
	<var>::bigint state 3
  state 2: #3
  state 3: #1
  state 4: #0 #2
	<var>::int state 5
	<var>::bigint state 6
  state 5: #2
  state 6: #0
}
{
  rule #0: pow x::int y::int = __C::bigint_pow (bigint x) y if y>=0
  rule #1: pow x::bigint y::bigint = __C::bigint_pow x y if y>=0
  rule #2: pow x::int y::bigint = __C::bigint_pow (bigint x) y if y>=0
  rule #3: pow x::bigint y::int = __C::bigint_pow x y if y>=0
  state 0: #0 #1 #2 #3
	<var>::int state 1
	<var>::bigint state 4
  state 1: #0 #2
	<var>::int state 2
	<var>::bigint state 3
  state 2: #0
  state 3: #2
  state 4: #1 #3
	<var>::int state 5
	<var>::bigint state 6
  state 5: #3
  state 6: #1
}
const inf = inf;
const nan = nan;
infp x/*0:1*/ = case x/*0:1*/ of x/*0:*/ :: double = x/*0:*/==inf||x/*0:*/==-inf; x/*0:*/ :: int = 0; x/*0:*/ :: bigint = 0; x/*0:*/ :: real = case double x/*0:*/ of x/*0:*/ :: double = infp x/*0:*/; _/*0:*/ = 0 {
  rule #0: x::double = infp x
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::double state 2
  state 1: #1
  state 2: #0 #1
} end; _/*0:*/ = 0 {
  rule #0: x::double = x==inf||x==-inf
  rule #1: x::int = 0
  rule #2: x::bigint = 0
  rule #3: x::real = case double x of x::double = infp x; _ = 0 end
  rule #4: _ = 0
  state 0: #0 #1 #2 #3 #4
	<var> state 1
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 1: #3 #4
  state 2: #1 #3 #4
  state 3: #2 #3 #4
  state 4: #0 #3 #4
} end;
nanp x/*0:1*/ = case x/*0:1*/ of x/*0:*/ :: double = ~x/*0:*/==x/*0:*/; x/*0:*/ :: int = 0; x/*0:*/ :: bigint = 0; x/*0:*/ :: real = case double x/*0:*/ of x/*0:*/ :: double = nanp x/*0:*/; _/*0:*/ = 0 {
  rule #0: x::double = nanp x
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::double state 2
  state 1: #1
  state 2: #0 #1
} end; _/*0:*/ = 0 {
  rule #0: x::double = ~x==x
  rule #1: x::int = 0
  rule #2: x::bigint = 0
  rule #3: x::real = case double x of x::double = nanp x; _ = 0 end
  rule #4: _ = 0
  state 0: #0 #1 #2 #3 #4
	<var> state 1
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 1: #3 #4
  state 2: #1 #3 #4
  state 3: #2 #3 #4
  state 4: #0 #3 #4
} end;
n/*0:01*/ :: int..m/*0:1*/ :: int = __C::pure_int_seq n/*0:01*/ m/*0:1*/ 1;
n1/*0:0101*/ :: int:n2/*0:011*/ :: int..m/*0:1*/ :: int = __C::pure_int_seq n1/*0:0101*/ m/*0:1*/ (n2/*0:011*/-n1/*0:0101*/) if n1/*0:0101*/~=n2/*0:011*/;
n/*0:01*/ :: double..m/*0:1*/ :: double = __C::pure_double_seq n/*0:01*/ m/*0:1*/ 1.0 if ~infp n/*0:01*/&&~infp m/*0:1*/;
n/*0:01*/ :: int..m/*0:1*/ :: double = __C::pure_double_seq (double n/*0:01*/) m/*0:1*/ 1.0 if ~infp m/*0:1*/;
n/*0:01*/ :: double..m/*0:1*/ :: int = __C::pure_double_seq n/*0:01*/ (double m/*0:1*/) 1.0 if ~infp n/*0:01*/;
n1/*0:0101*/ :: double:n2/*0:011*/ :: double..m/*0:1*/ :: double = __C::pure_double_seq n1/*0:0101*/ m/*0:1*/ (n2/*0:011*/-n1/*0:0101*/) if ~infp n1/*0:0101*/&&~infp m/*0:1*/&&n1/*0:0101*/~=n2/*0:011*/;
n1/*0:0101*/ :: int:n2/*0:011*/ :: double..m/*0:1*/ :: double = __C::pure_double_seq (double n1/*0:0101*/) m/*0:1*/ (n2/*0:011*/-n1/*0:0101*/) if ~infp m/*0:1*/&&n1/*0:0101*/~=n2/*0:011*/;
n1/*0:0101*/ :: double:n2/*0:011*/ :: int..m/*0:1*/ :: double = __C::pure_double_seq n1/*0:0101*/ m/*0:1*/ (n2/*0:011*/-n1/*0:0101*/) if ~infp n1/*0:0101*/&&~infp m/*0:1*/&&n1/*0:0101*/~=n2/*0:011*/;
n1/*0:0101*/ :: double:n2/*0:011*/ :: double..m/*0:1*/ :: int = __C::pure_double_seq n1/*0:0101*/ (double m/*0:1*/) (n2/*0:011*/-n1/*0:0101*/) if ~infp n1/*0:0101*/&&n1/*0:0101*/~=n2/*0:011*/;
n1/*0:0101*/ :: int:n2/*0:011*/ :: int..m/*0:1*/ :: double = __C::pure_double_seq (double n1/*0:0101*/) m/*0:1*/ (double (n2/*0:011*/-n1/*0:0101*/)) if ~infp m/*0:1*/&&n1/*0:0101*/~=n2/*0:011*/;
n1/*0:0101*/ :: int:n2/*0:011*/ :: double..m/*0:1*/ :: int = __C::pure_double_seq (double n1/*0:0101*/) (double m/*0:1*/) (n2/*0:011*/-n1/*0:0101*/) if n1/*0:0101*/~=n2/*0:011*/;
n1/*0:0101*/ :: double:n2/*0:011*/ :: int..m/*0:1*/ :: int = __C::pure_double_seq n1/*0:0101*/ (double m/*0:1*/) (n2/*0:011*/-n1/*0:0101*/) if ~infp n1/*0:0101*/&&n1/*0:0101*/~=n2/*0:011*/;
get_byte x/*0:1*/ :: pointer = __C::pointer_get_byte x/*0:1*/;
get_short x/*0:1*/ :: pointer = __C::pointer_get_short x/*0:1*/;
get_int x/*0:1*/ :: pointer = __C::pointer_get_int x/*0:1*/;
get_long x/*0:1*/ :: pointer = __C::pointer_get_long x/*0:1*/;
get_int64 x/*0:1*/ :: pointer = __C::pointer_get_int64 x/*0:1*/;
get_float x/*0:1*/ :: pointer = __C::pointer_get_float x/*0:1*/;
get_double x/*0:1*/ :: pointer = __C::pointer_get_double x/*0:1*/;
get_string x/*0:1*/ :: pointer = __C::pointer_get_string x/*0:1*/;
get_pointer x/*0:1*/ :: pointer = __C::pointer_get_pointer x/*0:1*/;
put_byte x/*0:01*/ :: pointer y/*0:1*/ :: int = __C::pointer_put_byte x/*0:01*/ y/*0:1*/;
put_short x/*0:01*/ :: pointer y/*0:1*/ :: int = __C::pointer_put_short x/*0:01*/ y/*0:1*/;
put_int x/*0:01*/ :: pointer y/*0:1*/ :: int = __C::pointer_put_int x/*0:01*/ y/*0:1*/;
put_long x/*0:01*/ :: pointer y/*0:1*/ :: int = __C::pointer_put_long x/*0:01*/ y/*0:1*/;
put_long x/*0:01*/ :: pointer y/*0:1*/ :: bigint = __C::pointer_put_long x/*0:01*/ y/*0:1*/;
put_int64 x/*0:01*/ :: pointer y/*0:1*/ :: int = __C::pointer_put_int64 x/*0:01*/ y/*0:1*/;
put_int64 x/*0:01*/ :: pointer y/*0:1*/ :: bigint = __C::pointer_put_int64 x/*0:01*/ y/*0:1*/;
put_float x/*0:01*/ :: pointer y/*0:1*/ :: double = __C::pointer_put_float x/*0:01*/ y/*0:1*/;
put_double x/*0:01*/ :: pointer y/*0:1*/ :: double = __C::pointer_put_double x/*0:01*/ y/*0:1*/;
put_string x/*0:01*/ :: pointer y/*0:1*/ :: string = __C::pointer_put_string x/*0:01*/ y/*0:1*/;
put_pointer x/*0:01*/ :: pointer y/*0:1*/ :: string = __C::pointer_put_pointer x/*0:01*/ y/*0:1*/;
put_pointer x/*0:01*/ :: pointer y/*0:1*/ :: pointer = __C::pointer_put_pointer x/*0:01*/ y/*0:1*/;
sentry f/*0:01*/ x/*0:1*/ = if __C::pure_has_sentry x/*0:1*/ then (case __C::pure_get_sentry x/*0:1*/ of weak::sentrybox1 wr/*0:1*/ = __C::pure_sentry (weak::sentrybox2 wr/*0:1*/ f/*1:01*/) x/*1:1*/; weak::sentrybox2 wr/*0:01*/ _/*0:1*/ = __C::pure_sentry (weak::sentrybox2 wr/*0:01*/ f/*1:01*/) x/*1:1*/; _/*0:*/ = __C::pure_sentry f/*1:01*/ x/*1:1*/ {
  rule #0: weak::sentrybox1 wr = __C::pure_sentry (weak::sentrybox2 wr f) x
  rule #1: weak::sentrybox2 wr _ = __C::pure_sentry (weak::sentrybox2 wr f) x
  rule #2: _ = __C::pure_sentry f x
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
	weak::sentrybox1 state 12
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #1 #2
	<var> state 6
	weak::sentrybox2 state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
  state 10: #1 #2
	<var> state 11
  state 11: #1 #2
  state 12: #0 #2
	<var> state 13
  state 13: #0 #2
} end) else __C::pure_sentry f/*0:01*/ x/*0:1*/;
clear_sentry x/*0:1*/ = if __C::pure_has_sentry x/*0:1*/ then (case __C::pure_get_sentry x/*0:1*/ of weak::sentrybox1 _/*0:1*/ = x/*1:1*/; weak::sentrybox2 wr/*0:01*/ _/*0:1*/ = __C::pure_sentry (weak::sentrybox1 wr/*0:01*/) x/*1:1*/; _/*0:*/ = __C::pure_clear_sentry x/*1:1*/ {
  rule #0: weak::sentrybox1 _ = x
  rule #1: weak::sentrybox2 wr _ = __C::pure_sentry (weak::sentrybox1 wr) x
  rule #2: _ = __C::pure_clear_sentry x
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
	weak::sentrybox1 state 12
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #1 #2
	<var> state 6
	weak::sentrybox2 state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
  state 10: #1 #2
	<var> state 11
  state 11: #1 #2
  state 12: #0 #2
	<var> state 13
  state 13: #0 #2
} end) else x/*0:1*/;
get_sentry x/*0:1*/ = s/*0:1*/ if ok/*0:0*/ when ok@_/*0:0*/ s/*0:1*/ = if __C::pure_has_sentry x/*0:1*/ then (case __C::pure_get_sentry x/*0:1*/ of weak::sentrybox1 _/*0:1*/ = 0 _; weak::sentrybox2 _/*0:01*/ s/*0:1*/ = 1 s/*0:1*/; s/*0:*/ = 1 s/*0:*/ {
  rule #0: weak::sentrybox1 _ = 0 _
  rule #1: weak::sentrybox2 _ s = 1 s
  rule #2: s = 1 s
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
	weak::sentrybox1 state 12
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #1 #2
	<var> state 6
	weak::sentrybox2 state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
  state 10: #1 #2
	<var> state 11
  state 11: #1 #2
  state 12: #0 #2
	<var> state 13
  state 13: #0 #2
} end) else 0 _ {
  rule #0: ok@_ s = if __C::pure_has_sentry x then (case __C::pure_get_sentry x of weak::sentrybox1 _ = 0 _; weak::sentrybox2 _ s = 1 s; s = 1 s end) else 0 _
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end;
cookedp x/*0:1*/ = if __C::pure_has_sentry x/*0:1*/ then (case __C::pure_get_sentry x/*0:1*/ of weak::sentrybox1 _/*0:1*/ = 0; _/*0:*/ = 1 {
  rule #0: weak::sentrybox1 _ = 0
  rule #1: _ = 1
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	weak::sentrybox1 state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
  state 6: #0 #1
} end) else 0;
cooked p/*0:1*/ :: pointer = sentry free p/*0:1*/;
pointer_tag x/*0:1*/ :: string = __C::pure_pointer_tag x/*0:1*/;
pointer_tag x/*0:1*/ :: pointer = get_ptrtag x/*0:1*/;
pointer_type x/*0:1*/ :: pointer = pointer_type (get_ptrtag x/*0:1*/);
pointer_cast ty/*0:01*/ :: string x/*0:1*/ :: pointer = pointer_cast (pointer_tag ty/*0:01*/) x/*0:1*/;
{
  rule #0: n::int..m::int = __C::pure_int_seq n m 1
  rule #1: n1::int:n2::int..m::int = __C::pure_int_seq n1 m (n2-n1) if n1~=n2
  rule #2: n::double..m::double = __C::pure_double_seq n m 1.0 if ~infp n&&~infp m
  rule #3: n::int..m::double = __C::pure_double_seq (double n) m 1.0 if ~infp m
  rule #4: n::double..m::int = __C::pure_double_seq n (double m) 1.0 if ~infp n
  rule #5: n1::double:n2::double..m::double = __C::pure_double_seq n1 m (n2-n1) if ~infp n1&&~infp m&&n1~=n2
  rule #6: n1::int:n2::double..m::double = __C::pure_double_seq (double n1) m (n2-n1) if ~infp m&&n1~=n2
  rule #7: n1::double:n2::int..m::double = __C::pure_double_seq n1 m (n2-n1) if ~infp n1&&~infp m&&n1~=n2
  rule #8: n1::double:n2::double..m::int = __C::pure_double_seq n1 (double m) (n2-n1) if ~infp n1&&n1~=n2
  rule #9: n1::int:n2::int..m::double = __C::pure_double_seq (double n1) m (double (n2-n1)) if ~infp m&&n1~=n2
  rule #10: n1::int:n2::double..m::int = __C::pure_double_seq (double n1) (double m) (n2-n1) if n1~=n2
  rule #11: n1::double:n2::int..m::int = __C::pure_double_seq n1 (double m) (n2-n1) if ~infp n1&&n1~=n2
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11
	<var>::int state 1
	<var>::double state 4
	<app> state 7
  state 1: #0 #3
	<var>::int state 2
	<var>::double state 3
  state 2: #0
  state 3: #3
  state 4: #2 #4
	<var>::int state 5
	<var>::double state 6
  state 5: #4
  state 6: #2
  state 7: #1 #5 #6 #7 #8 #9 #10 #11
	<app> state 8
  state 8: #1 #5 #6 #7 #8 #9 #10 #11
	: state 9
  state 9: #1 #5 #6 #7 #8 #9 #10 #11
	<var>::int state 10
	<var>::double state 17
  state 10: #1 #6 #9 #10
	<var>::int state 11
	<var>::double state 14
  state 11: #1 #9
	<var>::int state 12
	<var>::double state 13
  state 12: #1
  state 13: #9
  state 14: #6 #10
	<var>::int state 15
	<var>::double state 16
  state 15: #10
  state 16: #6
  state 17: #5 #7 #8 #11
	<var>::int state 18
	<var>::double state 21
  state 18: #7 #11
	<var>::int state 19
	<var>::double state 20
  state 19: #11
  state 20: #7
  state 21: #5 #8
	<var>::int state 22
	<var>::double state 23
  state 22: #8
  state 23: #5
}
{
  rule #0: infp x = case x of x::double = x==inf||x==-inf; x::int = 0; x::bigint = 0; x::real = case double x of x::double = infp x; _ = 0 end; _ = 0 end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: nanp x = case x of x::double = ~x==x; x::int = 0; x::bigint = 0; x::real = case double x of x::double = nanp x; _ = 0 end; _ = 0 end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: get_byte x::pointer = __C::pointer_get_byte x
  state 0: #0
	<var>::pointer state 1
  state 1: #0
}
{
  rule #0: get_short x::pointer = __C::pointer_get_short x
  state 0: #0
	<var>::pointer state 1
  state 1: #0
}
{
  rule #0: get_int x::pointer = __C::pointer_get_int x
  state 0: #0
	<var>::pointer state 1
  state 1: #0
}
{
  rule #0: get_long x::pointer = __C::pointer_get_long x
  state 0: #0
	<var>::pointer state 1
  state 1: #0
}
{
  rule #0: get_int64 x::pointer = __C::pointer_get_int64 x
  state 0: #0
	<var>::pointer state 1
  state 1: #0
}
{
  rule #0: get_float x::pointer = __C::pointer_get_float x
  state 0: #0
	<var>::pointer state 1
  state 1: #0
}
{
  rule #0: get_double x::pointer = __C::pointer_get_double x
  state 0: #0
	<var>::pointer state 1
  state 1: #0
}
{
  rule #0: get_string x::pointer = __C::pointer_get_string x
  state 0: #0
	<var>::pointer state 1
  state 1: #0
}
{
  rule #0: get_pointer x::pointer = __C::pointer_get_pointer x
  state 0: #0
	<var>::pointer state 1
  state 1: #0
}
{
  rule #0: put_byte x::pointer y::int = __C::pointer_put_byte x y
  state 0: #0
	<var>::pointer state 1
  state 1: #0
	<var>::int state 2
  state 2: #0
}
{
  rule #0: put_short x::pointer y::int = __C::pointer_put_short x y
  state 0: #0
	<var>::pointer state 1
  state 1: #0
	<var>::int state 2
  state 2: #0
}
{
  rule #0: put_int x::pointer y::int = __C::pointer_put_int x y
  state 0: #0
	<var>::pointer state 1
  state 1: #0
	<var>::int state 2
  state 2: #0
}
{
  rule #0: put_long x::pointer y::int = __C::pointer_put_long x y
  rule #1: put_long x::pointer y::bigint = __C::pointer_put_long x y
  state 0: #0 #1
	<var>::pointer state 1
  state 1: #0 #1
	<var>::int state 2
	<var>::bigint state 3
  state 2: #0
  state 3: #1
}
{
  rule #0: put_int64 x::pointer y::int = __C::pointer_put_int64 x y
  rule #1: put_int64 x::pointer y::bigint = __C::pointer_put_int64 x y
  state 0: #0 #1
	<var>::pointer state 1
  state 1: #0 #1
	<var>::int state 2
	<var>::bigint state 3
  state 2: #0
  state 3: #1
}
{
  rule #0: put_float x::pointer y::double = __C::pointer_put_float x y
  state 0: #0
	<var>::pointer state 1
  state 1: #0
	<var>::double state 2
  state 2: #0
}
{
  rule #0: put_double x::pointer y::double = __C::pointer_put_double x y
  state 0: #0
	<var>::pointer state 1
  state 1: #0
	<var>::double state 2
  state 2: #0
}
{
  rule #0: put_string x::pointer y::string = __C::pointer_put_string x y
  state 0: #0
	<var>::pointer state 1
  state 1: #0
	<var>::string state 2
  state 2: #0
}
{
  rule #0: put_pointer x::pointer y::string = __C::pointer_put_pointer x y
  rule #1: put_pointer x::pointer y::pointer = __C::pointer_put_pointer x y
  state 0: #0 #1
	<var>::pointer state 1
  state 1: #0 #1
	<var>::string state 2
	<var>::pointer state 3
  state 2: #0
  state 3: #1
}
{
  rule #0: sentry f x = if __C::pure_has_sentry x then (case __C::pure_get_sentry x of weak::sentrybox1 wr = __C::pure_sentry (weak::sentrybox2 wr f) x; weak::sentrybox2 wr _ = __C::pure_sentry (weak::sentrybox2 wr f) x; _ = __C::pure_sentry f x end) else __C::pure_sentry f x
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: clear_sentry x = if __C::pure_has_sentry x then (case __C::pure_get_sentry x of weak::sentrybox1 _ = x; weak::sentrybox2 wr _ = __C::pure_sentry (weak::sentrybox1 wr) x; _ = __C::pure_clear_sentry x end) else x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: get_sentry x = s if ok when ok@_ s = if __C::pure_has_sentry x then (case __C::pure_get_sentry x of weak::sentrybox1 _ = 0 _; weak::sentrybox2 _ s = 1 s; s = 1 s end) else 0 _ end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: cookedp x = if __C::pure_has_sentry x then (case __C::pure_get_sentry x of weak::sentrybox1 _ = 0; _ = 1 end) else 0
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: cooked p::pointer = sentry free p
  state 0: #0
	<var>::pointer state 1
  state 1: #0
}
{
  rule #0: pointer_type x::pointer = pointer_type (get_ptrtag x)
  state 0: #0
	<var>::pointer state 1
  state 1: #0
}
{
  rule #0: pointer_cast ty::string x::pointer = pointer_cast (pointer_tag ty) x
  state 0: #0
	<var>::string state 1
  state 1: #0
	<var>::pointer state 2
  state 2: #0
}
{
  rule #0: pointer_tag x::string = __C::pure_pointer_tag x
  rule #1: pointer_tag x::pointer = get_ptrtag x
  state 0: #0 #1
	<var>::string state 1
	<var>::pointer state 2
  state 1: #0
  state 2: #1
}
const __C::voidp_t = pointer_tag "void*";
const __C::voidpp_t = pointer_tag "void**";
const __C::charp_t = pointer_tag "char*";
const __C::charpp_t = pointer_tag "char**";
const __C::shortp_t = pointer_tag "short*";
const __C::shortpp_t = pointer_tag "short**";
const __C::intp_t = pointer_tag "int*";
const __C::intpp_t = pointer_tag "int**";
const __C::floatp_t = pointer_tag "float*";
const __C::floatpp_t = pointer_tag "float**";
const __C::doublep_t = pointer_tag "double*";
const __C::doublepp_t = pointer_tag "double**";
type ref x/*0:1*/ :: pointer = refp x/*0:1*/;
ref x/*0:1*/ = __C::pointer_put_expr r/*0:*/ (__C::pure_new x/*1:1*/)$$sentry (unref clear_sentry) r/*0:*/ when r/*0:*/ :: pointer = __C::pure_expr_pointer {
  rule #0: r::pointer = __C::pure_expr_pointer
  state 0: #0
	<var>::pointer state 1
  state 1: #0
} end;
unref next/*0:01*/ r/*0:1*/ :: ref = __C::pure_free (__C::pointer_get_expr r/*0:1*/)$$next/*0:01*/ r/*0:1*/;
put r/*0:01*/ :: ref x/*0:1*/ = __C::pure_free (__C::pointer_get_expr r/*0:01*/)$$__C::pointer_put_expr r/*0:01*/ (__C::pure_new x/*0:1*/)$$x/*0:1*/;
get r/*0:1*/ :: ref = __C::pointer_get_expr r/*0:1*/;
refp r/*0:1*/ = case r/*0:1*/ of _/*0:*/ :: pointer = case get_sentry r/*1:1*/ of unref _/*0:1*/ = 1; _/*0:*/ = 0 {
  rule #0: unref _ = 1
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	unref state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
  state 6: #0 #1
} end; _/*0:*/ = 0 {
  rule #0: _::pointer = case get_sentry r of unref _ = 1; _ = 0 end
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::pointer state 2
  state 1: #1
  state 2: #0 #1
} end;
def __std__::__avect__ {} (r/*0:101*/:s/*0:1101*/:t/*0:11101*/:u/*0:111101*/:w/*0:1111101*/:x/*0:11111101*/:y/*0:111111101*/:z/*0:1111111101*/:zs/*0:111111111*/) = __std__::__avect__ (__C::vector8 8 r/*0:101*/ s/*0:1101*/ t/*0:11101*/ u/*0:111101*/ w/*0:1111101*/ x/*0:11111101*/ y/*0:111111101*/ z/*0:1111111101*/) zs/*0:111111111*/;
def __std__::__avect__ {} (s/*0:101*/:t/*0:1101*/:u/*0:11101*/:w/*0:111101*/:x/*0:1111101*/:y/*0:11111101*/:z/*0:111111101*/:zs/*0:11111111*/) = __std__::__avect__ (__C::vector7 7 s/*0:101*/ t/*0:1101*/ u/*0:11101*/ w/*0:111101*/ x/*0:1111101*/ y/*0:11111101*/ z/*0:111111101*/) zs/*0:11111111*/;
def __std__::__avect__ {} (t/*0:101*/:u/*0:1101*/:w/*0:11101*/:x/*0:111101*/:y/*0:1111101*/:z/*0:11111101*/:zs/*0:1111111*/) = __std__::__avect__ (__C::vector6 6 t/*0:101*/ u/*0:1101*/ w/*0:11101*/ x/*0:111101*/ y/*0:1111101*/ z/*0:11111101*/) zs/*0:1111111*/;
def __std__::__avect__ {} (u/*0:101*/:w/*0:1101*/:x/*0:11101*/:y/*0:111101*/:z/*0:1111101*/:zs/*0:111111*/) = __std__::__avect__ (__C::vector5 5 u/*0:101*/ w/*0:1101*/ x/*0:11101*/ y/*0:111101*/ z/*0:1111101*/) zs/*0:111111*/;
def __std__::__avect__ {} (w/*0:101*/:x/*0:1101*/:y/*0:11101*/:z/*0:111101*/:zs/*0:11111*/) = __std__::__avect__ (__C::vector4 4 w/*0:101*/ x/*0:1101*/ y/*0:11101*/ z/*0:111101*/) zs/*0:11111*/;
def __std__::__avect__ {} (x/*0:101*/:y/*0:1101*/:z/*0:11101*/:zs/*0:1111*/) = __std__::__avect__ (__C::vector3 3 x/*0:101*/ y/*0:1101*/ z/*0:11101*/) zs/*0:1111*/;
def __std__::__avect__ {} (y/*0:101*/:z/*0:1101*/:zs/*0:111*/) = __std__::__avect__ (__C::vector2 2 y/*0:101*/ z/*0:1101*/) zs/*0:111*/;
def __std__::__avect__ {} (z/*0:101*/:zs/*0:11*/) = __std__::__avect__ (__C::vector1 1 z/*0:101*/) zs/*0:11*/;
def __std__::__avect__ v/*0:01*/ (r/*0:101*/:s/*0:1101*/:t/*0:11101*/:u/*0:111101*/:w/*0:1111101*/:x/*0:11111101*/:y/*0:111111101*/:z/*0:1111111101*/:zs/*0:111111111*/) = __std__::__avect__ {v/*0:01*/,__C::vector8 8 r/*0:101*/ s/*0:1101*/ t/*0:11101*/ u/*0:111101*/ w/*0:1111101*/ x/*0:11111101*/ y/*0:111111101*/ z/*0:1111111101*/} zs/*0:111111111*/;
def __std__::__avect__ v/*0:01*/ (s/*0:101*/:t/*0:1101*/:u/*0:11101*/:w/*0:111101*/:x/*0:1111101*/:y/*0:11111101*/:z/*0:111111101*/:zs/*0:11111111*/) = __std__::__avect__ {v/*0:01*/,__C::vector7 7 s/*0:101*/ t/*0:1101*/ u/*0:11101*/ w/*0:111101*/ x/*0:1111101*/ y/*0:11111101*/ z/*0:111111101*/} zs/*0:11111111*/;
def __std__::__avect__ v/*0:01*/ (t/*0:101*/:u/*0:1101*/:w/*0:11101*/:x/*0:111101*/:y/*0:1111101*/:z/*0:11111101*/:zs/*0:1111111*/) = __std__::__avect__ {v/*0:01*/,__C::vector6 6 t/*0:101*/ u/*0:1101*/ w/*0:11101*/ x/*0:111101*/ y/*0:1111101*/ z/*0:11111101*/} zs/*0:1111111*/;
def __std__::__avect__ v/*0:01*/ (u/*0:101*/:w/*0:1101*/:x/*0:11101*/:y/*0:111101*/:z/*0:1111101*/:zs/*0:111111*/) = __std__::__avect__ {v/*0:01*/,__C::vector5 5 u/*0:101*/ w/*0:1101*/ x/*0:11101*/ y/*0:111101*/ z/*0:1111101*/} zs/*0:111111*/;
def __std__::__avect__ v/*0:01*/ (w/*0:101*/:x/*0:1101*/:y/*0:11101*/:z/*0:111101*/:zs/*0:11111*/) = __std__::__avect__ {v/*0:01*/,__C::vector4 4 w/*0:101*/ x/*0:1101*/ y/*0:11101*/ z/*0:111101*/} zs/*0:11111*/;
def __std__::__avect__ v/*0:01*/ (x/*0:101*/:y/*0:1101*/:z/*0:11101*/:zs/*0:1111*/) = __std__::__avect__ {v/*0:01*/,__C::vector3 3 x/*0:101*/ y/*0:1101*/ z/*0:11101*/} zs/*0:1111*/;
def __std__::__avect__ v/*0:01*/ (y/*0:101*/:z/*0:1101*/:zs/*0:111*/) = __std__::__avect__ {v/*0:01*/,__C::vector2 2 y/*0:101*/ z/*0:1101*/} zs/*0:111*/;
def __std__::__avect__ v/*0:01*/ (z/*0:101*/:zs/*0:11*/) = __std__::__avect__ {v/*0:01*/,__C::vector1 1 z/*0:101*/} zs/*0:11*/;
def __std__::__avect__ v/*0:01*/ [] = v/*0:01*/;
def __std__::__vect__ xs/*0:1*/ = __std__::__avect__ {} (__list__ xs/*0:1*/);
def {|xs/*0:1*/|} = __std__::__vect__ xs/*0:1*/;
vector1 z/*0:1*/ = __C::vector1 1 z/*0:1*/;
vector2 y/*0:01*/ z/*0:1*/ = __C::vector2 2 y/*0:01*/ z/*0:1*/;
vector3 x/*0:001*/ y/*0:01*/ z/*0:1*/ = __C::vector3 3 x/*0:001*/ y/*0:01*/ z/*0:1*/;
dmatrixp x/*0:1*/ = case x/*0:1*/ of _/*0:*/ :: matrix = matrix_type x/*1:1*/==1; _/*0:*/ = 0 {
  rule #0: _::matrix = matrix_type x==1
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::matrix state 2
  state 1: #1
  state 2: #0 #1
} end;
cmatrixp x/*0:1*/ = case x/*0:1*/ of _/*0:*/ :: matrix = matrix_type x/*1:1*/==2; _/*0:*/ = 0 {
  rule #0: _::matrix = matrix_type x==2
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::matrix state 2
  state 1: #1
  state 2: #0 #1
} end;
imatrixp x/*0:1*/ = case x/*0:1*/ of _/*0:*/ :: matrix = matrix_type x/*1:1*/==3; _/*0:*/ = 0 {
  rule #0: _::matrix = matrix_type x==3
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::matrix state 2
  state 1: #1
  state 2: #0 #1
} end;
nmatrixp x/*0:1*/ = case x/*0:1*/ of _/*0:*/ :: matrix = matrix_type x/*1:1*/>=1; _/*0:*/ = 0 {
  rule #0: _::matrix = matrix_type x>=1
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::matrix state 2
  state 1: #1
  state 2: #0 #1
} end;
smatrixp x/*0:1*/ = case x/*0:1*/ of _/*0:*/ :: matrix = matrix_type x/*1:1*/==0; _/*0:*/ = 0 {
  rule #0: _::matrix = matrix_type x==0
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::matrix state 2
  state 1: #1
  state 2: #0 #1
} end;
type dmatrix = dmatrixp;
type imatrix = imatrixp;
type cmatrix = cmatrixp;
type nmatrix = nmatrixp;
type smatrix = smatrixp;
vectorp x/*0:1*/ = matrixp x/*0:1*/&&(n/*0:01*/==1||m/*0:1*/==1 when n/*0:01*/ :: int,m/*0:1*/ :: int = dim x/*0:1*/ {
  rule #0: n::int,m::int = dim x
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var>::int state 4
  state 4: #0
	<var>::int state 5
  state 5: #0
} end);
rowvectorp x/*0:1*/ = matrixp x/*0:1*/&&dim x/*0:1*/!0==1;
colvectorp x/*0:1*/ = matrixp x/*0:1*/&&dim x/*0:1*/!1==1;
x/*0:01*/ :: matrix==y/*0:1*/ :: matrix = x/*0:01*/===y/*0:1*/ if nmatrixp x/*0:01*/&&matrix_type x/*0:01*/==matrix_type y/*0:1*/;
x/*0:01*/ :: matrix==y/*0:1*/ :: matrix = cmatrix x/*0:01*/===y/*0:1*/ if nmatrixp x/*0:01*/&&cmatrixp y/*0:1*/;
x/*0:01*/ :: matrix==y/*0:1*/ :: matrix = x/*0:01*/===cmatrix y/*0:1*/ if cmatrixp x/*0:01*/&&nmatrixp y/*0:1*/;
x/*0:01*/ :: matrix==y/*0:1*/ :: matrix = dmatrix x/*0:01*/===y/*0:1*/ if imatrixp x/*0:01*/&&dmatrixp y/*0:1*/;
x/*0:01*/ :: matrix==y/*0:1*/ :: matrix = x/*0:01*/===dmatrix y/*0:1*/ if dmatrixp x/*0:01*/&&imatrixp y/*0:1*/;
x/*0:01*/ :: matrix==y/*0:1*/ :: matrix = 0 if dim x/*0:01*/~=dim y/*0:1*/;
x/*0:01*/ :: matrix==y/*0:1*/ :: matrix = compare/*0*/ 0 with compare i/*0:1*/ :: int = 1 if i/*0:1*/>=n/*1:*/; compare i/*0:1*/ :: int = 0 if x/*2:01*/!i/*0:1*/~=y/*2:1*/!i/*0:1*/; compare i/*0:1*/ :: int = compare/*1*/ (i/*0:1*/+1) {
  rule #0: compare i::int = 1 if i>=n
  rule #1: compare i::int = 0 if x!i~=y!i
  rule #2: compare i::int = compare (i+1)
  state 0: #0 #1 #2
	<var>::int state 1
  state 1: #0 #1 #2
} end when n/*0:*/ :: int = #x/*0:01*/ {
  rule #0: n::int = #x
  state 0: #0
	<var>::int state 1
  state 1: #0
} end;
x/*0:01*/ :: matrix~=y/*0:1*/ :: matrix = ~x/*0:01*/==y/*0:1*/;
#x/*0:1*/ :: matrix = __C::matrix_size x/*0:1*/;
dim x/*0:1*/ :: matrix = __C::matrix_dim x/*0:1*/;
null x/*0:1*/ :: matrix = #x/*0:1*/==0;
stride x/*0:1*/ :: matrix = __C::matrix_stride x/*0:1*/;
x/*0:01*/ :: matrix!i/*0:1*/ :: int = __C::matrix_elem_at x/*0:01*/ i/*0:1*/ if i/*0:1*/>=0&&i/*0:1*/<#x/*0:01*/;
x/*0:01*/ :: matrix!i/*0:1*/ :: int = throw out_of_bounds;
x/*0:01*/ :: matrix!(i/*0:101*/ :: int,j/*0:11*/ :: int) = __C::matrix_elem_at2 x/*0:01*/ i/*0:101*/ j/*0:11*/ if (i/*1:101*/>=0&&i/*1:101*/<n/*0:01*/&&j/*1:11*/>=0&&j/*1:11*/<m/*0:1*/ when n/*0:01*/ :: int,m/*0:1*/ :: int = dim x/*0:01*/ {
  rule #0: n::int,m::int = dim x
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var>::int state 4
  state 4: #0
	<var>::int state 5
  state 5: #0
} end);
x/*0:01*/ :: matrix!(i/*0:101*/ :: int,j/*0:11*/ :: int) = throw out_of_bounds;
x/*0:01*/!!ns/*0:1*/ :: matrix = x/*0:01*/!!list ns/*0:1*/;
x/*0:01*/!!(ns/*0:101*/ :: matrix,ms/*0:11*/) = x/*0:01*/!!(list ns/*0:101*/,ms/*0:11*/) if ~tuplep ms/*0:11*/;
x/*0:01*/!!(ns/*0:101*/,ms/*0:11*/ :: matrix) = x/*0:01*/!!(ns/*0:101*/,list ms/*0:11*/);
x/*0:01*/!!(ns/*0:101*/ :: int,ms/*0:11*/) = x/*0:01*/!!([ns/*0:101*/],ms/*0:11*/) if ~tuplep ms/*0:11*/;
x/*0:01*/!!(ns/*0:101*/,ms/*0:11*/ :: int) = x/*0:01*/!!(ns/*0:101*/,[ms/*0:11*/]);
x/*0:01*/ :: matrix!!(ns/*0:101*/,ms/*0:11*/) = case ns/*0:101*/,ms/*0:11*/ of ns@(n/*0:0101*/:_/*0:011*/),ms@(m/*0:101*/:_/*0:11*/) = submat x/*1:01*/ (n/*0:0101*/,m/*0:101*/) (#ns/*0:01*/,#ms/*0:1*/) if cont/*1*/ ns/*0:01*/&&cont/*1*/ ms/*0:1*/; _/*0:*/ = colcatmap (mth/*1*/ (rowcatmap (nth/*1*/ x/*1:01*/) ns/*1:101*/)) ms/*1:11*/ {
  rule #0: ns@(n:_),ms@(m:_) = submat x (n,m) (#ns,#ms) if cont ns&&cont ms
  rule #1: _ = colcatmap (mth (rowcatmap (nth x) ns)) ms
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	, state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #1
	<var> state 11
  state 11: #1
  state 12: #0 #1
	<var> state 13
	<app> state 16
  state 13: #1
	<var> state 14
  state 14: #1
	<var> state 15
  state 15: #1
  state 16: #0 #1
	<var> state 17
	: state 21
  state 17: #1
	<var> state 18
  state 18: #1
	<var> state 19
  state 19: #1
	<var> state 20
  state 20: #1
  state 21: #0 #1
	<var> state 22
  state 22: #0 #1
	<var> state 23
  state 23: #0 #1
	<var> state 24
	<app> state 25
  state 24: #1
  state 25: #0 #1
	<var> state 26
	<app> state 28
  state 26: #1
	<var> state 27
  state 27: #1
  state 28: #0 #1
	<var> state 29
	: state 32
  state 29: #1
	<var> state 30
  state 30: #1
	<var> state 31
  state 31: #1
  state 32: #0 #1
	<var> state 33
  state 33: #0 #1
	<var> state 34
  state 34: #0 #1
} end with cont [n/*0:101*/ :: int] = 1; cont (n/*0:101*/ :: int:ns@(m/*0:1101*/ :: int:_/*0:111*/)) = cont/*1*/ ns/*0:11*/ if m/*0:1101*/==n/*0:101*/+1; cont _/*0:1*/ = 0 {
  rule #0: cont [n::int] = 1
  rule #1: cont (n::int:ns@(m::int:_)) = cont ns if m==n+1
  rule #2: cont _ = 0
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #1 #2
	<var> state 10
	<var>::int state 12
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #0 #1 #2
	<var> state 13
	<app> state 14
	[] state 26
  state 13: #2
  state 14: #1 #2
	<var> state 15
	<app> state 17
  state 15: #2
	<var> state 16
  state 16: #2
  state 17: #1 #2
	<var> state 18
	: state 21
  state 18: #2
	<var> state 19
  state 19: #2
	<var> state 20
  state 20: #2
  state 21: #1 #2
	<var> state 22
	<var>::int state 24
  state 22: #2
	<var> state 23
  state 23: #2
  state 24: #1 #2
	<var> state 25
  state 25: #1 #2
  state 26: #0 #2
}; mth x/*0:01*/ m/*0:1*/ = catch (cst {}) (col x/*1:01*/ m/*1:1*/) {
  rule #0: mth x m = catch (cst {}) (col x m)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}; nth x/*0:01*/ n/*0:1*/ = catch (cst {}) (row x/*1:01*/ n/*1:1*/) {
  rule #0: nth x n = catch (cst {}) (row x n)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
} end;
x/*0:01*/ :: matrix!!ns/*0:1*/ = if all intp ns/*0:1*/&&packed x/*0:01*/ then rowvector x/*0:01*/!!([0],ns/*0:1*/) else colcatmap (nth/*0*/ x/*0:01*/) ns/*0:1*/ with nth x/*0:01*/ n/*0:1*/ = catch (cst {}) {x/*1:01*/!n/*1:1*/} {
  rule #0: nth x n = catch (cst {}) {x!n}
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
} end;
subseq2 x/*0:00001*/ :: matrix a1/*0:0001*/ :: int b1/*0:001*/ :: int a2/*0:01*/ :: int b2/*0:1*/ :: int = __C::matrix_slice x/*0:00001*/ a1/*0:0001*/ a2/*0:01*/ b1/*0:001*/ b2/*0:1*/;
subseq2 x/*0:00001*/ a1/*0:0001*/ a1/*0:001*/ a2/*0:01*/ b2/*0:1*/ = slice x/*0:00001*/ (a1/*0:0001*/,a2/*0:01*/..b2/*0:1*/);
subseq2 x/*0:00001*/ a1/*0:0001*/ b1/*0:001*/ a2/*0:01*/ a2/*0:1*/ = slice x/*0:00001*/ (a1/*0:0001*/..b1/*0:001*/,a2/*0:01*/);
subseq2 x/*0:00001*/ a1/*0:0001*/ b1/*0:001*/ a2/*0:01*/ b2/*0:1*/ = slice x/*0:00001*/ (a1/*0:0001*/..b1/*0:001*/,a2/*0:01*/..b2/*0:1*/);
subseq x/*0:001*/ :: matrix a/*0:01*/ :: int b/*0:1*/ :: int = __C::matrix_slice (rowvector x/*0:001*/) 0 a/*0:01*/ 0 b/*0:1*/;
def x/*0:01*/!!(a1/*0:10101*/..b1/*0:1011*/,a2/*0:1101*/..b2/*0:111*/) = subseq2 x/*0:01*/ a1/*0:10101*/ b1/*0:1011*/ a2/*0:1101*/ b2/*0:111*/;
def x/*0:01*/!!(a1/*0:101*/,a2/*0:1101*/..b2/*0:111*/) = subseq2 x/*0:01*/ a1/*0:101*/ a1/*0:101*/ a2/*0:1101*/ b2/*0:111*/;
def x/*0:01*/!!(a1/*0:10101*/..b1/*0:1011*/,a2/*0:11*/) = subseq2 x/*0:01*/ a1/*0:10101*/ b1/*0:1011*/ a2/*0:11*/ a2/*0:11*/;
row x/*0:01*/ :: matrix i/*0:1*/ :: int = if i/*1:1*/>=0&&i/*1:1*/<n/*0:01*/ then __C::matrix_slice x/*1:01*/ i/*1:1*/ 0 i/*1:1*/ (m/*0:1*/-1) else throw out_of_bounds when n/*0:01*/ :: int,m/*0:1*/ :: int = dim x/*0:01*/ {
  rule #0: n::int,m::int = dim x
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var>::int state 4
  state 4: #0
	<var>::int state 5
  state 5: #0
} end;
col x/*0:01*/ :: matrix j/*0:1*/ :: int = if j/*1:1*/>=0&&j/*1:1*/<m/*0:1*/ then __C::matrix_slice x/*1:01*/ 0 j/*1:1*/ (n/*0:01*/-1) j/*1:1*/ else throw out_of_bounds when n/*0:01*/ :: int,m/*0:1*/ :: int = dim x/*0:01*/ {
  rule #0: n::int,m::int = dim x
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var>::int state 4
  state 4: #0
	<var>::int state 5
  state 5: #0
} end;
rows x/*0:1*/ :: matrix = map (row x/*1:1*/) (0..n/*0:01*/-1) when n/*0:01*/ :: int,_/*0:1*/ = dim x/*0:1*/ {
  rule #0: n::int,_ = dim x
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var>::int state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end;
cols x/*0:1*/ :: matrix = map (col x/*1:1*/) (0..m/*0:1*/-1) when _/*0:01*/,m/*0:1*/ :: int = dim x/*0:1*/ {
  rule #0: _,m::int = dim x
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var>::int state 5
  state 5: #0
} end;
list x/*0:1*/ :: matrix = listmap (\i/*0:1*/ -> x/*1:1*/!i/*0:1*/ {
  rule #0: _ i = x!i
  state 0: #0
	<var> state 1
  state 1: #0
}) (0..#x/*0:1*/-1);
list2 x/*0:1*/ :: matrix = listmap (\i/*0:1*/ -> listmap (\j/*0:1*/ -> x/*3:1*/!(i/*1:1*/,j/*0:1*/) {
  rule #0: _ j = x!(i,j)
  state 0: #0
	<var> state 1
  state 1: #0
}) (0..m/*1:1*/-1) {
  rule #0: _ i = listmap (\j -> x!(i,j)) (0..m-1)
  state 0: #0
	<var> state 1
  state 1: #0
}) (0..n/*0:01*/-1) when n/*0:01*/ :: int,m/*0:1*/ :: int = dim x/*0:1*/ {
  rule #0: n::int,m::int = dim x
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var>::int state 4
  state 4: #0
	<var>::int state 5
  state 5: #0
} end;
matrix [] = {};
matrix xs@(_/*0:101*/:_/*0:11*/) = throw (bad_list_value xs/*0:1*/) if ~rlistp xs/*0:1*/;
matrix xs@(_/*0:101*/:_/*0:11*/) = rowcatmap colcat xs/*0:1*/ if all rlistp xs/*0:1*/;
matrix xs@(_/*0:101*/:_/*0:11*/) = rowcat xs/*0:1*/ if any matrixp xs/*0:1*/;
matrix xs@(_/*0:101*/:_/*0:11*/) = colcat xs/*0:1*/;
tuple x/*0:1*/ :: matrix = tuple (list x/*0:1*/);
matrix () = {};
matrix xs@(_/*0:101*/,_/*0:11*/) = matrix (list xs/*0:1*/);
matrix x/*0:1*/ :: matrix = x/*0:1*/;
dmatrix (n/*0:101*/ :: int,m/*0:11*/ :: int) = double_matrix (n/*0:101*/,m/*0:11*/) #<pointer 0>;
cmatrix (n/*0:101*/ :: int,m/*0:11*/ :: int) = complex_matrix (n/*0:101*/,m/*0:11*/) #<pointer 0>;
imatrix (n/*0:101*/ :: int,m/*0:11*/ :: int) = int_matrix (n/*0:101*/,m/*0:11*/) #<pointer 0>;
dmatrix n/*0:1*/ :: int = dmatrix (1,n/*0:1*/);
cmatrix n/*0:1*/ :: int = cmatrix (1,n/*0:1*/);
imatrix n/*0:1*/ :: int = imatrix (1,n/*0:1*/);
dmatrix x/*0:1*/ = y/*0:*/ if matrixp y/*0:*/ when y/*0:*/ = __C::matrix_double x/*0:1*/ {
  rule #0: y = __C::matrix_double x
  state 0: #0
	<var> state 1
  state 1: #0
} end;
imatrix x/*0:1*/ = y/*0:*/ if matrixp y/*0:*/ when y/*0:*/ = __C::matrix_int x/*0:1*/ {
  rule #0: y = __C::matrix_int x
  state 0: #0
	<var> state 1
  state 1: #0
} end;
cmatrix x/*0:1*/ = y/*0:*/ if matrixp y/*0:*/ when y/*0:*/ = __C::matrix_complex x/*0:1*/ {
  rule #0: y = __C::matrix_complex x
  state 0: #0
	<var> state 1
  state 1: #0
} end;
smatrix x/*0:1*/ = y/*0:*/ if matrixp y/*0:*/ when y/*0:*/ = __C::matrix_symbolic x/*0:1*/ {
  rule #0: y = __C::matrix_symbolic x
  state 0: #0
	<var> state 1
  state 1: #0
} end;
rowvector x/*0:1*/ :: matrix = redim (1,#x/*0:1*/) x/*0:1*/;
colvector x/*0:1*/ :: matrix = redim (#x/*0:1*/,1) x/*0:1*/;
rowvector () = redim (1,0) {};
rowvector xs@(_/*0:101*/,_/*0:11*/) = rowvector (list xs/*0:1*/);
colvector () = redim (0,1) {};
colvector xs@(_/*0:101*/,_/*0:11*/) = colvector (list xs/*0:1*/);
rowvector [] = redim (1,0) {};
rowvector xs/*0:1*/ :: rlist = case cmatrix xs/*0:1*/ of x/*0:*/ :: matrix = x/*0:*/; _/*0:*/ = case dmatrix xs/*1:1*/ of x/*0:*/ :: matrix = x/*0:*/; _/*0:*/ = case imatrix xs/*2:1*/ of x/*0:*/ :: matrix = x/*0:*/; _/*0:*/ = smatrix xs/*3:1*/ {
  rule #0: x::matrix = x
  rule #1: _ = smatrix xs
  state 0: #0 #1
	<var> state 1
	<var>::matrix state 2
  state 1: #1
  state 2: #0 #1
} end {
  rule #0: x::matrix = x
  rule #1: _ = case imatrix xs of x::matrix = x; _ = smatrix xs end
  state 0: #0 #1
	<var> state 1
	<var>::matrix state 2
  state 1: #1
  state 2: #0 #1
} end {
  rule #0: x::matrix = x
  rule #1: _ = case dmatrix xs of x::matrix = x; _ = case imatrix xs of x::matrix = x; _ = smatrix xs end end
  state 0: #0 #1
	<var> state 1
	<var>::matrix state 2
  state 1: #1
  state 2: #0 #1
} end;
colvector xs/*0:1*/ = redim (#x/*0:*/,1) x/*0:*/ if matrixp x/*0:*/ when x/*0:*/ = rowvector xs/*0:1*/ {
  rule #0: x = rowvector xs
  state 0: #0
	<var> state 1
  state 1: #0
} end;
vector xs/*0:1*/ = x/*0:*/ if matrixp x/*0:*/ when x/*0:*/ = rowvector xs/*0:1*/ {
  rule #0: x = rowvector xs
  state 0: #0
	<var> state 1
  state 1: #0
} end;
rowvectorseq n/*0:001*/ :: int m/*0:01*/ :: int s/*0:1*/ :: int = __C::pure_int_rowvect n/*0:001*/ m/*0:01*/ s/*0:1*/;
rowvectorseq n/*0:001*/ :: double m/*0:01*/ :: double s/*0:1*/ :: double = __C::pure_double_rowvect n/*0:001*/ m/*0:01*/ s/*0:1*/;
rowvectorseq n/*0:001*/ :: int m/*0:01*/ :: double s/*0:1*/ :: double = __C::pure_double_rowvect (double n/*0:001*/) (double m/*0:01*/) (double s/*0:1*/);
rowvectorseq n/*0:001*/ :: double m/*0:01*/ :: int s/*0:1*/ :: double = __C::pure_double_rowvect (double n/*0:001*/) (double m/*0:01*/) (double s/*0:1*/);
rowvectorseq n/*0:001*/ :: double m/*0:01*/ :: double s/*0:1*/ :: int = __C::pure_double_rowvect (double n/*0:001*/) (double m/*0:01*/) (double s/*0:1*/);
rowvectorseq n/*0:001*/ :: int m/*0:01*/ :: int s/*0:1*/ :: double = __C::pure_double_rowvect (double n/*0:001*/) (double m/*0:01*/) (double s/*0:1*/);
rowvectorseq n/*0:001*/ :: int m/*0:01*/ :: double s/*0:1*/ :: int = __C::pure_double_rowvect (double n/*0:001*/) (double m/*0:01*/) (double s/*0:1*/);
rowvectorseq n/*0:001*/ :: double m/*0:01*/ :: int s/*0:1*/ :: int = __C::pure_double_rowvect (double n/*0:001*/) (double m/*0:01*/) (double s/*0:1*/);
rowvectorseq n/*0:001*/ m/*0:01*/ s/*0:1*/ = x/*0:*/ if matrixp x/*0:*/ when x/*0:*/ = rowvector (n/*0:001*/:n/*0:001*/+s/*0:1*/..m/*0:01*/) {
  rule #0: x = rowvector (n:n+s..m)
  state 0: #0
	<var> state 1
  state 1: #0
} end;
colvectorseq n/*0:001*/ :: int m/*0:01*/ :: int s/*0:1*/ :: int = __C::pure_int_colvect n/*0:001*/ m/*0:01*/ s/*0:1*/;
colvectorseq n/*0:001*/ :: double m/*0:01*/ :: double s/*0:1*/ :: double = __C::pure_double_colvect n/*0:001*/ m/*0:01*/ s/*0:1*/;
colvectorseq n/*0:001*/ :: int m/*0:01*/ :: double s/*0:1*/ :: double = __C::pure_double_colvect (double n/*0:001*/) (double m/*0:01*/) (double s/*0:1*/);
colvectorseq n/*0:001*/ :: double m/*0:01*/ :: int s/*0:1*/ :: double = __C::pure_double_colvect (double n/*0:001*/) (double m/*0:01*/) (double s/*0:1*/);
colvectorseq n/*0:001*/ :: double m/*0:01*/ :: double s/*0:1*/ :: int = __C::pure_double_colvect (double n/*0:001*/) (double m/*0:01*/) (double s/*0:1*/);
colvectorseq n/*0:001*/ :: int m/*0:01*/ :: int s/*0:1*/ :: double = __C::pure_double_colvect (double n/*0:001*/) (double m/*0:01*/) (double s/*0:1*/);
colvectorseq n/*0:001*/ :: int m/*0:01*/ :: double s/*0:1*/ :: int = __C::pure_double_colvect (double n/*0:001*/) (double m/*0:01*/) (double s/*0:1*/);
colvectorseq n/*0:001*/ :: double m/*0:01*/ :: int s/*0:1*/ :: int = __C::pure_double_colvect (double n/*0:001*/) (double m/*0:01*/) (double s/*0:1*/);
colvectorseq n/*0:001*/ m/*0:01*/ s/*0:1*/ = x/*0:*/ if matrixp x/*0:*/ when x/*0:*/ = colvector (n/*0:001*/:n/*0:001*/+s/*0:1*/..m/*0:01*/) {
  rule #0: x = colvector (n:n+s..m)
  state 0: #0
	<var> state 1
  state 1: #0
} end;
vectorseq n/*0:001*/ m/*0:01*/ s/*0:1*/ = x/*0:*/ if matrixp x/*0:*/ when x/*0:*/ = rowvectorseq n/*0:001*/ m/*0:01*/ s/*0:1*/ {
  rule #0: x = rowvectorseq n m s
  state 0: #0
	<var> state 1
  state 1: #0
} end;
def rowvector (n1/*0:10101*/:n2/*0:1011*/..m/*0:11*/) = rowvectorseq n1/*0:10101*/ m/*0:11*/ (n2/*0:1011*/-n1/*0:10101*/);
def rowvector (n/*0:101*/..m/*0:11*/) = rowvectorseq n/*0:101*/ m/*0:11*/ 1;
def colvector (n1/*0:10101*/:n2/*0:1011*/..m/*0:11*/) = colvectorseq n1/*0:10101*/ m/*0:11*/ (n2/*0:1011*/-n1/*0:10101*/);
def colvector (n/*0:101*/..m/*0:11*/) = colvectorseq n/*0:101*/ m/*0:11*/ 1;
def vector (n1/*0:10101*/:n2/*0:1011*/..m/*0:11*/) = vectorseq n1/*0:10101*/ m/*0:11*/ (n2/*0:1011*/-n1/*0:10101*/);
def vector (n/*0:101*/..m/*0:11*/) = vectorseq n/*0:101*/ m/*0:11*/ 1;
submat x/*0:001*/ :: matrix (i/*0:0101*/ :: int,j/*0:011*/ :: int) (n/*0:101*/ :: int,m/*0:11*/ :: int) = __C::matrix_slice x/*0:001*/ i/*0:0101*/ j/*0:011*/ (i/*0:0101*/+n/*0:101*/-1) (j/*0:011*/+m/*0:11*/-1);
rowcatmap f/*0:01*/ [] = {};
rowcatmap f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = rowcat (map f/*0:01*/ xs/*0:1*/);
colcatmap f/*0:01*/ [] = {};
colcatmap f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = colcat (map f/*0:01*/ xs/*0:1*/);
rowmap f/*0:01*/ [] = {};
rowmap f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = rowcat (map f/*0:01*/ xs/*0:1*/);
colmap f/*0:01*/ [] = {};
colmap f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = colcat (map f/*0:01*/ xs/*0:1*/);
re x/*0:1*/ :: matrix = __C::matrix_re x/*0:1*/ if nmatrixp x/*0:1*/;
im x/*0:1*/ :: matrix = __C::matrix_im x/*0:1*/ if nmatrixp x/*0:1*/;
conj x/*0:1*/ :: matrix = __C::matrix_conj x/*0:1*/ if nmatrixp x/*0:1*/;
pack x/*0:1*/ :: matrix = colcat [x/*0:1*/,{}];
packed x/*0:1*/ :: matrix = stride x/*0:1*/==dim x/*0:1*/!1;
redim (n/*0:0101*/ :: int,m/*0:011*/ :: int) x/*0:1*/ :: matrix = __C::matrix_redim x/*0:1*/ n/*0:0101*/ m/*0:011*/ if n/*0:0101*/>=0&&m/*0:011*/>=0&&n/*0:0101*/*m/*0:011*/==#x/*0:1*/;
redim m/*0:01*/ :: int x/*0:1*/ :: matrix = redim (#x/*0:1*/ div m/*0:01*/,m/*0:01*/) x/*0:1*/ if m/*0:01*/>0&&#x/*0:1*/ mod m/*0:01*/==0;
redim m/*0:01*/ :: int x/*0:1*/ :: matrix = x/*0:1*/ if m/*0:01*/==0&&#x/*0:1*/==0;
sort p/*0:01*/ x/*0:1*/ :: matrix = case sort p/*0:01*/ (smatrix x/*0:1*/) of y/*0:*/ :: matrix = imatrix y/*0:*/ if imatrixp x/*1:1*/; y/*0:*/ :: matrix = dmatrix y/*0:*/ if dmatrixp x/*1:1*/; y/*0:*/ :: matrix = cmatrix y/*0:*/ if cmatrixp x/*1:1*/; y/*0:*/ = y/*0:*/ {
  rule #0: y::matrix = imatrix y if imatrixp x
  rule #1: y::matrix = dmatrix y if dmatrixp x
  rule #2: y::matrix = cmatrix y if cmatrixp x
  rule #3: y = y
  state 0: #0 #1 #2 #3
	<var> state 1
	<var>::matrix state 2
  state 1: #3
  state 2: #0 #1 #2 #3
} end;
transpose x/*0:1*/ :: matrix = __C::matrix_transpose x/*0:1*/;
rowrev x/*0:1*/ :: matrix = rowcat (__std__::reverse_onto [] (rows x/*0:1*/));
colrev x/*0:1*/ :: matrix = colcat (__std__::reverse_onto [] (cols x/*0:1*/));
reverse x/*0:1*/ :: matrix = rowrev (colrev x/*0:1*/);
catmap f/*0:01*/ x/*0:1*/ :: matrix = cat (list (map f/*0:01*/ x/*0:1*/));
rowcatmap f/*0:01*/ x/*0:1*/ :: matrix = matcat (map f/*0:01*/ x/*0:1*/);
colcatmap f/*0:01*/ x/*0:1*/ :: matrix = matcat (map f/*0:01*/ x/*0:1*/);
listmap f/*0:01*/ x/*0:1*/ :: matrix = list (map f/*0:01*/ x/*0:1*/);
rowmap f/*0:01*/ x/*0:1*/ :: matrix = map f/*0:01*/ x/*0:1*/;
colmap f/*0:01*/ x/*0:1*/ :: matrix = map f/*0:01*/ x/*0:1*/;
cycle x/*0:1*/ :: matrix = cycle (list x/*0:1*/);
cyclen n/*0:01*/ :: int x/*0:1*/ :: matrix = cyclen n/*0:01*/ (list x/*0:1*/) if ~null x/*0:1*/;
all p/*0:01*/ x/*0:1*/ :: matrix = __C::matrix_all p/*0:01*/ x/*0:1*/;
any p/*0:01*/ x/*0:1*/ :: matrix = __C::matrix_any p/*0:01*/ x/*0:1*/;
do f/*0:01*/ x/*0:1*/ :: matrix = __C::matrix_do f/*0:01*/ x/*0:1*/;
drop k/*0:01*/ :: int x/*0:1*/ :: matrix = x/*0:1*/!!(k/*0:01*/..#x/*0:1*/-1);
dropwhile p/*0:01*/ x/*0:1*/ :: matrix = __C::matrix_dropwhile p/*0:01*/ x/*0:1*/;
filter p/*0:01*/ x/*0:1*/ :: matrix = __C::matrix_filter p/*0:01*/ x/*0:1*/;
foldl f/*0:001*/ a/*0:01*/ x/*0:1*/ :: matrix = __C::matrix_foldl f/*0:001*/ a/*0:01*/ x/*0:1*/;
foldl1 f/*0:01*/ x/*0:1*/ :: matrix = __C::matrix_foldl1 f/*0:01*/ x/*0:1*/ if ~null x/*0:1*/;
foldr f/*0:001*/ a/*0:01*/ x/*0:1*/ :: matrix = __C::matrix_foldr f/*0:001*/ a/*0:01*/ x/*0:1*/;
foldr1 f/*0:01*/ x/*0:1*/ :: matrix = __C::matrix_foldr1 f/*0:01*/ x/*0:1*/ if ~null x/*0:1*/;
head x/*0:1*/ :: matrix = x/*0:1*/!0 if ~null x/*0:1*/;
init x/*0:1*/ :: matrix = x/*0:1*/!!(0..#x/*0:1*/-2) if ~null x/*0:1*/;
last x/*0:1*/ :: matrix = x/*0:1*/!(#x/*0:1*/-1) if ~null x/*0:1*/;
map f/*0:01*/ x/*0:1*/ :: matrix = __C::matrix_map f/*0:01*/ x/*0:1*/;
scanl f/*0:001*/ a/*0:01*/ x/*0:1*/ :: matrix = __C::matrix_scanl f/*0:001*/ a/*0:01*/ x/*0:1*/;
scanl1 f/*0:01*/ x/*0:1*/ :: matrix = __C::matrix_scanl1 f/*0:01*/ x/*0:1*/;
scanr f/*0:001*/ a/*0:01*/ x/*0:1*/ :: matrix = __C::matrix_scanr f/*0:001*/ a/*0:01*/ x/*0:1*/;
scanr1 f/*0:01*/ x/*0:1*/ :: matrix = __C::matrix_scanr1 f/*0:01*/ x/*0:1*/;
take k/*0:01*/ :: int x/*0:1*/ :: matrix = x/*0:1*/!!(0..k/*0:01*/-1);
takewhile p/*0:01*/ x/*0:1*/ :: matrix = __C::matrix_takewhile p/*0:01*/ x/*0:1*/;
tail x/*0:1*/ :: matrix = x/*0:1*/!!(1..#x/*0:1*/-1) if ~null x/*0:1*/;
zipwith f/*0:001*/ x/*0:01*/ :: matrix y/*0:1*/ :: matrix = __C::matrix_zipwith f/*0:001*/ x/*0:01*/ y/*0:1*/;
zipwith3 f/*0:0001*/ x/*0:001*/ :: matrix y/*0:01*/ :: matrix z/*0:1*/ :: matrix = __C::matrix_zipwith3 f/*0:0001*/ x/*0:001*/ y/*0:01*/ z/*0:1*/;
zip x/*0:01*/ :: matrix y/*0:1*/ :: matrix = zipwith (,) x/*0:01*/ y/*0:1*/;
zip3 x/*0:001*/ :: matrix y/*0:01*/ :: matrix z/*0:1*/ :: matrix = zipwith3 (\x/*0:001*/ y/*0:01*/ z/*0:1*/ -> x/*0:001*/,y/*0:01*/,z/*0:1*/ {
  rule #0: _ x y z = x,y,z
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}) x/*0:001*/ y/*0:01*/ z/*0:1*/;
dowith f/*0:001*/ x/*0:01*/ :: matrix y/*0:1*/ :: matrix = do (uncurry f/*0:001*/) (zip x/*0:01*/ y/*0:1*/);
dowith3 f/*0:0001*/ x/*0:001*/ :: matrix y/*0:01*/ :: matrix z/*0:1*/ :: matrix = do (uncurry3 f/*0:0001*/) (zip3 x/*0:001*/ y/*0:01*/ z/*0:1*/);
unzip x/*0:1*/ :: matrix = colmap (\(u/*0:101*/,_/*0:11*/) -> u/*0:101*/ {
  rule #0: _ (u,_) = u
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}) x/*0:1*/,colmap (\(_/*0:101*/,v/*0:11*/) -> v/*0:11*/ {
  rule #0: _ (_,v) = v
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}) x/*0:1*/ if all check/*0*/ x/*0:1*/ with check (_/*0:101*/,_/*0:11*/) = 1; check x/*0:1*/ = throw (bad_tuple_value x/*0:1*/) {
  rule #0: check (_,_) = 1
  rule #1: check x = throw (bad_tuple_value x)
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	, state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
} end;
unzip3 x/*0:1*/ :: matrix = colmap (\(u/*0:101*/,_/*0:11*/) -> u/*0:101*/ {
  rule #0: _ (u,_) = u
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}) x/*0:1*/,colmap (\(_/*0:101*/,v/*0:1101*/,_/*0:111*/) -> v/*0:1101*/ {
  rule #0: _ (_,v,_) = v
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	, state 7
  state 7: #0
	<var> state 8
  state 8: #0
	<var> state 9
  state 9: #0
}) x/*0:1*/,colmap (\(_/*0:101*/,_/*0:1101*/,w/*0:111*/) -> w/*0:111*/ {
  rule #0: _ (_,_,w) = w
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	, state 7
  state 7: #0
	<var> state 8
  state 8: #0
	<var> state 9
  state 9: #0
}) x/*0:1*/ if all check/*0*/ x/*0:1*/ with check (_/*0:101*/,_/*0:1101*/,_/*0:111*/) = 1; check x/*0:1*/ = throw (bad_tuple_value x/*0:1*/) {
  rule #0: check (_,_,_) = 1
  rule #1: check x = throw (bad_tuple_value x)
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	, state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
	<app> state 12
  state 11: #1
  state 12: #0 #1
	<var> state 13
	<app> state 15
  state 13: #1
	<var> state 14
  state 14: #1
  state 15: #0 #1
	<var> state 16
	, state 19
  state 16: #1
	<var> state 17
  state 17: #1
	<var> state 18
  state 18: #1
  state 19: #0 #1
	<var> state 20
  state 20: #0 #1
	<var> state 21
  state 21: #0 #1
} end;
pointer x/*0:1*/ :: matrix = __C::pure_pointerval x/*0:1*/;
double_pointer p/*0:01*/ :: pointer x/*0:1*/ :: matrix = __C::matrix_to_double_array p/*0:01*/ x/*0:1*/ if nmatrixp x/*0:1*/;
float_pointer p/*0:01*/ :: pointer x/*0:1*/ :: matrix = __C::matrix_to_float_array p/*0:01*/ x/*0:1*/ if nmatrixp x/*0:1*/;
complex_pointer p/*0:01*/ :: pointer x/*0:1*/ :: matrix = __C::matrix_to_complex_array p/*0:01*/ x/*0:1*/ if nmatrixp x/*0:1*/;
complex_float_pointer p/*0:01*/ :: pointer x/*0:1*/ :: matrix = __C::matrix_to_complex_float_array p/*0:01*/ x/*0:1*/ if nmatrixp x/*0:1*/;
int_pointer p/*0:01*/ :: pointer x/*0:1*/ :: matrix = __C::matrix_to_int_array p/*0:01*/ x/*0:1*/ if nmatrixp x/*0:1*/;
short_pointer p/*0:01*/ :: pointer x/*0:1*/ :: matrix = __C::matrix_to_short_array p/*0:01*/ x/*0:1*/ if nmatrixp x/*0:1*/;
byte_pointer p/*0:01*/ :: pointer x/*0:1*/ :: matrix = __C::matrix_to_byte_array p/*0:01*/ x/*0:1*/ if nmatrixp x/*0:1*/;
double_matrix (n/*0:0101*/ :: int,m/*0:011*/ :: int) p/*0:1*/ :: pointer = __C::matrix_from_double_array n/*0:0101*/ m/*0:011*/ p/*0:1*/;
float_matrix (n/*0:0101*/ :: int,m/*0:011*/ :: int) p/*0:1*/ :: pointer = __C::matrix_from_float_array n/*0:0101*/ m/*0:011*/ p/*0:1*/;
complex_matrix (n/*0:0101*/ :: int,m/*0:011*/ :: int) p/*0:1*/ :: pointer = __C::matrix_from_complex_array n/*0:0101*/ m/*0:011*/ p/*0:1*/;
complex_float_matrix (n/*0:0101*/ :: int,m/*0:011*/ :: int) p/*0:1*/ :: pointer = __C::matrix_from_complex_float_array n/*0:0101*/ m/*0:011*/ p/*0:1*/;
int_matrix (n/*0:0101*/ :: int,m/*0:011*/ :: int) p/*0:1*/ :: pointer = __C::matrix_from_int_array n/*0:0101*/ m/*0:011*/ p/*0:1*/;
short_matrix (n/*0:0101*/ :: int,m/*0:011*/ :: int) p/*0:1*/ :: pointer = __C::matrix_from_short_array n/*0:0101*/ m/*0:011*/ p/*0:1*/;
byte_matrix (n/*0:0101*/ :: int,m/*0:011*/ :: int) p/*0:1*/ :: pointer = __C::matrix_from_byte_array n/*0:0101*/ m/*0:011*/ p/*0:1*/;
double_matrix n/*0:01*/ :: int p/*0:1*/ :: pointer = double_matrix (1,n/*0:01*/) p/*0:1*/;
float_matrix n/*0:01*/ :: int p/*0:1*/ :: pointer = float_matrix (1,n/*0:01*/) p/*0:1*/;
complex_matrix n/*0:01*/ :: int p/*0:1*/ :: pointer = complex_matrix (1,n/*0:01*/) p/*0:1*/;
complex_float_matrix n/*0:01*/ :: int p/*0:1*/ :: pointer = complex_float_matrix (1,n/*0:01*/) p/*0:1*/;
int_matrix n/*0:01*/ :: int p/*0:1*/ :: pointer = int_matrix (1,n/*0:01*/) p/*0:1*/;
short_matrix n/*0:01*/ :: int p/*0:1*/ :: pointer = short_matrix (1,n/*0:01*/) p/*0:1*/;
byte_matrix n/*0:01*/ :: int p/*0:1*/ :: pointer = byte_matrix (1,n/*0:01*/) p/*0:1*/;
double_matrix_view (n/*0:0101*/ :: int,m/*0:011*/ :: int) p/*0:1*/ :: pointer = __C::matrix_from_double_array_nodup n/*0:0101*/ m/*0:011*/ p/*0:1*/;
complex_matrix_view (n/*0:0101*/ :: int,m/*0:011*/ :: int) p/*0:1*/ :: pointer = __C::matrix_from_complex_array_nodup n/*0:0101*/ m/*0:011*/ p/*0:1*/;
int_matrix_view (n/*0:0101*/ :: int,m/*0:011*/ :: int) p/*0:1*/ :: pointer = __C::matrix_from_int_array_nodup n/*0:0101*/ m/*0:011*/ p/*0:1*/;
double_matrix_view n/*0:01*/ :: int p/*0:1*/ :: pointer = double_matrix_view (1,n/*0:01*/) p/*0:1*/;
complex_matrix_view n/*0:01*/ :: int p/*0:1*/ :: pointer = complex_matrix_view (1,n/*0:01*/) p/*0:1*/;
int_matrix_view n/*0:01*/ :: int p/*0:1*/ :: pointer = int_matrix_view (1,n/*0:01*/) p/*0:1*/;
__C::record_elem_at x/*0:01*/ y/*0:1*/ = throw out_of_bounds;
recordp x/*0:1*/ = __C::record_check x/*0:1*/;
type record = recordp;
record x/*0:1*/ = __C::record_pack x/*0:1*/ if recordp x/*0:1*/;
record x/*0:1*/ = record x/*0:*/ if recordp x/*0:*/ when x/*0:*/ = matrix x/*0:1*/ {
  rule #0: x = matrix x
  state 0: #0
	<var> state 1
  state 1: #0
} end;
member x/*0:01*/ :: matrix y/*0:1*/ = __C::record_member x/*0:01*/ y/*0:1*/ if recordp x/*0:01*/;
x/*0:01*/ :: matrix!y/*0:1*/ = __C::record_elem_at x/*0:01*/ y/*0:1*/ if recordp x/*0:01*/;
insert x/*0:01*/ :: matrix (y/*0:101*/=>z/*0:11*/) = __C::record_update x/*0:01*/ y/*0:101*/ z/*0:11*/ if recordp x/*0:01*/;
update x/*0:001*/ :: matrix y/*0:01*/ z/*0:1*/ = __C::record_update x/*0:001*/ y/*0:01*/ z/*0:1*/ if recordp x/*0:001*/;
delete x/*0:01*/ :: matrix y/*0:1*/ = __C::record_delete x/*0:01*/ y/*0:1*/ if recordp x/*0:01*/;
keys x/*0:1*/ :: matrix = colmap (\(u/*0:101*/=>v/*0:11*/) -> u/*0:101*/ {
  rule #0: _ (u=>v) = u
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	=> state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}) x/*0:1*/ if recordp x/*0:1*/;
vals x/*0:1*/ :: matrix = colmap (\(u/*0:101*/=>v/*0:11*/) -> v/*0:11*/ {
  rule #0: _ (u=>v) = v
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	=> state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}) x/*0:1*/ if recordp x/*0:1*/;
chr n/*0:1*/ :: int = c/*0:*/ if stringp c/*0:*/ when c/*0:*/ = __C::string_chr n/*0:1*/ {
  rule #0: c = __C::string_chr n
  state 0: #0
	<var> state 1
  state 1: #0
} end;
ord s/*0:1*/ :: string = n/*0:*/ if intp n/*0:*/ when n/*0:*/ = __C::string_ord s/*0:1*/ {
  rule #0: n = __C::string_ord s
  state 0: #0
	<var> state 1
  state 1: #0
} end;
a/*0:01*/ :: string..b/*0:1*/ :: string = map chr (ord a/*0:01*/..ord b/*0:1*/) if charp a/*0:01*/&&charp b/*0:1*/;
a/*0:0101*/ :: string:b/*0:011*/ :: string..c/*0:1*/ :: string = map chr (ord a/*0:0101*/:ord b/*0:011*/..ord c/*0:1*/) if charp a/*0:0101*/&&charp b/*0:011*/&&charp c/*0:1*/;
string s/*0:1*/ :: pointer = __C::pure_string s/*0:1*/;
cstring s/*0:1*/ :: pointer = __C::pure_cstring s/*0:1*/;
string_dup s/*0:1*/ :: pointer = __C::pure_string_dup s/*0:1*/;
cstring_dup s/*0:1*/ :: pointer = __C::pure_cstring_dup s/*0:1*/;
byte_string s/*0:1*/ :: string = ptrtag 1$__C::pure_byte_string s/*0:1*/;
byte_cstring s/*0:1*/ :: string = ptrtag 1$__C::pure_byte_cstring s/*0:1*/;
byte_string_pointer xs/*0:1*/ = if null p/*1:*/ then throw malloc_error else make_pointer/*0*/ (map byte_string xs/*0:*/) with make_pointer xs/*0:1*/ = ptrtag 3$sentry free_pointer/*1*/ p/*2:*/ when dowith (\i/*0:01*/ x/*0:1*/ -> put_pointer (shift_pointer/*2*/ p/*3:*/ i/*0:01*/) x/*0:1*/ {
  rule #0: _ i x = put_pointer (shift_pointer p i) x
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}) (0..n/*3:*/-1) xs/*0:1*/ {
  rule #0: _ = dowith (\i x -> put_pointer (shift_pointer p i) x) (0..n-1) xs
  state 0: #0
	<var> state 1
  state 1: #0
} end {
  rule #0: make_pointer xs = ptrtag 3$sentry free_pointer p when dowith (\i x -> put_pointer (shift_pointer p i) x) (0..n-1) xs end
  state 0: #0
	<var> state 1
  state 1: #0
}; free_pointer p/*0:1*/ = free p/*0:1*/ when do (\i/*0:1*/ -> free (get_pointer (shift_pointer/*2*/ p/*1:1*/ i/*0:1*/)) {
  rule #0: _ i = free (get_pointer (shift_pointer p i))
  state 0: #0
	<var> state 1
  state 1: #0
}) (0..n/*3:*/-1) {
  rule #0: _ = do (\i -> free (get_pointer (shift_pointer p i))) (0..n-1)
  state 0: #0
	<var> state 1
  state 1: #0
} end {
  rule #0: free_pointer p = free p when do (\i -> free (get_pointer (shift_pointer p i))) (0..n-1) end
  state 0: #0
	<var> state 1
  state 1: #0
}; shift_pointer p/*0:01*/ i/*0:1*/ = pointer (__C::pure_bigintval p/*0:01*/+i/*0:1*/*8) {
  rule #0: shift_pointer p i = pointer (__C::pure_bigintval p+i*8)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
} end when n/*0:*/ = #xs/*0:1*/; p/*0:*/ = calloc (n/*0:*/+1) 8; xs/*0:*/ = if smatrixp xs/*2:1*/ then list xs/*2:1*/ else xs/*2:1*/ {
  rule #0: xs = if smatrixp xs then list xs else xs
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: p = calloc (n+1) 8
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: n = #xs
  state 0: #0
	<var> state 1
  state 1: #0
} end if (rlistp xs/*0:1*/||smatrixp xs/*0:1*/)&&all stringp xs/*0:1*/;
byte_cstring_pointer xs/*0:1*/ = if null p/*1:*/ then throw malloc_error else make_pointer/*0*/ (map byte_cstring xs/*0:*/) with make_pointer xs/*0:1*/ = ptrtag 3$sentry free_pointer/*1*/ p/*2:*/ when dowith (\i/*0:01*/ x/*0:1*/ -> put_pointer (shift_pointer/*2*/ p/*3:*/ i/*0:01*/) x/*0:1*/ {
  rule #0: _ i x = put_pointer (shift_pointer p i) x
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}) (0..n/*3:*/-1) xs/*0:1*/ {
  rule #0: _ = dowith (\i x -> put_pointer (shift_pointer p i) x) (0..n-1) xs
  state 0: #0
	<var> state 1
  state 1: #0
} end {
  rule #0: make_pointer xs = ptrtag 3$sentry free_pointer p when dowith (\i x -> put_pointer (shift_pointer p i) x) (0..n-1) xs end
  state 0: #0
	<var> state 1
  state 1: #0
}; free_pointer p/*0:1*/ = free p/*0:1*/ when do (\i/*0:1*/ -> free (get_pointer (shift_pointer/*2*/ p/*1:1*/ i/*0:1*/)) {
  rule #0: _ i = free (get_pointer (shift_pointer p i))
  state 0: #0
	<var> state 1
  state 1: #0
}) (0..n/*3:*/-1) {
  rule #0: _ = do (\i -> free (get_pointer (shift_pointer p i))) (0..n-1)
  state 0: #0
	<var> state 1
  state 1: #0
} end {
  rule #0: free_pointer p = free p when do (\i -> free (get_pointer (shift_pointer p i))) (0..n-1) end
  state 0: #0
	<var> state 1
  state 1: #0
}; shift_pointer p/*0:01*/ i/*0:1*/ = pointer (__C::pure_bigintval p/*0:01*/+i/*0:1*/*8) {
  rule #0: shift_pointer p i = pointer (__C::pure_bigintval p+i*8)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
} end when n/*0:*/ = #xs/*0:1*/; p/*0:*/ = calloc (n/*0:*/+1) 8; xs/*0:*/ = if smatrixp xs/*2:1*/ then list xs/*2:1*/ else xs/*2:1*/ {
  rule #0: xs = if smatrixp xs then list xs else xs
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: p = calloc (n+1) 8
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: n = #xs
  state 0: #0
	<var> state 1
  state 1: #0
} end if (rlistp xs/*0:1*/||smatrixp xs/*0:1*/)&&all stringp xs/*0:1*/;
string_list n/*0:01*/ p/*0:1*/ :: pointer = list$takewhile stringp (listmap (\i/*0:1*/ -> p/*1:1*/!/*1*/i/*0:1*/ {
  rule #0: _ i = p!i
  state 0: #0
	<var> state 1
  state 1: #0
}) (0..n/*0:01*/-1)) with p/*0:01*/!i/*0:1*/ = if null q/*0:*/ then q/*0:*/ else string_dup q/*0:*/ when q/*0:*/ = get_pointer (shift_pointer/*1*/ p/*0:01*/ i/*0:1*/) {
  rule #0: q = get_pointer (shift_pointer p i)
  state 0: #0
	<var> state 1
  state 1: #0
} end {
  rule #0: p!i = if null q then q else string_dup q when q = get_pointer (shift_pointer p i) end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}; shift_pointer p/*0:01*/ i/*0:1*/ = pointer (__C::pure_bigintval p/*0:01*/+i/*0:1*/*8) {
  rule #0: shift_pointer p i = pointer (__C::pure_bigintval p+i*8)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
} end if ~null p/*0:1*/&&(intp n/*0:01*/||infp n/*0:01*/);
string_vector n/*0:01*/ p/*0:1*/ :: pointer = vector xs/*0:*/ if listp xs/*0:*/ when xs/*0:*/ = string_list n/*0:01*/ p/*0:1*/ {
  rule #0: xs = string_list n p
  state 0: #0
	<var> state 1
  state 1: #0
} end;
cstring_list n/*0:01*/ p/*0:1*/ :: pointer = list$takewhile stringp (listmap (\i/*0:1*/ -> p/*1:1*/!/*1*/i/*0:1*/ {
  rule #0: _ i = p!i
  state 0: #0
	<var> state 1
  state 1: #0
}) (0..n/*0:01*/-1)) with p/*0:01*/!i/*0:1*/ = if null q/*0:*/ then q/*0:*/ else cstring_dup q/*0:*/ when q/*0:*/ = get_pointer (shift_pointer/*1*/ p/*0:01*/ i/*0:1*/) {
  rule #0: q = get_pointer (shift_pointer p i)
  state 0: #0
	<var> state 1
  state 1: #0
} end {
  rule #0: p!i = if null q then q else cstring_dup q when q = get_pointer (shift_pointer p i) end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}; shift_pointer p/*0:01*/ i/*0:1*/ = pointer (__C::pure_bigintval p/*0:01*/+i/*0:1*/*8) {
  rule #0: shift_pointer p i = pointer (__C::pure_bigintval p+i*8)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
} end if ~null p/*0:1*/&&(intp n/*0:01*/||infp n/*0:01*/);
cstring_vector n/*0:01*/ p/*0:1*/ :: pointer = vector xs/*0:*/ if listp xs/*0:*/ when xs/*0:*/ = cstring_list n/*0:01*/ p/*0:1*/ {
  rule #0: xs = cstring_list n p
  state 0: #0
	<var> state 1
  state 1: #0
} end;
s/*0:01*/ :: string+n/*0:1*/ :: int = chr (ord s/*0:01*/+n/*0:1*/) if #s/*0:01*/==1;
s/*0:01*/ :: string-n/*0:1*/ :: int = chr (ord s/*0:01*/-n/*0:1*/) if #s/*0:01*/==1&&ord s/*0:01*/>=n/*0:1*/;
s/*0:01*/ :: string-t/*0:1*/ :: string = ord s/*0:01*/-ord t/*0:1*/ if #s/*0:01*/==1&&#t/*0:1*/==1;
null s/*0:1*/ :: string = __C::string_null s/*0:1*/;
#s/*0:1*/ :: string = __C::string_size s/*0:1*/;
s/*0:01*/ :: string!n/*0:1*/ :: int = __C::string_char_at s/*0:01*/ n/*0:1*/ if n/*0:1*/>=0&&n/*0:1*/<#s/*0:01*/;
s/*0:01*/ :: string!n/*0:1*/ :: int = throw out_of_bounds;
s/*0:01*/ :: string+t/*0:1*/ :: string = __C::string_concat s/*0:01*/ t/*0:1*/;
chars s/*0:1*/ :: string = __C::string_chars s/*0:1*/ if ~funp (:);
chars s/*0:1*/ :: string = list (__C::string_chars s/*0:1*/);
x/*0:01*/ :: string<y/*0:1*/ :: string = __C::strcmp x/*0:01*/ y/*0:1*/<0;
x/*0:01*/ :: string>y/*0:1*/ :: string = __C::strcmp x/*0:01*/ y/*0:1*/>0;
x/*0:01*/ :: string<=y/*0:1*/ :: string = __C::strcmp x/*0:01*/ y/*0:1*/<=0;
x/*0:01*/ :: string>=y/*0:1*/ :: string = __C::strcmp x/*0:01*/ y/*0:1*/>=0;
x/*0:01*/ :: string==y/*0:1*/ :: string = __C::strcmp x/*0:01*/ y/*0:1*/==0;
x/*0:01*/ :: string~=y/*0:1*/ :: string = __C::strcmp x/*0:01*/ y/*0:1*/~=0;
substr s/*0:001*/ :: string pos/*0:01*/ :: int size/*0:1*/ :: int = __C::string_substr s/*0:001*/ (max/*0*/ 0 pos/*0:01*/) (max/*0*/ 0 size/*0:1*/) with max x/*0:01*/ y/*0:1*/ = if x/*0:01*/>=y/*0:1*/ then x/*0:01*/ else y/*0:1*/ {
  rule #0: max x y = if x>=y then x else y
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
} end;
index s/*0:01*/ :: string u/*0:1*/ :: string = __C::string_index s/*0:01*/ u/*0:1*/;
s/*0:01*/ :: string!!ns/*0:1*/ = case ns/*0:1*/ of ns@(n/*0:01*/:_/*0:1*/) = substr s/*1:01*/ n/*0:01*/ (count/*1*/ ns/*0:*/) if cont/*1*/ ns/*0:*/; _/*0:*/ = string (chars s/*1:01*/!!ns/*1:1*/) {
  rule #0: ns@(n:_) = substr s n (count ns) if cont ns
  rule #1: _ = string (chars s!!ns)
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	: state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
} end with cont [n/*0:101*/ :: int] = 1; cont (n/*0:101*/ :: int:ns@(m/*0:1101*/ :: int:_/*0:111*/)) = cont/*1*/ ns/*0:11*/ if m/*0:1101*/==n/*0:101*/+1; cont _/*0:1*/ = 0 {
  rule #0: cont [n::int] = 1
  rule #1: cont (n::int:ns@(m::int:_)) = cont ns if m==n+1
  rule #2: cont _ = 0
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #1 #2
	<var> state 10
	<var>::int state 12
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #0 #1 #2
	<var> state 13
	<app> state 14
	[] state 26
  state 13: #2
  state 14: #1 #2
	<var> state 15
	<app> state 17
  state 15: #2
	<var> state 16
  state 16: #2
  state 17: #1 #2
	<var> state 18
	: state 21
  state 18: #2
	<var> state 19
  state 19: #2
	<var> state 20
  state 20: #2
  state 21: #1 #2
	<var> state 22
	<var>::int state 24
  state 22: #2
	<var> state 23
  state 23: #2
  state 24: #1 #2
	<var> state 25
  state 25: #1 #2
  state 26: #0 #2
}; count ns/*0:1*/ = #dropwhile (\n/*0:1*/ :: int -> n/*0:1*/<0 {
  rule #0: _ n::int = n<0
  state 0: #0
	<var>::int state 1
  state 1: #0
}) ns/*0:1*/ {
  rule #0: count ns = #dropwhile (\n::int -> n<0) ns
  state 0: #0
	<var> state 1
  state 1: #0
} end;
subseq s/*0:001*/ :: string a/*0:01*/ :: int b/*0:1*/ :: int = substr s/*0:001*/ a/*0:01*/ (b/*0:1*/-a/*0:01*/+1);
strcat xs/*0:1*/ = s/*0:*/ if stringp s/*0:*/ when s/*0:*/ = __C::string_concat_list xs/*0:1*/ {
  rule #0: s = __C::string_concat_list xs
  state 0: #0
	<var> state 1
  state 1: #0
} end;
join delim/*0:01*/ :: string xs/*0:1*/ = s/*0:*/ if stringp s/*0:*/ when s/*0:*/ = __C::string_join delim/*0:01*/ xs/*0:1*/ {
  rule #0: s = __C::string_join delim xs
  state 0: #0
	<var> state 1
  state 1: #0
} end;
split delim/*0:01*/ :: string s/*0:1*/ :: string = __C::string_split delim/*0:01*/ s/*0:1*/ if ~funp (:);
split delim/*0:01*/ :: string s/*0:1*/ :: string = list (__C::string_split delim/*0:01*/ s/*0:1*/);
list s/*0:1*/ :: string = chars s/*0:1*/;
stream s/*0:1*/ :: string = stream (chars s/*0:1*/);
tuple s/*0:1*/ :: string = tuple (chars s/*0:1*/);
string [] = "";
string xs@(_/*0:101*/ :: string:_/*0:11*/) = strcat xs/*0:1*/ if all stringp xs/*0:1*/;
string () = "";
string xs@(_/*0:101*/ :: string,_/*0:11*/) = strcat xs/*0:*/ if all stringp xs/*0:*/ when xs/*0:*/ = list xs/*0:1*/ {
  rule #0: xs = list xs
  state 0: #0
	<var> state 1
  state 1: #0
} end;
string s/*0:1*/ :: string = s/*0:1*/;
matrix s/*0:1*/ :: string = matrix (chars s/*0:1*/);
string x/*0:1*/ :: matrix = string (list x/*0:1*/) if all stringp x/*0:1*/;
s/*0:01*/ :: string+[] = chars s/*0:01*/;
s/*0:01*/ :: string+xs@(_/*0:101*/:_/*0:11*/) = chars s/*0:01*/+xs/*0:1*/;
[]+s/*0:1*/ :: string = chars s/*0:1*/;
xs@(_/*0:0101*/:_/*0:011*/)+s/*0:1*/ :: string = xs/*0:01*/+chars s/*0:1*/;
reverse s/*0:1*/ :: string = strcat (reverse (chars s/*0:1*/));
reverse_onto b/*0:01*/ :: string s/*0:1*/ :: string = strcat (reverse_onto [b/*0:01*/] (chars s/*0:1*/));
reverse_onto b/*0:01*/ :: string s/*0:1*/ = reverse_onto (chars b/*0:01*/) s/*0:1*/;
reverse_onto b/*0:01*/ s/*0:1*/ :: string = strcat (reverse_onto [b/*0:*/] (chars s/*1:1*/)) if stringp b/*0:*/ when b/*0:*/ = __C::string_concat_list b/*0:01*/ {
  rule #0: b = __C::string_concat_list b
  state 0: #0
	<var> state 1
  state 1: #0
} end;
reverse_onto b/*0:01*/ s/*0:1*/ :: string = reverse_onto b/*0:01*/ (chars s/*0:1*/);
catmap f/*0:01*/ s/*0:1*/ :: string = catmap f/*0:01*/ (chars s/*0:1*/);
catmap_onto f/*0:001*/ b/*0:01*/ :: string s/*0:1*/ :: string = catmap_onto f/*0:001*/ (chars b/*0:01*/) (chars s/*0:1*/);
catmap_onto f/*0:001*/ b/*0:01*/ s/*0:1*/ :: string = catmap_onto f/*0:001*/ b/*0:01*/ (chars s/*0:1*/);
catmap_onto f/*0:001*/ b/*0:01*/ :: string s/*0:1*/ = catmap_onto f/*0:001*/ (chars b/*0:01*/) s/*0:1*/;
rowcatmap f/*0:01*/ s/*0:1*/ :: string = rowcatmap f/*0:01*/ (chars s/*0:1*/);
colcatmap f/*0:01*/ s/*0:1*/ :: string = colcatmap f/*0:01*/ (chars s/*0:1*/);
listmap f/*0:01*/ s/*0:1*/ :: string = map f/*0:01*/ (chars s/*0:1*/);
rowmap f/*0:01*/ s/*0:1*/ :: string = rowmap f/*0:01*/ (chars s/*0:1*/);
colmap f/*0:01*/ s/*0:1*/ :: string = colmap f/*0:01*/ (chars s/*0:1*/);
cycle s/*0:1*/ :: string = cycle (chars s/*0:1*/);
cyclen n/*0:01*/ :: int s/*0:1*/ :: string = cyclen n/*0:01*/ (chars s/*0:1*/) if ~null s/*0:1*/;
all p/*0:01*/ s/*0:1*/ :: string = all p/*0:01*/ (chars s/*0:1*/);
any p/*0:01*/ s/*0:1*/ :: string = any p/*0:01*/ (chars s/*0:1*/);
do f/*0:01*/ s/*0:1*/ :: string = do f/*0:01*/ (chars s/*0:1*/);
drop n/*0:01*/ :: int s/*0:1*/ :: string = substr s/*0:1*/ n/*0:01*/ 2147483647;
dropwhile p/*0:01*/ s/*0:1*/ :: string = strcat (dropwhile p/*0:01*/ (chars s/*0:1*/));
filter p/*0:01*/ s/*0:1*/ :: string = strcat (filter p/*0:01*/ (chars s/*0:1*/));
firstby p/*0:001*/ none/*0:01*/ s/*0:1*/ :: string = firstby p/*0:001*/ none/*0:01*/ (chars s/*0:1*/);
foldl f/*0:001*/ a/*0:01*/ s/*0:1*/ :: string = foldl f/*0:001*/ a/*0:01*/ (chars s/*0:1*/);
foldl1 f/*0:01*/ s/*0:1*/ :: string = foldl1 f/*0:01*/ (chars s/*0:1*/);
foldl2 f/*0:0001*/ a/*0:001*/ s/*0:01*/ :: string t/*0:1*/ :: string = foldl2 f/*0:0001*/ a/*0:001*/ (chars s/*0:01*/) (chars t/*0:1*/);
foldl2 f/*0:0001*/ a/*0:001*/ s/*0:01*/ t/*0:1*/ :: string = foldl2 f/*0:0001*/ a/*0:001*/ s/*0:01*/ (chars t/*0:1*/);
foldl2 f/*0:0001*/ a/*0:001*/ s/*0:01*/ :: string t/*0:1*/ = foldl2 f/*0:0001*/ a/*0:001*/ (chars s/*0:01*/) t/*0:1*/;
foldl3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ :: string = foldl3 f/*0:00001*/ a/*0:0001*/ (chars s/*0:001*/) (chars t/*0:01*/) (chars u/*0:1*/);
foldl3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ = foldl3 f/*0:00001*/ a/*0:0001*/ (chars s/*0:001*/) (chars t/*0:01*/) u/*0:1*/;
foldl3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ :: string = foldl3 f/*0:00001*/ a/*0:0001*/ (chars s/*0:001*/) t/*0:01*/ (chars u/*0:1*/);
foldl3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ = foldl3 f/*0:00001*/ a/*0:0001*/ (chars s/*0:001*/) t/*0:01*/ u/*0:1*/;
foldl3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ :: string = foldl3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ (chars t/*0:01*/) (chars u/*0:1*/);
foldl3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ = foldl3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ (chars t/*0:01*/) u/*0:1*/;
foldl3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ t/*0:01*/ u/*0:1*/ :: string = foldl3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ t/*0:01*/ (chars u/*0:1*/);
foldr f/*0:001*/ a/*0:01*/ s/*0:1*/ :: string = foldr f/*0:001*/ a/*0:01*/ (chars s/*0:1*/);
foldr1 f/*0:01*/ s/*0:1*/ :: string = foldr1 f/*0:01*/ (chars s/*0:1*/);
foldr2 f/*0:0001*/ a/*0:001*/ s/*0:01*/ :: string t/*0:1*/ :: string = foldr2 f/*0:0001*/ a/*0:001*/ (chars s/*0:01*/) (chars t/*0:1*/);
foldr2 f/*0:0001*/ a/*0:001*/ s/*0:01*/ t/*0:1*/ :: string = foldr2 f/*0:0001*/ a/*0:001*/ s/*0:01*/ (chars t/*0:1*/);
foldr2 f/*0:0001*/ a/*0:001*/ s/*0:01*/ :: string t/*0:1*/ = foldr2 f/*0:0001*/ a/*0:001*/ (chars s/*0:01*/) t/*0:1*/;
foldr3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ :: string = foldr3 f/*0:00001*/ a/*0:0001*/ (chars s/*0:001*/) (chars t/*0:01*/) (chars u/*0:1*/);
foldr3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ = foldr3 f/*0:00001*/ a/*0:0001*/ (chars s/*0:001*/) (chars t/*0:01*/) u/*0:1*/;
foldr3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ :: string = foldr3 f/*0:00001*/ a/*0:0001*/ (chars s/*0:001*/) t/*0:01*/ (chars u/*0:1*/);
foldr3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ = foldr3 f/*0:00001*/ a/*0:0001*/ (chars s/*0:001*/) t/*0:01*/ u/*0:1*/;
foldr3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ :: string = foldr3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ (chars t/*0:01*/) (chars u/*0:1*/);
foldr3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ = foldr3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ (chars t/*0:01*/) u/*0:1*/;
foldr3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ t/*0:01*/ u/*0:1*/ :: string = foldr3 f/*0:00001*/ a/*0:0001*/ s/*0:001*/ t/*0:01*/ (chars u/*0:1*/);
head s/*0:1*/ :: string = s/*0:1*/!0 if ~null s/*0:1*/;
init s/*0:1*/ :: string = substr s/*0:1*/ 0 (#s/*0:1*/-1) if ~null s/*0:1*/;
last s/*0:1*/ :: string = s/*0:1*/!(#s/*0:1*/-1) if ~null s/*0:1*/;
lastby p/*0:001*/ none/*0:01*/ s/*0:1*/ :: string = lastby p/*0:001*/ none/*0:01*/ (chars s/*0:1*/);
map f/*0:01*/ s/*0:1*/ :: string = map f/*0:01*/ (chars s/*0:1*/);
map_onto f/*0:001*/ b/*0:01*/ :: string s/*0:1*/ :: string = map_onto f/*0:001*/ (chars b/*0:01*/) (chars s/*0:1*/);
map_onto f/*0:001*/ b/*0:01*/ s/*0:1*/ :: string = map_onto f/*0:001*/ b/*0:01*/ (chars s/*0:1*/);
map_onto f/*0:001*/ b/*0:01*/ :: string s/*0:1*/ = map_onto f/*0:001*/ (chars b/*0:01*/) s/*0:1*/;
partition p/*0:01*/ s/*0:1*/ :: string = strcat yes/*0:01*/,strcat no/*0:1*/ when yes/*0:01*/,no/*0:1*/ = partition p/*0:01*/ (chars s/*0:1*/) {
  rule #0: yes,no = partition p (chars s)
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end;
pickfirstby p/*0:01*/ s/*0:1*/ :: string = case pickfirstby p/*0:01*/ (chars s/*0:1*/) of () = (); c/*0:01*/,cs/*0:1*/ = c/*0:01*/,strcat cs/*0:1*/ {
  rule #0: () = ()
  rule #1: c,cs = c,strcat cs
  state 0: #0 #1
	<app> state 1
	() state 6
  state 1: #1
	<app> state 2
  state 2: #1
	, state 3
  state 3: #1
	<var> state 4
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0
} end;
picklastby p/*0:01*/ s/*0:1*/ :: string = case picklastby p/*0:01*/ (chars s/*0:1*/) of () = (); c/*0:01*/,cs/*0:1*/ = c/*0:01*/,strcat cs/*0:1*/ {
  rule #0: () = ()
  rule #1: c,cs = c,strcat cs
  state 0: #0 #1
	<app> state 1
	() state 6
  state 1: #1
	<app> state 2
  state 2: #1
	, state 3
  state 3: #1
	<var> state 4
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0
} end;
revmap f/*0:01*/ s/*0:1*/ :: string = revmap f/*0:01*/ (chars s/*0:1*/);
revmap_onto f/*0:001*/ b/*0:01*/ :: string s/*0:1*/ :: string = revmap_onto f/*0:001*/ (chars b/*0:01*/) (chars s/*0:1*/);
revmap_onto f/*0:001*/ b/*0:01*/ s/*0:1*/ :: string = revmap_onto f/*0:001*/ b/*0:01*/ (chars s/*0:1*/);
revmap_onto f/*0:001*/ b/*0:01*/ :: string s/*0:1*/ = revmap_onto f/*0:001*/ (chars b/*0:01*/) s/*0:1*/;
rmfirstby p/*0:01*/ s/*0:1*/ :: string = strcat (rmfirstby p/*0:01*/ (chars s/*0:1*/));
rmlastby p/*0:01*/ s/*0:1*/ :: string = strcat (rmfirstby p/*0:01*/ (chars s/*0:1*/));
rotate n/*0:01*/ :: int s/*0:1*/ :: string = strcat (rotate n/*0:01*/ (chars s/*0:1*/));
scanl f/*0:001*/ a/*0:01*/ s/*0:1*/ :: string = scanl f/*0:001*/ a/*0:01*/ (chars s/*0:1*/);
scanl1 f/*0:01*/ s/*0:1*/ :: string = scanl1 f/*0:01*/ (chars s/*0:1*/);
scanr f/*0:001*/ a/*0:01*/ s/*0:1*/ :: string = scanr f/*0:001*/ a/*0:01*/ (chars s/*0:1*/);
scanr1 f/*0:01*/ s/*0:1*/ :: string = scanr1 f/*0:01*/ (chars s/*0:1*/);
span p/*0:01*/ s/*0:1*/ :: string = strcat pre/*0:01*/,strcat post/*0:1*/ when pre/*0:01*/,post/*0:1*/ = span p/*0:01*/ (chars s/*0:1*/) {
  rule #0: pre,post = span p (chars s)
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end;
split n/*0:01*/ :: int s/*0:1*/ :: string = substr s/*0:1*/ 0 n/*0:01*/,substr s/*0:1*/ n/*0:01*/ 2147483647;
take n/*0:01*/ :: int s/*0:1*/ :: string = substr s/*0:1*/ 0 n/*0:01*/;
takewhile p/*0:01*/ s/*0:1*/ :: string = strcat (takewhile p/*0:01*/ (chars s/*0:1*/));
tail s/*0:1*/ :: string = substr s/*0:1*/ 1 (#s/*0:1*/-1) if ~null s/*0:1*/;
zip s/*0:01*/ :: string t/*0:1*/ :: string = zip (chars s/*0:01*/) (chars t/*0:1*/);
zip s/*0:01*/ t/*0:1*/ :: string = zip s/*0:01*/ (chars t/*0:1*/);
zip s/*0:01*/ :: string t/*0:1*/ = zip (chars s/*0:01*/) t/*0:1*/;
zip_onto b/*0:001*/ :: string s/*0:01*/ :: string t/*0:1*/ :: string = zip_onto (chars b/*0:001*/) (chars s/*0:01*/) (chars t/*0:1*/);
zip_onto b/*0:001*/ :: string s/*0:01*/ :: string t/*0:1*/ = zip_onto (chars b/*0:001*/) (chars s/*0:01*/) t/*0:1*/;
zip_onto b/*0:001*/ :: string s/*0:01*/ t/*0:1*/ :: string = zip_onto (chars b/*0:001*/) s/*0:01*/ (chars t/*0:1*/);
zip_onto b/*0:001*/ :: string s/*0:01*/ t/*0:1*/ = zip_onto (chars b/*0:001*/) s/*0:01*/ t/*0:1*/;
zip_onto b/*0:001*/ s/*0:01*/ :: string t/*0:1*/ :: string = zip_onto b/*0:001*/ (chars s/*0:01*/) (chars t/*0:1*/);
zip_onto b/*0:001*/ s/*0:01*/ :: string t/*0:1*/ = zip_onto b/*0:001*/ (chars s/*0:01*/) t/*0:1*/;
zip_onto b/*0:001*/ s/*0:01*/ t/*0:1*/ :: string = zip_onto b/*0:001*/ s/*0:01*/ (chars t/*0:1*/);
zip3 s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ :: string = zip3 (chars s/*0:001*/) (chars t/*0:01*/) (chars u/*0:1*/);
zip3 s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ = zip3 (chars s/*0:001*/) (chars t/*0:01*/) u/*0:1*/;
zip3 s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ :: string = zip3 (chars s/*0:001*/) t/*0:01*/ (chars u/*0:1*/);
zip3 s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ = zip3 (chars s/*0:001*/) t/*0:01*/ u/*0:1*/;
zip3 s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ :: string = zip3 s/*0:001*/ (chars t/*0:01*/) (chars u/*0:1*/);
zip3 s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ = zip3 s/*0:001*/ (chars t/*0:01*/) u/*0:1*/;
zip3 s/*0:001*/ t/*0:01*/ u/*0:1*/ :: string = zip3 s/*0:001*/ t/*0:01*/ (chars u/*0:1*/);
zip3_onto b/*0:0001*/ :: string s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ :: string = zip3_onto (chars b/*0:0001*/) (chars s/*0:001*/) (chars t/*0:01*/) (chars u/*0:1*/);
zip3_onto b/*0:0001*/ :: string s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ = zip3_onto (chars b/*0:0001*/) (chars s/*0:001*/) (chars t/*0:01*/) u/*0:1*/;
zip3_onto b/*0:0001*/ :: string s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ :: string = zip3_onto (chars b/*0:0001*/) (chars s/*0:001*/) t/*0:01*/ (chars u/*0:1*/);
zip3_onto b/*0:0001*/ :: string s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ = zip3_onto (chars b/*0:0001*/) (chars s/*0:001*/) t/*0:01*/ u/*0:1*/;
zip3_onto b/*0:0001*/ :: string s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ :: string = zip3_onto (chars b/*0:0001*/) s/*0:001*/ (chars t/*0:01*/) (chars u/*0:1*/);
zip3_onto b/*0:0001*/ :: string s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ = zip3_onto (chars b/*0:0001*/) s/*0:001*/ (chars t/*0:01*/) u/*0:1*/;
zip3_onto b/*0:0001*/ :: string s/*0:001*/ t/*0:01*/ u/*0:1*/ :: string = zip3_onto (chars b/*0:0001*/) s/*0:001*/ t/*0:01*/ (chars u/*0:1*/);
zip3_onto b/*0:0001*/ :: string s/*0:001*/ t/*0:01*/ u/*0:1*/ = zip3_onto (chars b/*0:0001*/) s/*0:001*/ t/*0:01*/ u/*0:1*/;
zip3_onto b/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ :: string = zip3_onto b/*0:0001*/ (chars s/*0:001*/) (chars t/*0:01*/) (chars u/*0:1*/);
zip3_onto b/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ = zip3_onto b/*0:0001*/ (chars s/*0:001*/) (chars t/*0:01*/) u/*0:1*/;
zip3_onto b/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ :: string = zip3_onto b/*0:0001*/ (chars s/*0:001*/) t/*0:01*/ (chars u/*0:1*/);
zip3_onto b/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ = zip3_onto b/*0:0001*/ (chars s/*0:001*/) t/*0:01*/ u/*0:1*/;
zip3_onto b/*0:0001*/ s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ :: string = zip3_onto b/*0:0001*/ s/*0:001*/ (chars t/*0:01*/) (chars u/*0:1*/);
zip3_onto b/*0:0001*/ s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ = zip3_onto b/*0:0001*/ s/*0:001*/ (chars t/*0:01*/) u/*0:1*/;
zip3_onto b/*0:0001*/ s/*0:001*/ t/*0:01*/ u/*0:1*/ :: string = zip3_onto b/*0:0001*/ s/*0:001*/ t/*0:01*/ (chars u/*0:1*/);
zipwith f/*0:001*/ s/*0:01*/ :: string t/*0:1*/ :: string = zipwith f/*0:001*/ (chars s/*0:01*/) (chars t/*0:1*/);
zipwith f/*0:001*/ s/*0:01*/ t/*0:1*/ :: string = zipwith f/*0:001*/ s/*0:01*/ (chars t/*0:1*/);
zipwith f/*0:001*/ s/*0:01*/ :: string t/*0:1*/ = zipwith f/*0:001*/ (chars s/*0:01*/) t/*0:1*/;
zipwith_onto f/*0:0001*/ b/*0:001*/ :: string s/*0:01*/ :: string t/*0:1*/ :: string = zipwith_onto f/*0:0001*/ (chars b/*0:001*/) (chars s/*0:01*/) (chars t/*0:1*/);
zipwith_onto f/*0:0001*/ b/*0:001*/ :: string s/*0:01*/ :: string t/*0:1*/ = zipwith_onto f/*0:0001*/ (chars b/*0:001*/) (chars s/*0:01*/) t/*0:1*/;
zipwith_onto f/*0:0001*/ b/*0:001*/ :: string s/*0:01*/ t/*0:1*/ :: string = zipwith_onto f/*0:0001*/ (chars b/*0:001*/) s/*0:01*/ (chars t/*0:1*/);
zipwith_onto f/*0:0001*/ b/*0:001*/ :: string s/*0:01*/ t/*0:1*/ = zipwith_onto f/*0:0001*/ (chars b/*0:001*/) s/*0:01*/ t/*0:1*/;
zipwith_onto f/*0:0001*/ b/*0:001*/ s/*0:01*/ :: string t/*0:1*/ :: string = zipwith_onto f/*0:0001*/ b/*0:001*/ (chars s/*0:01*/) (chars t/*0:1*/);
zipwith_onto f/*0:0001*/ b/*0:001*/ s/*0:01*/ :: string t/*0:1*/ = zipwith_onto f/*0:0001*/ b/*0:001*/ (chars s/*0:01*/) t/*0:1*/;
zipwith_onto f/*0:0001*/ b/*0:001*/ s/*0:01*/ t/*0:1*/ :: string = zipwith_onto f/*0:0001*/ b/*0:001*/ s/*0:01*/ (chars t/*0:1*/);
zipwith3 f/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ :: string = zipwith3 f/*0:0001*/ (chars s/*0:001*/) (chars t/*0:01*/) (chars u/*0:1*/);
zipwith3 f/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ = zipwith3 f/*0:0001*/ (chars s/*0:001*/) (chars t/*0:01*/) u/*0:1*/;
zipwith3 f/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ :: string = zipwith3 f/*0:0001*/ (chars s/*0:001*/) t/*0:01*/ (chars u/*0:1*/);
zipwith3 f/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ = zipwith3 f/*0:0001*/ (chars s/*0:001*/) t/*0:01*/ u/*0:1*/;
zipwith3 f/*0:0001*/ s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ :: string = zipwith3 f/*0:0001*/ s/*0:001*/ (chars t/*0:01*/) (chars u/*0:1*/);
zipwith3 f/*0:0001*/ s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ = zipwith3 f/*0:0001*/ s/*0:001*/ (chars t/*0:01*/) u/*0:1*/;
zipwith3 f/*0:0001*/ s/*0:001*/ t/*0:01*/ u/*0:1*/ :: string = zipwith3 f/*0:0001*/ s/*0:001*/ t/*0:01*/ (chars u/*0:1*/);
zipwith3_onto f/*0:00001*/ b/*0:0001*/ :: string s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ :: string = zipwith3_onto f/*0:00001*/ (chars b/*0:0001*/) (chars s/*0:001*/) (chars t/*0:01*/) (chars u/*0:1*/);
zipwith3_onto f/*0:00001*/ b/*0:0001*/ :: string s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ = zipwith3_onto f/*0:00001*/ (chars b/*0:0001*/) (chars s/*0:001*/) (chars t/*0:01*/) u/*0:1*/;
zipwith3_onto f/*0:00001*/ b/*0:0001*/ :: string s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ :: string = zipwith3_onto f/*0:00001*/ (chars b/*0:0001*/) (chars s/*0:001*/) t/*0:01*/ (chars u/*0:1*/);
zipwith3_onto f/*0:00001*/ b/*0:0001*/ :: string s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ = zipwith3_onto f/*0:00001*/ (chars b/*0:0001*/) (chars s/*0:001*/) t/*0:01*/ u/*0:1*/;
zipwith3_onto f/*0:00001*/ b/*0:0001*/ :: string s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ :: string = zipwith3_onto f/*0:00001*/ (chars b/*0:0001*/) s/*0:001*/ (chars t/*0:01*/) (chars u/*0:1*/);
zipwith3_onto f/*0:00001*/ b/*0:0001*/ :: string s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ = zipwith3_onto f/*0:00001*/ (chars b/*0:0001*/) s/*0:001*/ (chars t/*0:01*/) u/*0:1*/;
zipwith3_onto f/*0:00001*/ b/*0:0001*/ :: string s/*0:001*/ t/*0:01*/ u/*0:1*/ :: string = zipwith3_onto f/*0:00001*/ (chars b/*0:0001*/) s/*0:001*/ t/*0:01*/ (chars u/*0:1*/);
zipwith3_onto f/*0:00001*/ b/*0:0001*/ :: string s/*0:001*/ t/*0:01*/ u/*0:1*/ = zipwith3_onto f/*0:00001*/ (chars b/*0:0001*/) s/*0:001*/ t/*0:01*/ u/*0:1*/;
zipwith3_onto f/*0:00001*/ b/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ :: string = zipwith3_onto f/*0:00001*/ b/*0:0001*/ (chars s/*0:001*/) (chars t/*0:01*/) (chars u/*0:1*/);
zipwith3_onto f/*0:00001*/ b/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ = zipwith3_onto f/*0:00001*/ b/*0:0001*/ (chars s/*0:001*/) (chars t/*0:01*/) u/*0:1*/;
zipwith3_onto f/*0:00001*/ b/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ :: string = zipwith3_onto f/*0:00001*/ b/*0:0001*/ (chars s/*0:001*/) t/*0:01*/ (chars u/*0:1*/);
zipwith3_onto f/*0:00001*/ b/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ = zipwith3_onto f/*0:00001*/ b/*0:0001*/ (chars s/*0:001*/) t/*0:01*/ u/*0:1*/;
zipwith3_onto f/*0:00001*/ b/*0:0001*/ s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ :: string = zipwith3_onto f/*0:00001*/ b/*0:0001*/ s/*0:001*/ (chars t/*0:01*/) (chars u/*0:1*/);
zipwith3_onto f/*0:00001*/ b/*0:0001*/ s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ = zipwith3_onto f/*0:00001*/ b/*0:0001*/ s/*0:001*/ (chars t/*0:01*/) u/*0:1*/;
zipwith3_onto f/*0:00001*/ b/*0:0001*/ s/*0:001*/ t/*0:01*/ u/*0:1*/ :: string = zipwith3_onto f/*0:00001*/ b/*0:0001*/ s/*0:001*/ t/*0:01*/ (chars u/*0:1*/);
dowith f/*0:001*/ s/*0:01*/ :: string t/*0:1*/ :: string = dowith f/*0:001*/ (chars s/*0:01*/) (chars t/*0:1*/);
dowith f/*0:001*/ s/*0:01*/ :: string t/*0:1*/ = dowith f/*0:001*/ (chars s/*0:01*/) t/*0:1*/;
dowith f/*0:001*/ s/*0:01*/ t/*0:1*/ :: string = dowith f/*0:001*/ s/*0:01*/ (chars t/*0:1*/);
dowith3 f/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ :: string = dowith3 f/*0:0001*/ (chars s/*0:001*/) (chars t/*0:01*/) (chars u/*0:1*/);
dowith3 f/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ :: string u/*0:1*/ = dowith3 f/*0:0001*/ (chars s/*0:001*/) (chars t/*0:01*/) u/*0:1*/;
dowith3 f/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ :: string = dowith3 f/*0:0001*/ (chars s/*0:001*/) t/*0:01*/ (chars u/*0:1*/);
dowith3 f/*0:0001*/ s/*0:001*/ :: string t/*0:01*/ u/*0:1*/ = dowith3 f/*0:0001*/ (chars s/*0:001*/) t/*0:01*/ u/*0:1*/;
dowith3 f/*0:0001*/ s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ :: string = dowith3 f/*0:0001*/ s/*0:001*/ (chars t/*0:01*/) (chars u/*0:1*/);
dowith3 f/*0:0001*/ s/*0:001*/ t/*0:01*/ :: string u/*0:1*/ = dowith3 f/*0:0001*/ s/*0:001*/ (chars t/*0:01*/) u/*0:1*/;
dowith3 f/*0:0001*/ s/*0:001*/ t/*0:01*/ u/*0:1*/ :: string = dowith3 f/*0:0001*/ s/*0:001*/ t/*0:01*/ (chars u/*0:1*/);
f/*0:01*/$x/*0:1*/ = f/*0:01*/ x/*0:1*/;
(f/*0:001*/.g/*0:01*/) x/*0:1*/ = f/*0:001*/ (g/*0:01*/ x/*0:1*/);
void _/*0:1*/ = ();
id x/*0:1*/ = x/*0:1*/;
cst x/*0:01*/ y/*0:1*/ = x/*0:01*/;
flip f/*0:001*/ x/*0:01*/ y/*0:1*/ = f/*0:001*/ y/*0:1*/ x/*0:01*/;
curry f/*0:001*/ x/*0:01*/ y/*0:1*/ = f/*0:001*/ (x/*0:01*/,y/*0:1*/);
curry3 f/*0:0001*/ x/*0:001*/ y/*0:01*/ z/*0:1*/ = f/*0:0001*/ (x/*0:001*/,y/*0:01*/,z/*0:1*/);
uncurry f/*0:01*/ (x/*0:101*/,y/*0:11*/) = f/*0:01*/ x/*0:101*/ y/*0:11*/;
uncurry3 f/*0:01*/ (x/*0:101*/,y/*0:1101*/,z/*0:111*/) = f/*0:01*/ x/*0:101*/ y/*0:1101*/ z/*0:111*/;
fix f/*0:1*/ = f/*0:1*/ (fix f/*1:1*/&);
def f/*0:01*/$x/*0:1*/ = f/*0:01*/ x/*0:1*/;
def (f/*0:001*/.g/*0:01*/) x/*0:1*/ = f/*0:001*/ (g/*0:01*/ x/*0:1*/);
def void () = ();
def void [] = ();
def void {} = ();
def void [x/*0:101*/] = void x/*0:101*/;
def void {x/*0:100*/} = void x/*0:100*/;
(x/*0:0101*/=>v/*0:011*/)==(y/*0:101*/=>w/*0:11*/) = x/*0:0101*/==y/*0:101*/&&v/*0:011*/==w/*0:11*/;
(x/*0:0101*/=>v/*0:011*/)~=(y/*0:101*/=>w/*0:11*/) = x/*0:0101*/~=y/*0:101*/||v/*0:011*/~=w/*0:11*/;
key (x/*0:101*/=>v/*0:11*/) = x/*0:101*/;
val (x/*0:101*/=>v/*0:11*/) = v/*0:11*/;
tuple2 x/*0:01*/ y/*0:1*/ = 'comma/*0:*/ x/*1:01*/ y/*1:1*/ when comma/*0:*/ = (,) {
  rule #0: comma = (,)
  state 0: #0
	<var> state 1
  state 1: #0
} end;
tuple3 x/*0:001*/ y/*0:01*/ z/*0:1*/ = 'comma/*0:*/ x/*1:001*/ (comma/*0:*/ y/*1:01*/ z/*1:1*/) when comma/*0:*/ = (,) {
  rule #0: comma = (,)
  state 0: #0
	<var> state 1
  state 1: #0
} end;
x/*0:01*/,y/*0:1*/ = flatten/*0*/ x/*0:01*/ y/*0:1*/ with flatten () (x/*0:101*/,y/*0:11*/) = flatten/*1*/ x/*0:101*/ y/*0:11*/; flatten (x/*0:0101*/,y/*0:011*/) () = flatten/*1*/ x/*0:0101*/ y/*0:011*/; flatten () x/*0:1*/ = x/*0:1*/; flatten x/*0:01*/ () = x/*0:01*/; flatten (x/*0:0101*/,y/*0:011*/) z/*0:1*/ = flatten/*1*/ x/*0:0101*/ (flatten/*1*/ y/*0:011*/ z/*0:1*/); flatten x/*0:01*/ (y/*0:101*/,z/*0:11*/) = tuple2 x/*0:01*/ (flatten/*1*/ y/*0:101*/ z/*0:11*/); flatten x/*0:01*/ z/*0:1*/ = tuple2 x/*0:01*/ z/*0:1*/ {
  rule #0: flatten () (x,y) = flatten x y
  rule #1: flatten (x,y) () = flatten x y
  rule #2: flatten () x = x
  rule #3: flatten x () = x
  rule #4: flatten (x,y) z = flatten x (flatten y z)
  rule #5: flatten x (y,z) = tuple2 x (flatten y z)
  rule #6: flatten x z = tuple2 x z
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var> state 1
	<app> state 14
	() state 60
  state 1: #3 #5 #6
	<var> state 2
	<app> state 3
	() state 13
  state 2: #6
  state 3: #5 #6
	<var> state 4
	<app> state 6
  state 4: #6
	<var> state 5
  state 5: #6
  state 6: #5 #6
	<var> state 7
	, state 10
  state 7: #6
	<var> state 8
  state 8: #6
	<var> state 9
  state 9: #6
  state 10: #5 #6
	<var> state 11
  state 11: #5 #6
	<var> state 12
  state 12: #5 #6
  state 13: #3 #6
  state 14: #1 #3 #4 #5 #6
	<var> state 15
	<app> state 29
  state 15: #3 #5 #6
	<var> state 16
  state 16: #3 #5 #6
	<var> state 17
	<app> state 18
	() state 28
  state 17: #6
  state 18: #5 #6
	<var> state 19
	<app> state 21
  state 19: #6
	<var> state 20
  state 20: #6
  state 21: #5 #6
	<var> state 22
	, state 25
  state 22: #6
	<var> state 23
  state 23: #6
	<var> state 24
  state 24: #6
  state 25: #5 #6
	<var> state 26
  state 26: #5 #6
	<var> state 27
  state 27: #5 #6
  state 28: #3 #6
  state 29: #1 #3 #4 #5 #6
	<var> state 30
	, state 45
  state 30: #3 #5 #6
	<var> state 31
  state 31: #3 #5 #6
	<var> state 32
  state 32: #3 #5 #6
	<var> state 33
	<app> state 34
	() state 44
  state 33: #6
  state 34: #5 #6
	<var> state 35
	<app> state 37
  state 35: #6
	<var> state 36
  state 36: #6
  state 37: #5 #6
	<var> state 38
	, state 41
  state 38: #6
	<var> state 39
  state 39: #6
	<var> state 40
  state 40: #6
  state 41: #5 #6
	<var> state 42
  state 42: #5 #6
	<var> state 43
  state 43: #5 #6
  state 44: #3 #6
  state 45: #1 #3 #4 #5 #6
	<var> state 46
  state 46: #1 #3 #4 #5 #6
	<var> state 47
  state 47: #1 #3 #4 #5 #6
	<var> state 48
	<app> state 49
	() state 59
  state 48: #4 #6
  state 49: #4 #5 #6
	<var> state 50
	<app> state 52
  state 50: #4 #6
	<var> state 51
  state 51: #4 #6
  state 52: #4 #5 #6
	<var> state 53
	, state 56
  state 53: #4 #6
	<var> state 54
  state 54: #4 #6
	<var> state 55
  state 55: #4 #6
  state 56: #4 #5 #6
	<var> state 57
  state 57: #4 #5 #6
	<var> state 58
  state 58: #4 #5 #6
  state 59: #1 #3 #4 #6
  state 60: #0 #2 #3 #5 #6
	<var> state 61
	<app> state 62
	() state 72
  state 61: #2 #6
  state 62: #0 #2 #5 #6
	<var> state 63
	<app> state 65
  state 63: #2 #6
	<var> state 64
  state 64: #2 #6
  state 65: #0 #2 #5 #6
	<var> state 66
	, state 69
  state 66: #2 #6
	<var> state 67
  state 67: #2 #6
	<var> state 68
  state 68: #2 #6
  state 69: #0 #2 #5 #6
	<var> state 70
  state 70: #0 #2 #5 #6
	<var> state 71
  state 71: #0 #2 #5 #6
  state 72: #2 #3 #6
} end;
mapfst f/*0:01*/ (a/*0:101*/,b/*0:11*/) = tuple2 (f/*0:01*/ a/*0:101*/) b/*0:11*/;
mapsnd f/*0:01*/ (a/*0:101*/,b/*0:11*/) = tuple2 a/*0:101*/ (f/*0:01*/ b/*0:11*/);
maptrd f/*0:01*/ (a/*0:101*/,b/*0:1101*/,c/*0:111*/) = tuple3 a/*0:101*/ b/*0:1101*/ (f/*0:01*/ c/*0:111*/);
fst _/*0:01*/ (a/*0:101*/,_/*0:11*/) = a/*0:101*/;
snd _/*0:01*/ (_/*0:101*/,a/*0:11*/) = a/*0:11*/;
trd _/*0:01*/ (_/*0:101*/,_/*0:1101*/,a/*0:111*/) = a/*0:111*/;
fst none/*0:01*/ () = none/*0:01*/;
snd none/*0:01*/ () = none/*0:01*/;
trd none/*0:01*/ () = none/*0:01*/;
()==() = 1;
(x/*0:0101*/,xs/*0:011*/)==(y/*0:101*/,ys/*0:11*/) = x/*0:0101*/==y/*0:101*/&&xs/*0:011*/==ys/*0:11*/;
(x/*0:0101*/,xs/*0:011*/)==_/*0:1*/ = 0;
()==_/*0:1*/ = 0;
_/*0:01*/==(x/*0:101*/,xs/*0:11*/) = 0;
_/*0:01*/==() = 0;
()~=() = 0;
(x/*0:0101*/,xs/*0:011*/)~=(y/*0:101*/,ys/*0:11*/) = x/*0:0101*/~=y/*0:101*/||xs/*0:011*/~=ys/*0:11*/;
(x/*0:0101*/,xs/*0:011*/)~=_/*0:1*/ = 1;
()~=_/*0:1*/ = 1;
_/*0:01*/~=(x/*0:101*/,xs/*0:11*/) = 1;
_/*0:01*/~=() = 1;
null () = 1;
null (x/*0:101*/,xs/*0:11*/) = 0;
#() = 0;
#(x/*0:101*/,xs/*0:11*/) = accum/*0*/ 1 xs/*0:11*/ with accum n/*0:01*/ :: int (x/*0:101*/,xs/*0:11*/) = accum/*1*/ (n/*0:01*/+1) xs/*0:11*/; accum n/*0:01*/ :: int x/*0:1*/ = n/*0:01*/+1 {
  rule #0: accum n::int (x,xs) = accum (n+1) xs
  rule #1: accum n::int x = n+1
  state 0: #0 #1
	<var>::int state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	, state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
} end;
(x/*0:0101*/,xs/*0:011*/)!n/*0:1*/ :: int = throw out_of_bounds if n/*0:1*/<0;
(x/*0:0101*/,xs/*0:011*/)!0 = x/*0:0101*/;
(x/*0:0101*/,y/*0:01101*/,xs/*0:0111*/)!n/*0:1*/ :: int = (y/*0:01101*/,xs/*0:0111*/)!(n/*0:1*/-1);
(x/*0:0101*/,y/*0:011*/)!1 = y/*0:011*/;
(x/*0:0101*/,y/*0:011*/)!n/*0:1*/ :: int = throw out_of_bounds;
()!n/*0:1*/ :: int = throw out_of_bounds;
xs@()!!ns/*0:1*/ = tuple (list xs/*0:01*/!!ns/*0:1*/);
xs@(_/*0:0101*/,_/*0:011*/)!!ns/*0:1*/ = tuple (list xs/*0:01*/!!ns/*0:1*/);
reverse () = ();
reverse (x/*0:101*/,xs/*0:11*/) = accum/*0*/ x/*0:101*/ xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/,xs/*0:11*/) = accum/*1*/ (x/*0:101*/,ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ x/*0:1*/ = x/*0:1*/,ys/*0:01*/ {
  rule #0: accum ys (x,xs) = accum (x,ys) xs
  rule #1: accum ys x = x,ys
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	, state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
} end;
[]==[] = 1;
x/*0:0101*/:xs/*0:011*/==[] = 0;
[]==x/*0:101*/:xs/*0:11*/ = 0;
x/*0:0101*/:xs/*0:011*/==y/*0:101*/:ys/*0:11*/ = x/*0:0101*/==y/*0:101*/&&xs/*0:011*/==ys/*0:11*/;
[]~=[] = 0;
x/*0:0101*/:xs/*0:011*/~=[] = 1;
[]~=x/*0:101*/:xs/*0:11*/ = 1;
x/*0:0101*/:xs/*0:011*/~=y/*0:101*/:ys/*0:11*/ = x/*0:0101*/~=y/*0:101*/||xs/*0:011*/~=ys/*0:11*/;
null [] = 1;
null (x/*0:101*/:xs/*0:11*/) = 0;
#[] = 0;
#(x/*0:101*/:xs/*0:11*/) = accum/*0*/ 1 xs/*0:11*/ with accum n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (n/*0:01*/+1) xs/*0:11*/; accum n/*0:01*/ :: int [] = n/*0:01*/; accum n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/+#xs/*0:1*/ {
  rule #0: accum n::int (x:xs) = accum (n+1) xs
  rule #1: accum n::int [] = n
  rule #2: accum n::int xs = n+#xs
  state 0: #0 #1 #2
	<var>::int state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
[]!n/*0:1*/ :: int = throw out_of_bounds;
(x/*0:0101*/:xs/*0:011*/)!0 = x/*0:0101*/;
(x/*0:0101*/:xs/*0:011*/)!n/*0:1*/ :: int = xs/*0:011*/!(n/*0:1*/-1) if n/*0:1*/>0;
(x/*0:0101*/:xs/*0:011*/)!n/*0:1*/ :: int = throw out_of_bounds;
type ref {
  rule #0: ref x::pointer = refp x
  state 0: #0
	<var>::pointer state 1
  state 1: #0
}
type dmatrix {
  rule #0: dmatrix = dmatrixp
  state 0: #0
}
type imatrix {
  rule #0: imatrix = imatrixp
  state 0: #0
}
type cmatrix {
  rule #0: cmatrix = cmatrixp
  state 0: #0
}
type nmatrix {
  rule #0: nmatrix = nmatrixp
  state 0: #0
}
type smatrix {
  rule #0: smatrix = smatrixp
  state 0: #0
}
type record {
  rule #0: record = recordp
  state 0: #0
}
{
  rule #0: x,y = flatten x y with flatten () (x,y) = flatten x y; flatten (x,y) () = flatten x y; flatten () x = x; flatten x () = x; flatten (x,y) z = flatten x (flatten y z); flatten x (y,z) = tuple2 x (flatten y z); flatten x z = tuple2 x z end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: flip f x y = f y x
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}
{
  rule #0: x::int<y::int = x<y
  rule #1: x::double<y::double = x<y
  rule #2: x::int<y::double = x<y
  rule #3: x::double<y::int = x<y
  rule #4: x::bigint<y::bigint = __C::bigint_cmp x y<0
  rule #5: x::int<y::bigint = bigint x<y
  rule #6: x::bigint<y::int = x<bigint y
  rule #7: x::bigint<y::double = double x<y
  rule #8: x::double<y::bigint = x<double y
  rule #9: x::string<y::string = __C::strcmp x y<0
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
	<var>::string state 13
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
  state 13: #9
	<var>::string state 14
  state 14: #9
}
{
  rule #0: x::int>y::int = x>y
  rule #1: x::double>y::double = x>y
  rule #2: x::int>y::double = x>y
  rule #3: x::double>y::int = x>y
  rule #4: x::bigint>y::bigint = __C::bigint_cmp x y>0
  rule #5: x::int>y::bigint = bigint x>y
  rule #6: x::bigint>y::int = x>bigint y
  rule #7: x::bigint>y::double = double x>y
  rule #8: x::double>y::bigint = x>double y
  rule #9: x::string>y::string = __C::strcmp x y>0
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
	<var>::string state 13
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
  state 13: #9
	<var>::string state 14
  state 14: #9
}
{
  rule #0: x::int<=y::int = x<=y
  rule #1: x::double<=y::double = x<=y
  rule #2: x::int<=y::double = x<=y
  rule #3: x::double<=y::int = x<=y
  rule #4: x::bigint<=y::bigint = __C::bigint_cmp x y<=0
  rule #5: x::int<=y::bigint = bigint x<=y
  rule #6: x::bigint<=y::int = x<=bigint y
  rule #7: x::bigint<=y::double = double x<=y
  rule #8: x::double<=y::bigint = x<=double y
  rule #9: x::string<=y::string = __C::strcmp x y<=0
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
	<var>::string state 13
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
  state 13: #9
	<var>::string state 14
  state 14: #9
}
{
  rule #0: x::int>=y::int = x>=y
  rule #1: x::double>=y::double = x>=y
  rule #2: x::int>=y::double = x>=y
  rule #3: x::double>=y::int = x>=y
  rule #4: x::bigint>=y::bigint = __C::bigint_cmp x y>=0
  rule #5: x::int>=y::bigint = bigint x>=y
  rule #6: x::bigint>=y::int = x>=bigint y
  rule #7: x::bigint>=y::double = double x>=y
  rule #8: x::double>=y::bigint = x>=double y
  rule #9: x::string>=y::string = __C::strcmp x y>=0
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
	<var>::string state 13
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
  state 13: #9
	<var>::string state 14
  state 14: #9
}
{
  rule #0: x::int==y::int = x==y
  rule #1: x::double==y::double = x==y
  rule #2: x::int==y::double = x==y
  rule #3: x::double==y::int = x==y
  rule #4: x::bigint==y::bigint = __C::bigint_cmp x y==0
  rule #5: x::int==y::bigint = bigint x==y
  rule #6: x::bigint==y::int = x==bigint y
  rule #7: x::bigint==y::double = double x==y
  rule #8: x::double==y::bigint = x==double y
  rule #9: x::matrix==y::matrix = x===y if nmatrixp x&&matrix_type x==matrix_type y
  rule #10: x::matrix==y::matrix = cmatrix x===y if nmatrixp x&&cmatrixp y
  rule #11: x::matrix==y::matrix = x===cmatrix y if cmatrixp x&&nmatrixp y
  rule #12: x::matrix==y::matrix = dmatrix x===y if imatrixp x&&dmatrixp y
  rule #13: x::matrix==y::matrix = x===dmatrix y if dmatrixp x&&imatrixp y
  rule #14: x::matrix==y::matrix = 0 if dim x~=dim y
  rule #15: x::matrix==y::matrix = compare 0 with compare i::int = 1 if i>=n; compare i::int = 0 if x!i~=y!i; compare i::int = compare (i+1) end when n::int = #x end
  rule #16: x::string==y::string = __C::strcmp x y==0
  rule #17: (x=>v)==(y=>w) = x==y&&v==w
  rule #18: ()==() = 1
  rule #19: (x,xs)==(y,ys) = x==y&&xs==ys
  rule #20: (x,xs)==_ = 0
  rule #21: ()==_ = 0
  rule #22: _==(x,xs) = 0
  rule #23: _==() = 0
  rule #24: []==[] = 1
  rule #25: x:xs==[] = 0
  rule #26: []==x:xs = 0
  rule #27: x:xs==y:ys = x==y&&xs==ys
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16 #17 #18 #19 #20 #21 #22 #23 #24 #25 #26 #27
	<var> state 1
	<var>::int state 8
	<var>::bigint state 18
	<var>::double state 28
	<var>::string state 38
	<var>::matrix state 46
	<app> state 54
	[] state 113
	() state 124
  state 1: #22 #23
	<app> state 2
	() state 7
  state 2: #22
	<app> state 3
  state 3: #22
	, state 4
  state 4: #22
	<var> state 5
  state 5: #22
	<var> state 6
  state 6: #22
  state 7: #23
  state 8: #0 #2 #5 #22 #23
	<var>::int state 9
	<var>::bigint state 10
	<var>::double state 11
	<app> state 12
	() state 17
  state 9: #0
  state 10: #5
  state 11: #2
  state 12: #22
	<app> state 13
  state 13: #22
	, state 14
  state 14: #22
	<var> state 15
  state 15: #22
	<var> state 16
  state 16: #22
  state 17: #23
  state 18: #4 #6 #7 #22 #23
	<var>::int state 19
	<var>::bigint state 20
	<var>::double state 21
	<app> state 22
	() state 27
  state 19: #6
  state 20: #4
  state 21: #7
  state 22: #22
	<app> state 23
  state 23: #22
	, state 24
  state 24: #22
	<var> state 25
  state 25: #22
	<var> state 26
  state 26: #22
  state 27: #23
  state 28: #1 #3 #8 #22 #23
	<var>::int state 29
	<var>::bigint state 30
	<var>::double state 31
	<app> state 32
	() state 37
  state 29: #3
  state 30: #8
  state 31: #1
  state 32: #22
	<app> state 33
  state 33: #22
	, state 34
  state 34: #22
	<var> state 35
  state 35: #22
	<var> state 36
  state 36: #22
  state 37: #23
  state 38: #16 #22 #23
	<var>::string state 39
	<app> state 40
	() state 45
  state 39: #16
  state 40: #22
	<app> state 41
  state 41: #22
	, state 42
  state 42: #22
	<var> state 43
  state 43: #22
	<var> state 44
  state 44: #22
  state 45: #23
  state 46: #9 #10 #11 #12 #13 #14 #15 #22 #23
	<var>::matrix state 47
	<app> state 48
	() state 53
  state 47: #9 #10 #11 #12 #13 #14 #15
  state 48: #22
	<app> state 49
  state 49: #22
	, state 50
  state 50: #22
	<var> state 51
  state 51: #22
	<var> state 52
  state 52: #22
  state 53: #23
  state 54: #17 #19 #20 #22 #23 #25 #27
	<var> state 55
	<app> state 63
  state 55: #22 #23
	<var> state 56
  state 56: #22 #23
	<app> state 57
	() state 62
  state 57: #22
	<app> state 58
  state 58: #22
	, state 59
  state 59: #22
	<var> state 60
  state 60: #22
	<var> state 61
  state 61: #22
  state 62: #23
  state 63: #17 #19 #20 #22 #23 #25 #27
	<var> state 64
	: state 73
	, state 86
	=> state 101
  state 64: #22 #23
	<var> state 65
  state 65: #22 #23
	<var> state 66
  state 66: #22 #23
	<app> state 67
	() state 72
  state 67: #22
	<app> state 68
  state 68: #22
	, state 69
  state 69: #22
	<var> state 70
  state 70: #22
	<var> state 71
  state 71: #22
  state 72: #23
  state 73: #22 #23 #25 #27
	<var> state 74
  state 74: #22 #23 #25 #27
	<var> state 75
  state 75: #22 #23 #25 #27
	<app> state 76
	[] state 84
	() state 85
  state 76: #22 #27
	<app> state 77
  state 77: #22 #27
	: state 78
	, state 81
  state 78: #27
	<var> state 79
  state 79: #27
	<var> state 80
  state 80: #27
  state 81: #22
	<var> state 82
  state 82: #22
	<var> state 83
  state 83: #22
  state 84: #25
  state 85: #23
  state 86: #19 #20 #22 #23
	<var> state 87
  state 87: #19 #20 #22 #23
	<var> state 88
  state 88: #19 #20 #22 #23
	<var> state 89
	<app> state 90
	() state 100
  state 89: #20
  state 90: #19 #20 #22
	<var> state 91
	<app> state 93
  state 91: #20
	<var> state 92
  state 92: #20
  state 93: #19 #20 #22
	<var> state 94
	, state 97
  state 94: #20
	<var> state 95
  state 95: #20
	<var> state 96
  state 96: #20
  state 97: #19 #20 #22
	<var> state 98
  state 98: #19 #20 #22
	<var> state 99
  state 99: #19 #20 #22
  state 100: #20 #23
  state 101: #17 #22 #23
	<var> state 102
  state 102: #17 #22 #23
	<var> state 103
  state 103: #17 #22 #23
	<app> state 104
	() state 112
  state 104: #17 #22
	<app> state 105
  state 105: #17 #22
	, state 106
	=> state 109
  state 106: #22
	<var> state 107
  state 107: #22
	<var> state 108
  state 108: #22
  state 109: #17
	<var> state 110
  state 110: #17
	<var> state 111
  state 111: #17
  state 112: #23
  state 113: #22 #23 #24 #26
	<app> state 114
	[] state 122
	() state 123
  state 114: #22 #26
	<app> state 115
  state 115: #22 #26
	: state 116
	, state 119
  state 116: #26
	<var> state 117
  state 117: #26
	<var> state 118
  state 118: #26
  state 119: #22
	<var> state 120
  state 120: #22
	<var> state 121
  state 121: #22
  state 122: #24
  state 123: #23
  state 124: #18 #21 #22 #23
	<var> state 125
	<app> state 126
	() state 136
  state 125: #21
  state 126: #21 #22
	<var> state 127
	<app> state 129
  state 127: #21
	<var> state 128
  state 128: #21
  state 129: #21 #22
	<var> state 130
	, state 133
  state 130: #21
	<var> state 131
  state 131: #21
	<var> state 132
  state 132: #21
  state 133: #21 #22
	<var> state 134
  state 134: #21 #22
	<var> state 135
  state 135: #21 #22
  state 136: #18 #21 #23
}
{
  rule #0: x::int~=y::int = x~=y
  rule #1: x::double~=y::double = x~=y
  rule #2: x::int~=y::double = x~=y
  rule #3: x::double~=y::int = x~=y
  rule #4: x::bigint~=y::bigint = __C::bigint_cmp x y~=0
  rule #5: x::int~=y::bigint = bigint x~=y
  rule #6: x::bigint~=y::int = x~=bigint y
  rule #7: x::bigint~=y::double = double x~=y
  rule #8: x::double~=y::bigint = x~=double y
  rule #9: x::matrix~=y::matrix = ~x==y
  rule #10: x::string~=y::string = __C::strcmp x y~=0
  rule #11: (x=>v)~=(y=>w) = x~=y||v~=w
  rule #12: ()~=() = 0
  rule #13: (x,xs)~=(y,ys) = x~=y||xs~=ys
  rule #14: (x,xs)~=_ = 1
  rule #15: ()~=_ = 1
  rule #16: _~=(x,xs) = 1
  rule #17: _~=() = 1
  rule #18: []~=[] = 0
  rule #19: x:xs~=[] = 1
  rule #20: []~=x:xs = 1
  rule #21: x:xs~=y:ys = x~=y||xs~=ys
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16 #17 #18 #19 #20 #21
	<var> state 1
	<var>::int state 8
	<var>::bigint state 18
	<var>::double state 28
	<var>::string state 38
	<var>::matrix state 46
	<app> state 54
	[] state 113
	() state 124
  state 1: #16 #17
	<app> state 2
	() state 7
  state 2: #16
	<app> state 3
  state 3: #16
	, state 4
  state 4: #16
	<var> state 5
  state 5: #16
	<var> state 6
  state 6: #16
  state 7: #17
  state 8: #0 #2 #5 #16 #17
	<var>::int state 9
	<var>::bigint state 10
	<var>::double state 11
	<app> state 12
	() state 17
  state 9: #0
  state 10: #5
  state 11: #2
  state 12: #16
	<app> state 13
  state 13: #16
	, state 14
  state 14: #16
	<var> state 15
  state 15: #16
	<var> state 16
  state 16: #16
  state 17: #17
  state 18: #4 #6 #7 #16 #17
	<var>::int state 19
	<var>::bigint state 20
	<var>::double state 21
	<app> state 22
	() state 27
  state 19: #6
  state 20: #4
  state 21: #7
  state 22: #16
	<app> state 23
  state 23: #16
	, state 24
  state 24: #16
	<var> state 25
  state 25: #16
	<var> state 26
  state 26: #16
  state 27: #17
  state 28: #1 #3 #8 #16 #17
	<var>::int state 29
	<var>::bigint state 30
	<var>::double state 31
	<app> state 32
	() state 37
  state 29: #3
  state 30: #8
  state 31: #1
  state 32: #16
	<app> state 33
  state 33: #16
	, state 34
  state 34: #16
	<var> state 35
  state 35: #16
	<var> state 36
  state 36: #16
  state 37: #17
  state 38: #10 #16 #17
	<var>::string state 39
	<app> state 40
	() state 45
  state 39: #10
  state 40: #16
	<app> state 41
  state 41: #16
	, state 42
  state 42: #16
	<var> state 43
  state 43: #16
	<var> state 44
  state 44: #16
  state 45: #17
  state 46: #9 #16 #17
	<var>::matrix state 47
	<app> state 48
	() state 53
  state 47: #9
  state 48: #16
	<app> state 49
  state 49: #16
	, state 50
  state 50: #16
	<var> state 51
  state 51: #16
	<var> state 52
  state 52: #16
  state 53: #17
  state 54: #11 #13 #14 #16 #17 #19 #21
	<var> state 55
	<app> state 63
  state 55: #16 #17
	<var> state 56
  state 56: #16 #17
	<app> state 57
	() state 62
  state 57: #16
	<app> state 58
  state 58: #16
	, state 59
  state 59: #16
	<var> state 60
  state 60: #16
	<var> state 61
  state 61: #16
  state 62: #17
  state 63: #11 #13 #14 #16 #17 #19 #21
	<var> state 64
	: state 73
	, state 86
	=> state 101
  state 64: #16 #17
	<var> state 65
  state 65: #16 #17
	<var> state 66
  state 66: #16 #17
	<app> state 67
	() state 72
  state 67: #16
	<app> state 68
  state 68: #16
	, state 69
  state 69: #16
	<var> state 70
  state 70: #16
	<var> state 71
  state 71: #16
  state 72: #17
  state 73: #16 #17 #19 #21
	<var> state 74
  state 74: #16 #17 #19 #21
	<var> state 75
  state 75: #16 #17 #19 #21
	<app> state 76
	[] state 84
	() state 85
  state 76: #16 #21
	<app> state 77
  state 77: #16 #21
	: state 78
	, state 81
  state 78: #21
	<var> state 79
  state 79: #21
	<var> state 80
  state 80: #21
  state 81: #16
	<var> state 82
  state 82: #16
	<var> state 83
  state 83: #16
  state 84: #19
  state 85: #17
  state 86: #13 #14 #16 #17
	<var> state 87
  state 87: #13 #14 #16 #17
	<var> state 88
  state 88: #13 #14 #16 #17
	<var> state 89
	<app> state 90
	() state 100
  state 89: #14
  state 90: #13 #14 #16
	<var> state 91
	<app> state 93
  state 91: #14
	<var> state 92
  state 92: #14
  state 93: #13 #14 #16
	<var> state 94
	, state 97
  state 94: #14
	<var> state 95
  state 95: #14
	<var> state 96
  state 96: #14
  state 97: #13 #14 #16
	<var> state 98
  state 98: #13 #14 #16
	<var> state 99
  state 99: #13 #14 #16
  state 100: #14 #17
  state 101: #11 #16 #17
	<var> state 102
  state 102: #11 #16 #17
	<var> state 103
  state 103: #11 #16 #17
	<app> state 104
	() state 112
  state 104: #11 #16
	<app> state 105
  state 105: #11 #16
	, state 106
	=> state 109
  state 106: #16
	<var> state 107
  state 107: #16
	<var> state 108
  state 108: #16
  state 109: #11
	<var> state 110
  state 110: #11
	<var> state 111
  state 111: #11
  state 112: #17
  state 113: #16 #17 #18 #20
	<app> state 114
	[] state 122
	() state 123
  state 114: #16 #20
	<app> state 115
  state 115: #16 #20
	: state 116
	, state 119
  state 116: #20
	<var> state 117
  state 117: #20
	<var> state 118
  state 118: #20
  state 119: #16
	<var> state 120
  state 120: #16
	<var> state 121
  state 121: #16
  state 122: #18
  state 123: #17
  state 124: #12 #15 #16 #17
	<var> state 125
	<app> state 126
	() state 136
  state 125: #15
  state 126: #15 #16
	<var> state 127
	<app> state 129
  state 127: #15
	<var> state 128
  state 128: #15
  state 129: #15 #16
	<var> state 130
	, state 133
  state 130: #15
	<var> state 131
  state 131: #15
	<var> state 132
  state 132: #15
  state 133: #15 #16
	<var> state 134
  state 134: #15 #16
	<var> state 135
  state 135: #15 #16
  state 136: #12 #15 #17
}
{
  rule #0: x::int+y::int = x+y
  rule #1: x::double+y::double = x+y
  rule #2: x::int+y::double = x+y
  rule #3: x::double+y::int = x+y
  rule #4: x::bigint+y::bigint = __C::bigint_add x y
  rule #5: x::int+y::bigint = bigint x+y
  rule #6: x::bigint+y::int = x+bigint y
  rule #7: x::bigint+y::double = double x+y
  rule #8: x::double+y::bigint = x+double y
  rule #9: s::string+n::int = chr (ord s+n) if #s==1
  rule #10: s::string+t::string = __C::string_concat s t
  rule #11: s::string+[] = chars s
  rule #12: s::string+xs@(_:_) = chars s+xs
  rule #13: []+s::string = chars s
  rule #14: xs@(_:_)+s::string = xs+chars s
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
	<var>::string state 13
	<app> state 22
	[] state 28
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
  state 13: #9 #10 #11 #12
	<var>::int state 14
	<var>::string state 15
	<app> state 16
	[] state 21
  state 14: #9
  state 15: #10
  state 16: #12
	<app> state 17
  state 17: #12
	: state 18
  state 18: #12
	<var> state 19
  state 19: #12
	<var> state 20
  state 20: #12
  state 21: #11
  state 22: #14
	<app> state 23
  state 23: #14
	: state 24
  state 24: #14
	<var> state 25
  state 25: #14
	<var> state 26
  state 26: #14
	<var>::string state 27
  state 27: #14
  state 28: #13
	<var>::string state 29
  state 29: #13
}
{
  rule #0: x::int-y::int = x-y
  rule #1: x::double-y::double = x-y
  rule #2: x::int-y::double = x-y
  rule #3: x::double-y::int = x-y
  rule #4: x::bigint-y::bigint = __C::bigint_sub x y
  rule #5: x::int-y::bigint = bigint x-y
  rule #6: x::bigint-y::int = x-bigint y
  rule #7: x::bigint-y::double = double x-y
  rule #8: x::double-y::bigint = x-double y
  rule #9: s::string-n::int = chr (ord s-n) if #s==1&&ord s>=n
  rule #10: s::string-t::string = ord s-ord t if #s==1&&#t==1
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
	<var>::string state 13
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
  state 13: #9 #10
	<var>::int state 14
	<var>::string state 15
  state 14: #9
  state 15: #10
}
{
  rule #0: catmap f x::matrix = cat (list (map f x))
  rule #1: catmap f s::string = catmap f (chars s)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::string state 2
	<var>::matrix state 3
  state 2: #1
  state 3: #0
}
{
  rule #0: rowcatmap f [] = {}
  rule #1: rowcatmap f xs@(_:_) = rowcat (map f xs)
  rule #2: rowcatmap f x::matrix = matcat (map f x)
  rule #3: rowcatmap f s::string = rowcatmap f (chars s)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #3
  state 3: #2
  state 4: #1
	<app> state 5
  state 5: #1
	: state 6
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0
}
{
  rule #0: colcatmap f [] = {}
  rule #1: colcatmap f xs@(_:_) = colcat (map f xs)
  rule #2: colcatmap f x::matrix = matcat (map f x)
  rule #3: colcatmap f s::string = colcatmap f (chars s)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #3
  state 3: #2
  state 4: #1
	<app> state 5
  state 5: #1
	: state 6
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0
}
{
  rule #0: listmap f x::matrix = list (map f x)
  rule #1: listmap f s::string = map f (chars s)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::string state 2
	<var>::matrix state 3
  state 2: #1
  state 3: #0
}
{
  rule #0: rowmap f [] = {}
  rule #1: rowmap f xs@(_:_) = rowcat (map f xs)
  rule #2: rowmap f x::matrix = map f x
  rule #3: rowmap f s::string = rowmap f (chars s)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #3
  state 3: #2
  state 4: #1
	<app> state 5
  state 5: #1
	: state 6
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0
}
{
  rule #0: colmap f [] = {}
  rule #1: colmap f xs@(_:_) = colcat (map f xs)
  rule #2: colmap f x::matrix = map f x
  rule #3: colmap f s::string = colmap f (chars s)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #3
  state 3: #2
  state 4: #1
	<app> state 5
  state 5: #1
	: state 6
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0
}
{
  rule #0: string s::pointer = __C::pure_string s
  rule #1: string [] = ""
  rule #2: string xs@(_::string:_) = strcat xs if all stringp xs
  rule #3: string () = ""
  rule #4: string xs@(_::string,_) = strcat xs if all stringp xs when xs = list xs end
  rule #5: string s::string = s
  rule #6: string x::matrix = string (list x) if all stringp x
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var>::string state 1
	<var>::pointer state 2
	<var>::matrix state 3
	<app> state 4
	[] state 12
	() state 13
  state 1: #5
  state 2: #0
  state 3: #6
  state 4: #2 #4
	<app> state 5
  state 5: #2 #4
	: state 6
	, state 9
  state 6: #2
	<var>::string state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #4
	<var>::string state 10
  state 10: #4
	<var> state 11
  state 11: #4
  state 12: #1
  state 13: #3
}
{
  rule #0: pointer x::pointer = x
  rule #1: pointer x::int = __C::pure_pointerval x
  rule #2: pointer x::bigint = __C::pure_pointerval x
  rule #3: pointer x::string = __C::pure_pointerval x
  rule #4: pointer x::matrix = __C::pure_pointerval x
  state 0: #0 #1 #2 #3 #4
	<var>::int state 1
	<var>::bigint state 2
	<var>::string state 3
	<var>::pointer state 4
	<var>::matrix state 5
  state 1: #1
  state 2: #2
  state 3: #3
  state 4: #0
  state 5: #4
}
{
  rule #0: matrix [] = {}
  rule #1: matrix xs@(_:_) = throw (bad_list_value xs) if ~rlistp xs
  rule #2: matrix xs@(_:_) = rowcatmap colcat xs if all rlistp xs
  rule #3: matrix xs@(_:_) = rowcat xs if any matrixp xs
  rule #4: matrix xs@(_:_) = colcat xs
  rule #5: matrix () = {}
  rule #6: matrix xs@(_,_) = matrix (list xs)
  rule #7: matrix x::matrix = x
  rule #8: matrix s::string = matrix (chars s)
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
	[] state 11
	() state 12
  state 1: #8
  state 2: #7
  state 3: #1 #2 #3 #4 #6
	<app> state 4
  state 4: #1 #2 #3 #4 #6
	: state 5
	, state 8
  state 5: #1 #2 #3 #4
	<var> state 6
  state 6: #1 #2 #3 #4
	<var> state 7
  state 7: #1 #2 #3 #4
  state 8: #6
	<var> state 9
  state 9: #6
	<var> state 10
  state 10: #6
  state 11: #0
  state 12: #5
}
{
  rule #0: f$x = f x
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: n::int..m::int = __C::pure_int_seq n m 1
  rule #1: n1::int:n2::int..m::int = __C::pure_int_seq n1 m (n2-n1) if n1~=n2
  rule #2: n::double..m::double = __C::pure_double_seq n m 1.0 if ~infp n&&~infp m
  rule #3: n::int..m::double = __C::pure_double_seq (double n) m 1.0 if ~infp m
  rule #4: n::double..m::int = __C::pure_double_seq n (double m) 1.0 if ~infp n
  rule #5: n1::double:n2::double..m::double = __C::pure_double_seq n1 m (n2-n1) if ~infp n1&&~infp m&&n1~=n2
  rule #6: n1::int:n2::double..m::double = __C::pure_double_seq (double n1) m (n2-n1) if ~infp m&&n1~=n2
  rule #7: n1::double:n2::int..m::double = __C::pure_double_seq n1 m (n2-n1) if ~infp n1&&~infp m&&n1~=n2
  rule #8: n1::double:n2::double..m::int = __C::pure_double_seq n1 (double m) (n2-n1) if ~infp n1&&n1~=n2
  rule #9: n1::int:n2::int..m::double = __C::pure_double_seq (double n1) m (double (n2-n1)) if ~infp m&&n1~=n2
  rule #10: n1::int:n2::double..m::int = __C::pure_double_seq (double n1) (double m) (n2-n1) if n1~=n2
  rule #11: n1::double:n2::int..m::int = __C::pure_double_seq n1 (double m) (n2-n1) if ~infp n1&&n1~=n2
  rule #12: a::string..b::string = map chr (ord a..ord b) if charp a&&charp b
  rule #13: a::string:b::string..c::string = map chr (ord a:ord b..ord c) if charp a&&charp b&&charp c
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13
	<var>::int state 1
	<var>::double state 4
	<var>::string state 7
	<app> state 9
  state 1: #0 #3
	<var>::int state 2
	<var>::double state 3
  state 2: #0
  state 3: #3
  state 4: #2 #4
	<var>::int state 5
	<var>::double state 6
  state 5: #4
  state 6: #2
  state 7: #12
	<var>::string state 8
  state 8: #12
  state 9: #1 #5 #6 #7 #8 #9 #10 #11 #13
	<app> state 10
  state 10: #1 #5 #6 #7 #8 #9 #10 #11 #13
	: state 11
  state 11: #1 #5 #6 #7 #8 #9 #10 #11 #13
	<var>::int state 12
	<var>::double state 19
	<var>::string state 26
  state 12: #1 #6 #9 #10
	<var>::int state 13
	<var>::double state 16
  state 13: #1 #9
	<var>::int state 14
	<var>::double state 15
  state 14: #1
  state 15: #9
  state 16: #6 #10
	<var>::int state 17
	<var>::double state 18
  state 17: #10
  state 18: #6
  state 19: #5 #7 #8 #11
	<var>::int state 20
	<var>::double state 23
  state 20: #7 #11
	<var>::int state 21
	<var>::double state 22
  state 21: #11
  state 22: #7
  state 23: #5 #8
	<var>::int state 24
	<var>::double state 25
  state 24: #8
  state 25: #5
  state 26: #13
	<var>::string state 27
  state 27: #13
	<var>::string state 28
  state 28: #13
}
{
  rule #0: #p::pointer = blob_size p if blobp p
  rule #1: #x::matrix = __C::matrix_size x
  rule #2: #s::string = __C::string_size s
  rule #3: #() = 0
  rule #4: #(x,xs) = accum 1 xs with accum n::int (x,xs) = accum (n+1) xs; accum n::int x = n+1 end
  rule #5: #[] = 0
  rule #6: #(x:xs) = accum 1 xs with accum n::int (x:xs) = accum (n+1) xs; accum n::int [] = n; accum n::int xs = n+#xs end
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var>::string state 1
	<var>::pointer state 2
	<var>::matrix state 3
	<app> state 4
	[] state 12
	() state 13
  state 1: #2
  state 2: #0
  state 3: #1
  state 4: #4 #6
	<app> state 5
  state 5: #4 #6
	: state 6
	, state 9
  state 6: #6
	<var> state 7
  state 7: #6
	<var> state 8
  state 8: #6
  state 9: #4
	<var> state 10
  state 10: #4
	<var> state 11
  state 11: #4
  state 12: #5
  state 13: #3
}
{
  rule #0: x::matrix!i::int = __C::matrix_elem_at x i if i>=0&&i<#x
  rule #1: x::matrix!i::int = throw out_of_bounds
  rule #2: x::matrix!(i::int,j::int) = __C::matrix_elem_at2 x i j if (i>=0&&i<n&&j>=0&&j<m when n::int,m::int = dim x end)
  rule #3: x::matrix!(i::int,j::int) = throw out_of_bounds
  rule #4: x::matrix!y = __C::record_elem_at x y if recordp x
  rule #5: s::string!n::int = __C::string_char_at s n if n>=0&&n<#s
  rule #6: s::string!n::int = throw out_of_bounds
  rule #7: (x,xs)!n::int = throw out_of_bounds if n<0
  rule #8: (x,xs)!0 = x
  rule #9: (x,y,xs)!n::int = (y,xs)!(n-1)
  rule #10: (x,y)!1 = y
  rule #11: (x,y)!n::int = throw out_of_bounds
  rule #12: ()!n::int = throw out_of_bounds
  rule #13: []!n::int = throw out_of_bounds
  rule #14: (x:xs)!0 = x
  rule #15: (x:xs)!n::int = xs!(n-1) if n>0
  rule #16: (x:xs)!n::int = throw out_of_bounds
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16
	<var>::string state 1
	<var>::matrix state 3
	<app> state 19
	[] state 51
	() state 53
  state 1: #5 #6
	<var>::int state 2
  state 2: #5 #6
  state 3: #0 #1 #2 #3 #4
	<var> state 4
	<var>::int state 5
	<app> state 6
  state 4: #4
  state 5: #0 #1 #4
  state 6: #2 #3 #4
	<var> state 7
	<app> state 9
  state 7: #4
	<var> state 8
  state 8: #4
  state 9: #2 #3 #4
	<var> state 10
	, state 13
  state 10: #4
	<var> state 11
  state 11: #4
	<var> state 12
  state 12: #4
  state 13: #2 #3 #4
	<var> state 14
	<var>::int state 16
  state 14: #4
	<var> state 15
  state 15: #4
  state 16: #2 #3 #4
	<var> state 17
	<var>::int state 18
  state 17: #4
  state 18: #2 #3 #4
  state 19: #7 #8 #9 #10 #11 #14 #15 #16
	<app> state 20
  state 20: #7 #8 #9 #10 #11 #14 #15 #16
	: state 21
	, state 26
  state 21: #14 #15 #16
	<var> state 22
  state 22: #14 #15 #16
	<var> state 23
  state 23: #14 #15 #16
	<var>::int state 24
	0::int state 25
  state 24: #15 #16
  state 25: #14 #15 #16
  state 26: #7 #8 #9 #10 #11
	<var> state 27
  state 27: #7 #8 #9 #10 #11
	<var> state 28
	<app> state 32
  state 28: #7 #8 #10 #11
	<var>::int state 29
	0::int state 30
	1::int state 31
  state 29: #7 #11
  state 30: #7 #8 #11
  state 31: #7 #10 #11
  state 32: #7 #8 #9 #10 #11
	<var> state 33
	<app> state 38
  state 33: #7 #8 #10 #11
	<var> state 34
  state 34: #7 #8 #10 #11
	<var>::int state 35
	0::int state 36
	1::int state 37
  state 35: #7 #11
  state 36: #7 #8 #11
  state 37: #7 #10 #11
  state 38: #7 #8 #9 #10 #11
	<var> state 39
	, state 45
  state 39: #7 #8 #10 #11
	<var> state 40
  state 40: #7 #8 #10 #11
	<var> state 41
  state 41: #7 #8 #10 #11
	<var>::int state 42
	0::int state 43
	1::int state 44
  state 42: #7 #11
  state 43: #7 #8 #11
  state 44: #7 #10 #11
  state 45: #7 #8 #9 #10 #11
	<var> state 46
  state 46: #7 #8 #9 #10 #11
	<var> state 47
  state 47: #7 #8 #9 #10 #11
	<var>::int state 48
	0::int state 49
	1::int state 50
  state 48: #7 #9 #11
  state 49: #7 #8 #9 #11
  state 50: #7 #9 #10 #11
  state 51: #13
	<var>::int state 52
  state 52: #13
  state 53: #12
	<var>::int state 54
  state 54: #12
}
{
  rule #0: x!!ns::matrix = x!!list ns
  rule #1: x!!(ns::matrix,ms) = x!!(list ns,ms) if ~tuplep ms
  rule #2: x!!(ns,ms::matrix) = x!!(ns,list ms)
  rule #3: x!!(ns::int,ms) = x!!([ns],ms) if ~tuplep ms
  rule #4: x!!(ns,ms::int) = x!!(ns,[ms])
  rule #5: x::matrix!!(ns,ms) = case ns,ms of ns@(n:_),ms@(m:_) = submat x (n,m) (#ns,#ms) if cont ns&&cont ms; _ = colcatmap (mth (rowcatmap (nth x) ns)) ms end with cont [n::int] = 1; cont (n::int:ns@(m::int:_)) = cont ns if m==n+1; cont _ = 0; mth x m = catch (cst {}) (col x m); nth x n = catch (cst {}) (row x n) end
  rule #6: x::matrix!!ns = if all intp ns&&packed x then rowvector x!!([0],ns) else colcatmap (nth x) ns with nth x n = catch (cst {}) {x!n} end
  rule #7: s::string!!ns = case ns of ns@(n:_) = substr s n (count ns) if cont ns; _ = string (chars s!!ns) end with cont [n::int] = 1; cont (n::int:ns@(m::int:_)) = cont ns if m==n+1; cont _ = 0; count ns = #dropwhile (\n::int -> n<0) ns end
  rule #8: xs@()!!ns = tuple (list xs!!ns)
  rule #9: xs@(_,_)!!ns = tuple (list xs!!ns)
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9
	<var> state 1
	<var>::string state 17
	<var>::matrix state 40
	<app> state 63
	() state 125
  state 1: #0 #1 #2 #3 #4
	<var>::matrix state 2
	<app> state 3
  state 2: #0
  state 3: #1 #2 #3 #4
	<app> state 4
  state 4: #1 #2 #3 #4
	, state 5
  state 5: #1 #2 #3 #4
	<var> state 6
	<var>::int state 9
	<var>::matrix state 13
  state 6: #2 #4
	<var>::int state 7
	<var>::matrix state 8
  state 7: #4
  state 8: #2
  state 9: #2 #3 #4
	<var> state 10
	<var>::int state 11
	<var>::matrix state 12
  state 10: #3
  state 11: #3 #4
  state 12: #2 #3
  state 13: #1 #2 #4
	<var> state 14
	<var>::int state 15
	<var>::matrix state 16
  state 14: #1
  state 15: #1 #4
  state 16: #1 #2
  state 17: #0 #1 #2 #3 #4 #7
	<var> state 18
	<var>::matrix state 19
	<app> state 20
  state 18: #7
  state 19: #0 #7
  state 20: #1 #2 #3 #4 #7
	<var> state 21
	<app> state 23
  state 21: #7
	<var> state 22
  state 22: #7
  state 23: #1 #2 #3 #4 #7
	<var> state 24
	, state 27
  state 24: #7
	<var> state 25
  state 25: #7
	<var> state 26
  state 26: #7
  state 27: #1 #2 #3 #4 #7
	<var> state 28
	<var>::int state 32
	<var>::matrix state 36
  state 28: #2 #4 #7
	<var> state 29
	<var>::int state 30
	<var>::matrix state 31
  state 29: #7
  state 30: #4 #7
  state 31: #2 #7
  state 32: #2 #3 #4 #7
	<var> state 33
	<var>::int state 34
	<var>::matrix state 35
  state 33: #3 #7
  state 34: #3 #4 #7
  state 35: #2 #3 #7
  state 36: #1 #2 #4 #7
	<var> state 37
	<var>::int state 38
	<var>::matrix state 39
  state 37: #1 #7
  state 38: #1 #4 #7
  state 39: #1 #2 #7
  state 40: #0 #1 #2 #3 #4 #5 #6
	<var> state 41
	<var>::matrix state 42
	<app> state 43
  state 41: #6
  state 42: #0 #6
  state 43: #1 #2 #3 #4 #5 #6
	<var> state 44
	<app> state 46
  state 44: #6
	<var> state 45
  state 45: #6
  state 46: #1 #2 #3 #4 #5 #6
	<var> state 47
	, state 50
  state 47: #6
	<var> state 48
  state 48: #6
	<var> state 49
  state 49: #6
  state 50: #1 #2 #3 #4 #5 #6
	<var> state 51
	<var>::int state 55
	<var>::matrix state 59
  state 51: #2 #4 #5 #6
	<var> state 52
	<var>::int state 53
	<var>::matrix state 54
  state 52: #5 #6
  state 53: #4 #5 #6
  state 54: #2 #5 #6
  state 55: #2 #3 #4 #5 #6
	<var> state 56
	<var>::int state 57
	<var>::matrix state 58
  state 56: #3 #5 #6
  state 57: #3 #4 #5 #6
  state 58: #2 #3 #5 #6
  state 59: #1 #2 #4 #5 #6
	<var> state 60
	<var>::int state 61
	<var>::matrix state 62
  state 60: #1 #5 #6
  state 61: #1 #4 #5 #6
  state 62: #1 #2 #5 #6
  state 63: #0 #1 #2 #3 #4 #9
	<var> state 64
	<app> state 81
  state 64: #0 #1 #2 #3 #4
	<var> state 65
  state 65: #0 #1 #2 #3 #4
	<var>::matrix state 66
	<app> state 67
  state 66: #0
  state 67: #1 #2 #3 #4
	<app> state 68
  state 68: #1 #2 #3 #4
	, state 69
  state 69: #1 #2 #3 #4
	<var> state 70
	<var>::int state 73
	<var>::matrix state 77
  state 70: #2 #4
	<var>::int state 71
	<var>::matrix state 72
  state 71: #4
  state 72: #2
  state 73: #2 #3 #4
	<var> state 74
	<var>::int state 75
	<var>::matrix state 76
  state 74: #3
  state 75: #3 #4
  state 76: #2 #3
  state 77: #1 #2 #4
	<var> state 78
	<var>::int state 79
	<var>::matrix state 80
  state 78: #1
  state 79: #1 #4
  state 80: #1 #2
  state 81: #0 #1 #2 #3 #4 #9
	<var> state 82
	, state 100
  state 82: #0 #1 #2 #3 #4
	<var> state 83
  state 83: #0 #1 #2 #3 #4
	<var> state 84
  state 84: #0 #1 #2 #3 #4
	<var>::matrix state 85
	<app> state 86
  state 85: #0
  state 86: #1 #2 #3 #4
	<app> state 87
  state 87: #1 #2 #3 #4
	, state 88
  state 88: #1 #2 #3 #4
	<var> state 89
	<var>::int state 92
	<var>::matrix state 96
  state 89: #2 #4
	<var>::int state 90
	<var>::matrix state 91
  state 90: #4
  state 91: #2
  state 92: #2 #3 #4
	<var> state 93
	<var>::int state 94
	<var>::matrix state 95
  state 93: #3
  state 94: #3 #4
  state 95: #2 #3
  state 96: #1 #2 #4
	<var> state 97
	<var>::int state 98
	<var>::matrix state 99
  state 97: #1
  state 98: #1 #4
  state 99: #1 #2
  state 100: #0 #1 #2 #3 #4 #9
	<var> state 101
  state 101: #0 #1 #2 #3 #4 #9
	<var> state 102
  state 102: #0 #1 #2 #3 #4 #9
	<var> state 103
	<var>::matrix state 104
	<app> state 105
  state 103: #9
  state 104: #0 #9
  state 105: #1 #2 #3 #4 #9
	<var> state 106
	<app> state 108
  state 106: #9
	<var> state 107
  state 107: #9
  state 108: #1 #2 #3 #4 #9
	<var> state 109
	, state 112
  state 109: #9
	<var> state 110
  state 110: #9
	<var> state 111
  state 111: #9
  state 112: #1 #2 #3 #4 #9
	<var> state 113
	<var>::int state 117
	<var>::matrix state 121
  state 113: #2 #4 #9
	<var> state 114
	<var>::int state 115
	<var>::matrix state 116
  state 114: #9
  state 115: #4 #9
  state 116: #2 #9
  state 117: #2 #3 #4 #9
	<var> state 118
	<var>::int state 119
	<var>::matrix state 120
  state 118: #3 #9
  state 119: #3 #4 #9
  state 120: #2 #3 #9
  state 121: #1 #2 #4 #9
	<var> state 122
	<var>::int state 123
	<var>::matrix state 124
  state 122: #1 #9
  state 123: #1 #4 #9
  state 124: #1 #2 #9
  state 125: #0 #1 #2 #3 #4 #8
	<var> state 126
	<var>::matrix state 127
	<app> state 128
  state 126: #8
  state 127: #0 #8
  state 128: #1 #2 #3 #4 #8
	<var> state 129
	<app> state 131
  state 129: #8
	<var> state 130
  state 130: #8
  state 131: #1 #2 #3 #4 #8
	<var> state 132
	, state 135
  state 132: #8
	<var> state 133
  state 133: #8
	<var> state 134
  state 134: #8
  state 135: #1 #2 #3 #4 #8
	<var> state 136
	<var>::int state 140
	<var>::matrix state 144
  state 136: #2 #4 #8
	<var> state 137
	<var>::int state 138
	<var>::matrix state 139
  state 137: #8
  state 138: #4 #8
  state 139: #2 #8
  state 140: #2 #3 #4 #8
	<var> state 141
	<var>::int state 142
	<var>::matrix state 143
  state 141: #3 #8
  state 142: #3 #4 #8
  state 143: #2 #3 #8
  state 144: #1 #2 #4 #8
	<var> state 145
	<var>::int state 146
	<var>::matrix state 147
  state 145: #1 #8
  state 146: #1 #4 #8
  state 147: #1 #2 #8
}
{
  rule #0: (f.g) x = f (g x)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}
{
  rule #0: val (x=>v) = v
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	=> state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}
{
  rule #0: ord s::string = n if intp n when n = __C::string_ord s end
  state 0: #0
	<var>::string state 1
  state 1: #0
}
{
  rule #0: list x::matrix = listmap (\i -> x!i) (0..#x-1)
  rule #1: list s::string = chars s
  state 0: #0 #1
	<var>::string state 1
	<var>::matrix state 2
  state 1: #1
  state 2: #0
}
{
  rule #0: tuple x::matrix = tuple (list x)
  rule #1: tuple s::string = tuple (chars s)
  state 0: #0 #1
	<var>::string state 1
	<var>::matrix state 2
  state 1: #1
  state 2: #0
}
{
  rule #0: null x::pointer = x===#<pointer 0> if __C::pure_pointer_equal (get_ptrtag x)===#<pointer 0>
  rule #1: null x::matrix = #x==0
  rule #2: null s::string = __C::string_null s
  rule #3: null () = 1
  rule #4: null (x,xs) = 0
  rule #5: null [] = 1
  rule #6: null (x:xs) = 0
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var>::string state 1
	<var>::pointer state 2
	<var>::matrix state 3
	<app> state 4
	[] state 12
	() state 13
  state 1: #2
  state 2: #0
  state 3: #1
  state 4: #4 #6
	<app> state 5
  state 5: #4 #6
	: state 6
	, state 9
  state 6: #6
	<var> state 7
  state 7: #6
	<var> state 8
  state 8: #6
  state 9: #4
	<var> state 10
  state 10: #4
	<var> state 11
  state 11: #4
  state 12: #5
  state 13: #3
}
{
  rule #0: sort p x::matrix = case sort p (smatrix x) of y::matrix = imatrix y if imatrixp x; y::matrix = dmatrix y if dmatrixp x; y::matrix = cmatrix y if cmatrixp x; y = y end
  state 0: #0
	<var> state 1
  state 1: #0
	<var>::matrix state 2
  state 2: #0
}
{
  rule #0: ref x = __C::pointer_put_expr r (__C::pure_new x)$$sentry (unref clear_sentry) r when r::pointer = __C::pure_expr_pointer end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: unref next r::ref = __C::pure_free (__C::pointer_get_expr r)$$next r
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: refp r = case r of _::pointer = case get_sentry r of unref _ = 1; _ = 0 end; _ = 0 end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: put r::ref x = __C::pure_free (__C::pointer_get_expr r)$$__C::pointer_put_expr r (__C::pure_new x)$$x
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: get r::ref = __C::pointer_get_expr r
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: all p x::matrix = __C::matrix_all p x
  rule #1: all p s::string = all p (chars s)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::string state 2
	<var>::matrix state 3
  state 2: #1
  state 3: #0
}
{
  rule #0: any p x::matrix = __C::matrix_any p x
  rule #1: any p s::string = any p (chars s)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::string state 2
	<var>::matrix state 3
  state 2: #1
  state 3: #0
}
{
  rule #0: cst x y = x
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: do f x::matrix = __C::matrix_do f x
  rule #1: do f s::string = do f (chars s)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::string state 2
	<var>::matrix state 3
  state 2: #1
  state 3: #0
}
{
  rule #0: map f x::matrix = __C::matrix_map f x
  rule #1: map f s::string = map f (chars s)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::string state 2
	<var>::matrix state 3
  state 2: #1
  state 3: #0
}
{
  rule #0: reverse x::matrix = rowrev (colrev x)
  rule #1: reverse s::string = strcat (reverse (chars s))
  rule #2: reverse () = ()
  rule #3: reverse (x,xs) = accum x xs with accum ys (x,xs) = accum (x,ys) xs; accum ys x = x,ys end
  state 0: #0 #1 #2 #3
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
	() state 8
  state 1: #1
  state 2: #0
  state 3: #3
	<app> state 4
  state 4: #3
	, state 5
  state 5: #3
	<var> state 6
  state 6: #3
	<var> state 7
  state 7: #3
  state 8: #2
}
{
  rule #0: uncurry f (x,y) = f x y
  state 0: #0
	<var> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
}
{
  rule #0: uncurry3 f (x,y,z) = f x y z
  state 0: #0
	<var> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	<app> state 7
  state 7: #0
	, state 8
  state 8: #0
	<var> state 9
  state 9: #0
	<var> state 10
  state 10: #0
}
{
  rule #0: vector1 z = __C::vector1 1 z
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: vector2 y z = __C::vector2 2 y z
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: vector3 x y z = __C::vector3 3 x y z
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}
{
  rule #0: dmatrixp x = case x of _::matrix = matrix_type x==1; _ = 0 end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: cmatrixp x = case x of _::matrix = matrix_type x==2; _ = 0 end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: imatrixp x = case x of _::matrix = matrix_type x==3; _ = 0 end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: nmatrixp x = case x of _::matrix = matrix_type x>=1; _ = 0 end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: smatrixp x = case x of _::matrix = matrix_type x==0; _ = 0 end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: dmatrix (n::int,m::int) = double_matrix (n,m) #<pointer 0>
  rule #1: dmatrix n::int = dmatrix (1,n)
  rule #2: dmatrix x = y if matrixp y when y = __C::matrix_double x end
  state 0: #0 #1 #2
	<var> state 1
	<var>::int state 2
	<app> state 3
  state 1: #2
  state 2: #1 #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	, state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
	<var>::int state 13
  state 11: #2
	<var> state 12
  state 12: #2
  state 13: #0 #2
	<var> state 14
	<var>::int state 15
  state 14: #2
  state 15: #0 #2
}
{
  rule #0: imatrix (n::int,m::int) = int_matrix (n,m) #<pointer 0>
  rule #1: imatrix n::int = imatrix (1,n)
  rule #2: imatrix x = y if matrixp y when y = __C::matrix_int x end
  state 0: #0 #1 #2
	<var> state 1
	<var>::int state 2
	<app> state 3
  state 1: #2
  state 2: #1 #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	, state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
	<var>::int state 13
  state 11: #2
	<var> state 12
  state 12: #2
  state 13: #0 #2
	<var> state 14
	<var>::int state 15
  state 14: #2
  state 15: #0 #2
}
{
  rule #0: cmatrix (n::int,m::int) = complex_matrix (n,m) #<pointer 0>
  rule #1: cmatrix n::int = cmatrix (1,n)
  rule #2: cmatrix x = y if matrixp y when y = __C::matrix_complex x end
  state 0: #0 #1 #2
	<var> state 1
	<var>::int state 2
	<app> state 3
  state 1: #2
  state 2: #1 #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	, state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
	<var>::int state 13
  state 11: #2
	<var> state 12
  state 12: #2
  state 13: #0 #2
	<var> state 14
	<var>::int state 15
  state 14: #2
  state 15: #0 #2
}
{
  rule #0: smatrix x = y if matrixp y when y = __C::matrix_symbolic x end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: dim x::matrix = __C::matrix_dim x
  state 0: #0
	<var>::matrix state 1
  state 1: #0
}
{
  rule #0: vectorp x = matrixp x&&(n==1||m==1 when n::int,m::int = dim x end)
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: rowvectorp x = matrixp x&&dim x!0==1
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: colvectorp x = matrixp x&&dim x!1==1
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: stride x::matrix = __C::matrix_stride x
  state 0: #0
	<var>::matrix state 1
  state 1: #0
}
{
  rule #0: col x::matrix j::int = if j>=0&&j<m then __C::matrix_slice x 0 j (n-1) j else throw out_of_bounds when n::int,m::int = dim x end
  state 0: #0
	<var>::matrix state 1
  state 1: #0
	<var>::int state 2
  state 2: #0
}
{
  rule #0: row x::matrix i::int = if i>=0&&i<n then __C::matrix_slice x i 0 i (m-1) else throw out_of_bounds when n::int,m::int = dim x end
  state 0: #0
	<var>::matrix state 1
  state 1: #0
	<var>::int state 2
  state 2: #0
}
{
  rule #0: rowvector x::matrix = redim (1,#x) x
  rule #1: rowvector () = redim (1,0) {}
  rule #2: rowvector xs@(_,_) = rowvector (list xs)
  rule #3: rowvector [] = redim (1,0) {}
  rule #4: rowvector xs::rlist = case cmatrix xs of x::matrix = x; _ = case dmatrix xs of x::matrix = x; _ = case imatrix xs of x::matrix = x; _ = smatrix xs end end end
  state 0: #0 #1 #2 #3 #4
	<var> state 1
	<var>::matrix state 2
	<app> state 3
	[] state 13
	() state 14
  state 1: #4
  state 2: #0 #4
  state 3: #2 #4
	<var> state 4
	<app> state 6
  state 4: #4
	<var> state 5
  state 5: #4
  state 6: #2 #4
	<var> state 7
	, state 10
  state 7: #4
	<var> state 8
  state 8: #4
	<var> state 9
  state 9: #4
  state 10: #2 #4
	<var> state 11
  state 11: #2 #4
	<var> state 12
  state 12: #2 #4
  state 13: #3 #4
  state 14: #1 #4
}
{
  rule #0: submat x::matrix (i::int,j::int) (n::int,m::int) = __C::matrix_slice x i j (i+n-1) (j+m-1)
  state 0: #0
	<var>::matrix state 1
  state 1: #0
	<app> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var>::int state 5
  state 5: #0
	<var>::int state 6
  state 6: #0
	<app> state 7
  state 7: #0
	<app> state 8
  state 8: #0
	, state 9
  state 9: #0
	<var>::int state 10
  state 10: #0
	<var>::int state 11
  state 11: #0
}
{
  rule #0: packed x::matrix = stride x==dim x!1
  state 0: #0
	<var>::matrix state 1
  state 1: #0
}
{
  rule #0: subseq2 x::matrix a1::int b1::int a2::int b2::int = __C::matrix_slice x a1 a2 b1 b2
  rule #1: subseq2 x a1 a1 a2 b2 = slice x (a1,a2..b2)
  rule #2: subseq2 x a1 b1 a2 a2 = slice x (a1..b1,a2)
  rule #3: subseq2 x a1 b1 a2 b2 = slice x (a1..b1,a2..b2)
  state 0: #0 #1 #2 #3
	<var> state 1
	<var>::matrix state 6
  state 1: #1 #2 #3
	<var> state 2
  state 2: #1 #2 #3
	<var> state 3
  state 3: #1 #2 #3
	<var> state 4
  state 4: #1 #2 #3
	<var> state 5
  state 5: #1 #2 #3
  state 6: #0 #1 #2 #3
	<var> state 7
	<var>::int state 11
  state 7: #1 #2 #3
	<var> state 8
  state 8: #1 #2 #3
	<var> state 9
  state 9: #1 #2 #3
	<var> state 10
  state 10: #1 #2 #3
  state 11: #0 #1 #2 #3
	<var> state 12
	<var>::int state 15
  state 12: #1 #2 #3
	<var> state 13
  state 13: #1 #2 #3
	<var> state 14
  state 14: #1 #2 #3
  state 15: #0 #1 #2 #3
	<var> state 16
	<var>::int state 18
  state 16: #1 #2 #3
	<var> state 17
  state 17: #1 #2 #3
  state 18: #0 #1 #2 #3
	<var> state 19
	<var>::int state 20
  state 19: #1 #2 #3
  state 20: #0 #1 #2 #3
}
{
  rule #0: subseq x::matrix a::int b::int = __C::matrix_slice (rowvector x) 0 a 0 b
  rule #1: subseq s::string a::int b::int = substr s a (b-a+1)
  state 0: #0 #1
	<var>::string state 1
	<var>::matrix state 4
  state 1: #1
	<var>::int state 2
  state 2: #1
	<var>::int state 3
  state 3: #1
  state 4: #0
	<var>::int state 5
  state 5: #0
	<var>::int state 6
  state 6: #0
}
{
  rule #0: rows x::matrix = map (row x) (0..n-1) when n::int,_ = dim x end
  state 0: #0
	<var>::matrix state 1
  state 1: #0
}
{
  rule #0: cols x::matrix = map (col x) (0..m-1) when _,m::int = dim x end
  state 0: #0
	<var>::matrix state 1
  state 1: #0
}
{
  rule #0: list2 x::matrix = listmap (\i -> listmap (\j -> x!(i,j)) (0..m-1)) (0..n-1) when n::int,m::int = dim x end
  state 0: #0
	<var>::matrix state 1
  state 1: #0
}
{
  rule #0: int_matrix (n::int,m::int) p::pointer = __C::matrix_from_int_array n m p
  rule #1: int_matrix n::int p::pointer = int_matrix (1,n) p
  state 0: #0 #1
	<var>::int state 1
	<app> state 3
  state 1: #1
	<var>::pointer state 2
  state 2: #1
  state 3: #0
	<app> state 4
  state 4: #0
	, state 5
  state 5: #0
	<var>::int state 6
  state 6: #0
	<var>::int state 7
  state 7: #0
	<var>::pointer state 8
  state 8: #0
}
{
  rule #0: double_matrix (n::int,m::int) p::pointer = __C::matrix_from_double_array n m p
  rule #1: double_matrix n::int p::pointer = double_matrix (1,n) p
  state 0: #0 #1
	<var>::int state 1
	<app> state 3
  state 1: #1
	<var>::pointer state 2
  state 2: #1
  state 3: #0
	<app> state 4
  state 4: #0
	, state 5
  state 5: #0
	<var>::int state 6
  state 6: #0
	<var>::int state 7
  state 7: #0
	<var>::pointer state 8
  state 8: #0
}
{
  rule #0: complex_matrix (n::int,m::int) p::pointer = __C::matrix_from_complex_array n m p
  rule #1: complex_matrix n::int p::pointer = complex_matrix (1,n) p
  state 0: #0 #1
	<var>::int state 1
	<app> state 3
  state 1: #1
	<var>::pointer state 2
  state 2: #1
  state 3: #0
	<app> state 4
  state 4: #0
	, state 5
  state 5: #0
	<var>::int state 6
  state 6: #0
	<var>::int state 7
  state 7: #0
	<var>::pointer state 8
  state 8: #0
}
{
  rule #0: redim (n::int,m::int) x::matrix = __C::matrix_redim x n m if n>=0&&m>=0&&n*m==#x
  rule #1: redim m::int x::matrix = redim (#x div m,m) x if m>0&&#x mod m==0
  rule #2: redim m::int x::matrix = x if m==0&&#x==0
  state 0: #0 #1 #2
	<var>::int state 1
	<app> state 3
  state 1: #1 #2
	<var>::matrix state 2
  state 2: #1 #2
  state 3: #0
	<app> state 4
  state 4: #0
	, state 5
  state 5: #0
	<var>::int state 6
  state 6: #0
	<var>::int state 7
  state 7: #0
	<var>::matrix state 8
  state 8: #0
}
{
  rule #0: colvector x::matrix = redim (#x,1) x
  rule #1: colvector () = redim (0,1) {}
  rule #2: colvector xs@(_,_) = colvector (list xs)
  rule #3: colvector xs = redim (#x,1) x if matrixp x when x = rowvector xs end
  state 0: #0 #1 #2 #3
	<var> state 1
	<var>::matrix state 2
	<app> state 3
	() state 13
  state 1: #3
  state 2: #0 #3
  state 3: #2 #3
	<var> state 4
	<app> state 6
  state 4: #3
	<var> state 5
  state 5: #3
  state 6: #2 #3
	<var> state 7
	, state 10
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #2 #3
	<var> state 11
  state 11: #2 #3
	<var> state 12
  state 12: #2 #3
  state 13: #1 #3
}
{
  rule #0: vector xs = x if matrixp x when x = rowvector xs end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: rowvectorseq n::int m::int s::int = __C::pure_int_rowvect n m s
  rule #1: rowvectorseq n::double m::double s::double = __C::pure_double_rowvect n m s
  rule #2: rowvectorseq n::int m::double s::double = __C::pure_double_rowvect (double n) (double m) (double s)
  rule #3: rowvectorseq n::double m::int s::double = __C::pure_double_rowvect (double n) (double m) (double s)
  rule #4: rowvectorseq n::double m::double s::int = __C::pure_double_rowvect (double n) (double m) (double s)
  rule #5: rowvectorseq n::int m::int s::double = __C::pure_double_rowvect (double n) (double m) (double s)
  rule #6: rowvectorseq n::int m::double s::int = __C::pure_double_rowvect (double n) (double m) (double s)
  rule #7: rowvectorseq n::double m::int s::int = __C::pure_double_rowvect (double n) (double m) (double s)
  rule #8: rowvectorseq n m s = x if matrixp x when x = rowvector (n:n+s..m) end
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8
	<var> state 1
	<var>::int state 4
	<var>::double state 15
  state 1: #8
	<var> state 2
  state 2: #8
	<var> state 3
  state 3: #8
  state 4: #0 #2 #5 #6 #8
	<var> state 5
	<var>::int state 7
	<var>::double state 11
  state 5: #8
	<var> state 6
  state 6: #8
  state 7: #0 #5 #8
	<var> state 8
	<var>::int state 9
	<var>::double state 10
  state 8: #8
  state 9: #0 #8
  state 10: #5 #8
  state 11: #2 #6 #8
	<var> state 12
	<var>::int state 13
	<var>::double state 14
  state 12: #8
  state 13: #6 #8
  state 14: #2 #8
  state 15: #1 #3 #4 #7 #8
	<var> state 16
	<var>::int state 18
	<var>::double state 22
  state 16: #8
	<var> state 17
  state 17: #8
  state 18: #3 #7 #8
	<var> state 19
	<var>::int state 20
	<var>::double state 21
  state 19: #8
  state 20: #7 #8
  state 21: #3 #8
  state 22: #1 #4 #8
	<var> state 23
	<var>::int state 24
	<var>::double state 25
  state 23: #8
  state 24: #4 #8
  state 25: #1 #8
}
{
  rule #0: colvectorseq n::int m::int s::int = __C::pure_int_colvect n m s
  rule #1: colvectorseq n::double m::double s::double = __C::pure_double_colvect n m s
  rule #2: colvectorseq n::int m::double s::double = __C::pure_double_colvect (double n) (double m) (double s)
  rule #3: colvectorseq n::double m::int s::double = __C::pure_double_colvect (double n) (double m) (double s)
  rule #4: colvectorseq n::double m::double s::int = __C::pure_double_colvect (double n) (double m) (double s)
  rule #5: colvectorseq n::int m::int s::double = __C::pure_double_colvect (double n) (double m) (double s)
  rule #6: colvectorseq n::int m::double s::int = __C::pure_double_colvect (double n) (double m) (double s)
  rule #7: colvectorseq n::double m::int s::int = __C::pure_double_colvect (double n) (double m) (double s)
  rule #8: colvectorseq n m s = x if matrixp x when x = colvector (n:n+s..m) end
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8
	<var> state 1
	<var>::int state 4
	<var>::double state 15
  state 1: #8
	<var> state 2
  state 2: #8
	<var> state 3
  state 3: #8
  state 4: #0 #2 #5 #6 #8
	<var> state 5
	<var>::int state 7
	<var>::double state 11
  state 5: #8
	<var> state 6
  state 6: #8
  state 7: #0 #5 #8
	<var> state 8
	<var>::int state 9
	<var>::double state 10
  state 8: #8
  state 9: #0 #8
  state 10: #5 #8
  state 11: #2 #6 #8
	<var> state 12
	<var>::int state 13
	<var>::double state 14
  state 12: #8
  state 13: #6 #8
  state 14: #2 #8
  state 15: #1 #3 #4 #7 #8
	<var> state 16
	<var>::int state 18
	<var>::double state 22
  state 16: #8
	<var> state 17
  state 17: #8
  state 18: #3 #7 #8
	<var> state 19
	<var>::int state 20
	<var>::double state 21
  state 19: #8
  state 20: #7 #8
  state 21: #3 #8
  state 22: #1 #4 #8
	<var> state 23
	<var>::int state 24
	<var>::double state 25
  state 23: #8
  state 24: #4 #8
  state 25: #1 #8
}
{
  rule #0: vectorseq n m s = x if matrixp x when x = rowvectorseq n m s end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}
{
  rule #0: re x::matrix = __C::matrix_re x if nmatrixp x
  state 0: #0
	<var>::matrix state 1
  state 1: #0
}
{
  rule #0: im x::matrix = __C::matrix_im x if nmatrixp x
  state 0: #0
	<var>::matrix state 1
  state 1: #0
}
{
  rule #0: conj x::matrix = __C::matrix_conj x if nmatrixp x
  state 0: #0
	<var>::matrix state 1
  state 1: #0
}
{
  rule #0: pack x::matrix = colcat [x,{}]
  state 0: #0
	<var>::matrix state 1
  state 1: #0
}
{
  rule #0: transpose x::matrix = __C::matrix_transpose x
  state 0: #0
	<var>::matrix state 1
  state 1: #0
}
{
  rule #0: rowrev x::matrix = rowcat (__std__::reverse_onto [] (rows x))
  state 0: #0
	<var>::matrix state 1
  state 1: #0
}
{
  rule #0: colrev x::matrix = colcat (__std__::reverse_onto [] (cols x))
  state 0: #0
	<var>::matrix state 1
  state 1: #0
}
{
  rule #0: cycle x::matrix = cycle (list x)
  rule #1: cycle s::string = cycle (chars s)
  state 0: #0 #1
	<var>::string state 1
	<var>::matrix state 2
  state 1: #1
  state 2: #0
}
{
  rule #0: cyclen n::int x::matrix = cyclen n (list x) if ~null x
  rule #1: cyclen n::int s::string = cyclen n (chars s) if ~null s
  state 0: #0 #1
	<var>::int state 1
  state 1: #0 #1
	<var>::string state 2
	<var>::matrix state 3
  state 2: #1
  state 3: #0
}
{
  rule #0: drop k::int x::matrix = x!!(k..#x-1)
  rule #1: drop n::int s::string = substr s n 2147483647
  state 0: #0 #1
	<var>::int state 1
  state 1: #0 #1
	<var>::string state 2
	<var>::matrix state 3
  state 2: #1
  state 3: #0
}
{
  rule #0: dropwhile p x::matrix = __C::matrix_dropwhile p x
  rule #1: dropwhile p s::string = strcat (dropwhile p (chars s))
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::string state 2
	<var>::matrix state 3
  state 2: #1
  state 3: #0
}
{
  rule #0: filter p x::matrix = __C::matrix_filter p x
  rule #1: filter p s::string = strcat (filter p (chars s))
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::string state 2
	<var>::matrix state 3
  state 2: #1
  state 3: #0
}
{
  rule #0: foldl f a x::matrix = __C::matrix_foldl f a x
  rule #1: foldl f a s::string = foldl f a (chars s)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
	<var>::string state 3
	<var>::matrix state 4
  state 3: #1
  state 4: #0
}
{
  rule #0: foldl1 f x::matrix = __C::matrix_foldl1 f x if ~null x
  rule #1: foldl1 f s::string = foldl1 f (chars s)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::string state 2
	<var>::matrix state 3
  state 2: #1
  state 3: #0
}
{
  rule #0: foldr f a x::matrix = __C::matrix_foldr f a x
  rule #1: foldr f a s::string = foldr f a (chars s)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
	<var>::string state 3
	<var>::matrix state 4
  state 3: #1
  state 4: #0
}
{
  rule #0: foldr1 f x::matrix = __C::matrix_foldr1 f x if ~null x
  rule #1: foldr1 f s::string = foldr1 f (chars s)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::string state 2
	<var>::matrix state 3
  state 2: #1
  state 3: #0
}
{
  rule #0: head x::matrix = x!0 if ~null x
  rule #1: head s::string = s!0 if ~null s
  state 0: #0 #1
	<var>::string state 1
	<var>::matrix state 2
  state 1: #1
  state 2: #0
}
{
  rule #0: init x::matrix = x!!(0..#x-2) if ~null x
  rule #1: init s::string = substr s 0 (#s-1) if ~null s
  state 0: #0 #1
	<var>::string state 1
	<var>::matrix state 2
  state 1: #1
  state 2: #0
}
{
  rule #0: last x::matrix = x!(#x-1) if ~null x
  rule #1: last s::string = s!(#s-1) if ~null s
  state 0: #0 #1
	<var>::string state 1
	<var>::matrix state 2
  state 1: #1
  state 2: #0
}
{
  rule #0: scanl f a x::matrix = __C::matrix_scanl f a x
  rule #1: scanl f a s::string = scanl f a (chars s)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
	<var>::string state 3
	<var>::matrix state 4
  state 3: #1
  state 4: #0
}
{
  rule #0: scanl1 f x::matrix = __C::matrix_scanl1 f x
  rule #1: scanl1 f s::string = scanl1 f (chars s)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::string state 2
	<var>::matrix state 3
  state 2: #1
  state 3: #0
}
{
  rule #0: scanr f a x::matrix = __C::matrix_scanr f a x
  rule #1: scanr f a s::string = scanr f a (chars s)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
	<var>::string state 3
	<var>::matrix state 4
  state 3: #1
  state 4: #0
}
{
  rule #0: scanr1 f x::matrix = __C::matrix_scanr1 f x
  rule #1: scanr1 f s::string = scanr1 f (chars s)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::string state 2
	<var>::matrix state 3
  state 2: #1
  state 3: #0
}
{
  rule #0: take k::int x::matrix = x!!(0..k-1)
  rule #1: take n::int s::string = substr s 0 n
  state 0: #0 #1
	<var>::int state 1
  state 1: #0 #1
	<var>::string state 2
	<var>::matrix state 3
  state 2: #1
  state 3: #0
}
{
  rule #0: takewhile p x::matrix = __C::matrix_takewhile p x
  rule #1: takewhile p s::string = strcat (takewhile p (chars s))
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::string state 2
	<var>::matrix state 3
  state 2: #1
  state 3: #0
}
{
  rule #0: tail x::matrix = x!!(1..#x-1) if ~null x
  rule #1: tail s::string = substr s 1 (#s-1) if ~null s
  state 0: #0 #1
	<var>::string state 1
	<var>::matrix state 2
  state 1: #1
  state 2: #0
}
{
  rule #0: zipwith f x::matrix y::matrix = __C::matrix_zipwith f x y
  rule #1: zipwith f s::string t::string = zipwith f (chars s) (chars t)
  rule #2: zipwith f s t::string = zipwith f s (chars t)
  rule #3: zipwith f s::string t = zipwith f (chars s) t
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<var>::string state 4
	<var>::matrix state 7
  state 2: #2
	<var>::string state 3
  state 3: #2
  state 4: #1 #2 #3
	<var> state 5
	<var>::string state 6
  state 5: #3
  state 6: #1 #2 #3
  state 7: #0 #2
	<var>::string state 8
	<var>::matrix state 9
  state 8: #2
  state 9: #0
}
{
  rule #0: zipwith3 f x::matrix y::matrix z::matrix = __C::matrix_zipwith3 f x y z
  rule #1: zipwith3 f s::string t::string u::string = zipwith3 f (chars s) (chars t) (chars u)
  rule #2: zipwith3 f s::string t::string u = zipwith3 f (chars s) (chars t) u
  rule #3: zipwith3 f s::string t u::string = zipwith3 f (chars s) t (chars u)
  rule #4: zipwith3 f s::string t u = zipwith3 f (chars s) t u
  rule #5: zipwith3 f s t::string u::string = zipwith3 f s (chars t) (chars u)
  rule #6: zipwith3 f s t::string u = zipwith3 f s (chars t) u
  rule #7: zipwith3 f s t u::string = zipwith3 f s t (chars u)
  state 0: #0 #1 #2 #3 #4 #5 #6 #7
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5 #6 #7
	<var> state 2
	<var>::string state 8
	<var>::matrix state 15
  state 2: #5 #6 #7
	<var> state 3
	<var>::string state 5
  state 3: #7
	<var>::string state 4
  state 4: #7
  state 5: #5 #6 #7
	<var> state 6
	<var>::string state 7
  state 6: #6
  state 7: #5 #6 #7
  state 8: #1 #2 #3 #4 #5 #6 #7
	<var> state 9
	<var>::string state 12
  state 9: #3 #4 #7
	<var> state 10
	<var>::string state 11
  state 10: #4
  state 11: #3 #4 #7
  state 12: #1 #2 #3 #4 #5 #6 #7
	<var> state 13
	<var>::string state 14
  state 13: #2 #4 #6
  state 14: #1 #2 #3 #4 #5 #6 #7
  state 15: #0 #5 #6 #7
	<var> state 16
	<var>::string state 18
	<var>::matrix state 21
  state 16: #7
	<var>::string state 17
  state 17: #7
  state 18: #5 #6 #7
	<var> state 19
	<var>::string state 20
  state 19: #6
  state 20: #5 #6 #7
  state 21: #0 #7
	<var>::string state 22
	<var>::matrix state 23
  state 22: #7
  state 23: #0
}
{
  rule #0: zip x::matrix y::matrix = zipwith (,) x y
  rule #1: zip s::string t::string = zip (chars s) (chars t)
  rule #2: zip s t::string = zip s (chars t)
  rule #3: zip s::string t = zip (chars s) t
  state 0: #0 #1 #2 #3
	<var> state 1
	<var>::string state 3
	<var>::matrix state 6
  state 1: #2
	<var>::string state 2
  state 2: #2
  state 3: #1 #2 #3
	<var> state 4
	<var>::string state 5
  state 4: #3
  state 5: #1 #2 #3
  state 6: #0 #2
	<var>::string state 7
	<var>::matrix state 8
  state 7: #2
  state 8: #0
}
{
  rule #0: zip3 x::matrix y::matrix z::matrix = zipwith3 (\x y z -> x,y,z) x y z
  rule #1: zip3 s::string t::string u::string = zip3 (chars s) (chars t) (chars u)
  rule #2: zip3 s::string t::string u = zip3 (chars s) (chars t) u
  rule #3: zip3 s::string t u::string = zip3 (chars s) t (chars u)
  rule #4: zip3 s::string t u = zip3 (chars s) t u
  rule #5: zip3 s t::string u::string = zip3 s (chars t) (chars u)
  rule #6: zip3 s t::string u = zip3 s (chars t) u
  rule #7: zip3 s t u::string = zip3 s t (chars u)
  state 0: #0 #1 #2 #3 #4 #5 #6 #7
	<var> state 1
	<var>::string state 7
	<var>::matrix state 14
  state 1: #5 #6 #7
	<var> state 2
	<var>::string state 4
  state 2: #7
	<var>::string state 3
  state 3: #7
  state 4: #5 #6 #7
	<var> state 5
	<var>::string state 6
  state 5: #6
  state 6: #5 #6 #7
  state 7: #1 #2 #3 #4 #5 #6 #7
	<var> state 8
	<var>::string state 11
  state 8: #3 #4 #7
	<var> state 9
	<var>::string state 10
  state 9: #4
  state 10: #3 #4 #7
  state 11: #1 #2 #3 #4 #5 #6 #7
	<var> state 12
	<var>::string state 13
  state 12: #2 #4 #6
  state 13: #1 #2 #3 #4 #5 #6 #7
  state 14: #0 #5 #6 #7
	<var> state 15
	<var>::string state 17
	<var>::matrix state 20
  state 15: #7
	<var>::string state 16
  state 16: #7
  state 17: #5 #6 #7
	<var> state 18
	<var>::string state 19
  state 18: #6
  state 19: #5 #6 #7
  state 20: #0 #7
	<var>::string state 21
	<var>::matrix state 22
  state 21: #7
  state 22: #0
}
{
  rule #0: dowith f x::matrix y::matrix = do (uncurry f) (zip x y)
  rule #1: dowith f s::string t::string = dowith f (chars s) (chars t)
  rule #2: dowith f s::string t = dowith f (chars s) t
  rule #3: dowith f s t::string = dowith f s (chars t)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<var>::string state 4
	<var>::matrix state 7
  state 2: #3
	<var>::string state 3
  state 3: #3
  state 4: #1 #2 #3
	<var> state 5
	<var>::string state 6
  state 5: #2
  state 6: #1 #2 #3
  state 7: #0 #3
	<var>::string state 8
	<var>::matrix state 9
  state 8: #3
  state 9: #0
}
{
  rule #0: dowith3 f x::matrix y::matrix z::matrix = do (uncurry3 f) (zip3 x y z)
  rule #1: dowith3 f s::string t::string u::string = dowith3 f (chars s) (chars t) (chars u)
  rule #2: dowith3 f s::string t::string u = dowith3 f (chars s) (chars t) u
  rule #3: dowith3 f s::string t u::string = dowith3 f (chars s) t (chars u)
  rule #4: dowith3 f s::string t u = dowith3 f (chars s) t u
  rule #5: dowith3 f s t::string u::string = dowith3 f s (chars t) (chars u)
  rule #6: dowith3 f s t::string u = dowith3 f s (chars t) u
  rule #7: dowith3 f s t u::string = dowith3 f s t (chars u)
  state 0: #0 #1 #2 #3 #4 #5 #6 #7
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5 #6 #7
	<var> state 2
	<var>::string state 8
	<var>::matrix state 15
  state 2: #5 #6 #7
	<var> state 3
	<var>::string state 5
  state 3: #7
	<var>::string state 4
  state 4: #7
  state 5: #5 #6 #7
	<var> state 6
	<var>::string state 7
  state 6: #6
  state 7: #5 #6 #7
  state 8: #1 #2 #3 #4 #5 #6 #7
	<var> state 9
	<var>::string state 12
  state 9: #3 #4 #7
	<var> state 10
	<var>::string state 11
  state 10: #4
  state 11: #3 #4 #7
  state 12: #1 #2 #3 #4 #5 #6 #7
	<var> state 13
	<var>::string state 14
  state 13: #2 #4 #6
  state 14: #1 #2 #3 #4 #5 #6 #7
  state 15: #0 #5 #6 #7
	<var> state 16
	<var>::string state 18
	<var>::matrix state 21
  state 16: #7
	<var>::string state 17
  state 17: #7
  state 18: #5 #6 #7
	<var> state 19
	<var>::string state 20
  state 19: #6
  state 20: #5 #6 #7
  state 21: #0 #7
	<var>::string state 22
	<var>::matrix state 23
  state 22: #7
  state 23: #0
}
{
  rule #0: unzip x::matrix = colmap (\(u,_) -> u) x,colmap (\(_,v) -> v) x if all check x with check (_,_) = 1; check x = throw (bad_tuple_value x) end
  state 0: #0
	<var>::matrix state 1
  state 1: #0
}
{
  rule #0: unzip3 x::matrix = colmap (\(u,_) -> u) x,colmap (\(_,v,_) -> v) x,colmap (\(_,_,w) -> w) x if all check x with check (_,_,_) = 1; check x = throw (bad_tuple_value x) end
  state 0: #0
	<var>::matrix state 1
  state 1: #0
}
{
  rule #0: double_pointer p::pointer x::matrix = __C::matrix_to_double_array p x if nmatrixp x
  state 0: #0
	<var>::pointer state 1
  state 1: #0
	<var>::matrix state 2
  state 2: #0
}
{
  rule #0: float_pointer p::pointer x::matrix = __C::matrix_to_float_array p x if nmatrixp x
  state 0: #0
	<var>::pointer state 1
  state 1: #0
	<var>::matrix state 2
  state 2: #0
}
{
  rule #0: complex_pointer p::pointer x::matrix = __C::matrix_to_complex_array p x if nmatrixp x
  state 0: #0
	<var>::pointer state 1
  state 1: #0
	<var>::matrix state 2
  state 2: #0
}
{
  rule #0: complex_float_pointer p::pointer x::matrix = __C::matrix_to_complex_float_array p x if nmatrixp x
  state 0: #0
	<var>::pointer state 1
  state 1: #0
	<var>::matrix state 2
  state 2: #0
}
{
  rule #0: int_pointer p::pointer x::matrix = __C::matrix_to_int_array p x if nmatrixp x
  state 0: #0
	<var>::pointer state 1
  state 1: #0
	<var>::matrix state 2
  state 2: #0
}
{
  rule #0: short_pointer p::pointer x::matrix = __C::matrix_to_short_array p x if nmatrixp x
  state 0: #0
	<var>::pointer state 1
  state 1: #0
	<var>::matrix state 2
  state 2: #0
}
{
  rule #0: byte_pointer p::pointer x::matrix = __C::matrix_to_byte_array p x if nmatrixp x
  state 0: #0
	<var>::pointer state 1
  state 1: #0
	<var>::matrix state 2
  state 2: #0
}
{
  rule #0: float_matrix (n::int,m::int) p::pointer = __C::matrix_from_float_array n m p
  rule #1: float_matrix n::int p::pointer = float_matrix (1,n) p
  state 0: #0 #1
	<var>::int state 1
	<app> state 3
  state 1: #1
	<var>::pointer state 2
  state 2: #1
  state 3: #0
	<app> state 4
  state 4: #0
	, state 5
  state 5: #0
	<var>::int state 6
  state 6: #0
	<var>::int state 7
  state 7: #0
	<var>::pointer state 8
  state 8: #0
}
{
  rule #0: complex_float_matrix (n::int,m::int) p::pointer = __C::matrix_from_complex_float_array n m p
  rule #1: complex_float_matrix n::int p::pointer = complex_float_matrix (1,n) p
  state 0: #0 #1
	<var>::int state 1
	<app> state 3
  state 1: #1
	<var>::pointer state 2
  state 2: #1
  state 3: #0
	<app> state 4
  state 4: #0
	, state 5
  state 5: #0
	<var>::int state 6
  state 6: #0
	<var>::int state 7
  state 7: #0
	<var>::pointer state 8
  state 8: #0
}
{
  rule #0: short_matrix (n::int,m::int) p::pointer = __C::matrix_from_short_array n m p
  rule #1: short_matrix n::int p::pointer = short_matrix (1,n) p
  state 0: #0 #1
	<var>::int state 1
	<app> state 3
  state 1: #1
	<var>::pointer state 2
  state 2: #1
  state 3: #0
	<app> state 4
  state 4: #0
	, state 5
  state 5: #0
	<var>::int state 6
  state 6: #0
	<var>::int state 7
  state 7: #0
	<var>::pointer state 8
  state 8: #0
}
{
  rule #0: byte_matrix (n::int,m::int) p::pointer = __C::matrix_from_byte_array n m p
  rule #1: byte_matrix n::int p::pointer = byte_matrix (1,n) p
  state 0: #0 #1
	<var>::int state 1
	<app> state 3
  state 1: #1
	<var>::pointer state 2
  state 2: #1
  state 3: #0
	<app> state 4
  state 4: #0
	, state 5
  state 5: #0
	<var>::int state 6
  state 6: #0
	<var>::int state 7
  state 7: #0
	<var>::pointer state 8
  state 8: #0
}
{
  rule #0: double_matrix_view (n::int,m::int) p::pointer = __C::matrix_from_double_array_nodup n m p
  rule #1: double_matrix_view n::int p::pointer = double_matrix_view (1,n) p
  state 0: #0 #1
	<var>::int state 1
	<app> state 3
  state 1: #1
	<var>::pointer state 2
  state 2: #1
  state 3: #0
	<app> state 4
  state 4: #0
	, state 5
  state 5: #0
	<var>::int state 6
  state 6: #0
	<var>::int state 7
  state 7: #0
	<var>::pointer state 8
  state 8: #0
}
{
  rule #0: complex_matrix_view (n::int,m::int) p::pointer = __C::matrix_from_complex_array_nodup n m p
  rule #1: complex_matrix_view n::int p::pointer = complex_matrix_view (1,n) p
  state 0: #0 #1
	<var>::int state 1
	<app> state 3
  state 1: #1
	<var>::pointer state 2
  state 2: #1
  state 3: #0
	<app> state 4
  state 4: #0
	, state 5
  state 5: #0
	<var>::int state 6
  state 6: #0
	<var>::int state 7
  state 7: #0
	<var>::pointer state 8
  state 8: #0
}
{
  rule #0: int_matrix_view (n::int,m::int) p::pointer = __C::matrix_from_int_array_nodup n m p
  rule #1: int_matrix_view n::int p::pointer = int_matrix_view (1,n) p
  state 0: #0 #1
	<var>::int state 1
	<app> state 3
  state 1: #1
	<var>::pointer state 2
  state 2: #1
  state 3: #0
	<app> state 4
  state 4: #0
	, state 5
  state 5: #0
	<var>::int state 6
  state 6: #0
	<var>::int state 7
  state 7: #0
	<var>::pointer state 8
  state 8: #0
}
{
  rule #0: __C::record_elem_at x y = throw out_of_bounds
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: recordp x = __C::record_check x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: record x = __C::record_pack x if recordp x
  rule #1: record x = record x if recordp x when x = matrix x end
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
}
{
  rule #0: member x::matrix y = __C::record_member x y if recordp x
  state 0: #0
	<var>::matrix state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: insert x::matrix (y=>z) = __C::record_update x y z if recordp x
  state 0: #0
	<var>::matrix state 1
  state 1: #0
	<app> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	=> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
}
{
  rule #0: update x::matrix y z = __C::record_update x y z if recordp x
  state 0: #0
	<var>::matrix state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}
{
  rule #0: delete x::matrix y = __C::record_delete x y if recordp x
  state 0: #0
	<var>::matrix state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: keys x::matrix = colmap (\(u=>v) -> u) x if recordp x
  state 0: #0
	<var>::matrix state 1
  state 1: #0
}
{
  rule #0: vals x::matrix = colmap (\(u=>v) -> v) x if recordp x
  state 0: #0
	<var>::matrix state 1
  state 1: #0
}
{
  rule #0: chr n::int = c if stringp c when c = __C::string_chr n end
  state 0: #0
	<var>::int state 1
  state 1: #0
}
{
  rule #0: cstring s::pointer = __C::pure_cstring s
  state 0: #0
	<var>::pointer state 1
  state 1: #0
}
{
  rule #0: string_dup s::pointer = __C::pure_string_dup s
  state 0: #0
	<var>::pointer state 1
  state 1: #0
}
{
  rule #0: cstring_dup s::pointer = __C::pure_cstring_dup s
  state 0: #0
	<var>::pointer state 1
  state 1: #0
}
{
  rule #0: byte_string s::string = ptrtag 1$__C::pure_byte_string s
  state 0: #0
	<var>::string state 1
  state 1: #0
}
{
  rule #0: byte_cstring s::string = ptrtag 1$__C::pure_byte_cstring s
  state 0: #0
	<var>::string state 1
  state 1: #0
}
{
  rule #0: byte_string_pointer xs = if null p then throw malloc_error else make_pointer (map byte_string xs) with make_pointer xs = ptrtag 3$sentry free_pointer p when dowith (\i x -> put_pointer (shift_pointer p i) x) (0..n-1) xs end; free_pointer p = free p when do (\i -> free (get_pointer (shift_pointer p i))) (0..n-1) end; shift_pointer p i = pointer (__C::pure_bigintval p+i*8) end when n = #xs; p = calloc (n+1) 8; xs = if smatrixp xs then list xs else xs end if (rlistp xs||smatrixp xs)&&all stringp xs
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: byte_cstring_pointer xs = if null p then throw malloc_error else make_pointer (map byte_cstring xs) with make_pointer xs = ptrtag 3$sentry free_pointer p when dowith (\i x -> put_pointer (shift_pointer p i) x) (0..n-1) xs end; free_pointer p = free p when do (\i -> free (get_pointer (shift_pointer p i))) (0..n-1) end; shift_pointer p i = pointer (__C::pure_bigintval p+i*8) end when n = #xs; p = calloc (n+1) 8; xs = if smatrixp xs then list xs else xs end if (rlistp xs||smatrixp xs)&&all stringp xs
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: string_list n p::pointer = list$takewhile stringp (listmap (\i -> p!i) (0..n-1)) with p!i = if null q then q else string_dup q when q = get_pointer (shift_pointer p i) end; shift_pointer p i = pointer (__C::pure_bigintval p+i*8) end if ~null p&&(intp n||infp n)
  state 0: #0
	<var> state 1
  state 1: #0
	<var>::pointer state 2
  state 2: #0
}
{
  rule #0: string_vector n p::pointer = vector xs if listp xs when xs = string_list n p end
  state 0: #0
	<var> state 1
  state 1: #0
	<var>::pointer state 2
  state 2: #0
}
{
  rule #0: cstring_list n p::pointer = list$takewhile stringp (listmap (\i -> p!i) (0..n-1)) with p!i = if null q then q else cstring_dup q when q = get_pointer (shift_pointer p i) end; shift_pointer p i = pointer (__C::pure_bigintval p+i*8) end if ~null p&&(intp n||infp n)
  state 0: #0
	<var> state 1
  state 1: #0
	<var>::pointer state 2
  state 2: #0
}
{
  rule #0: cstring_vector n p::pointer = vector xs if listp xs when xs = cstring_list n p end
  state 0: #0
	<var> state 1
  state 1: #0
	<var>::pointer state 2
  state 2: #0
}
{
  rule #0: chars s::string = __C::string_chars s if ~funp (:)
  rule #1: chars s::string = list (__C::string_chars s)
  state 0: #0 #1
	<var>::string state 1
  state 1: #0 #1
}
{
  rule #0: substr s::string pos::int size::int = __C::string_substr s (max 0 pos) (max 0 size) with max x y = if x>=y then x else y end
  state 0: #0
	<var>::string state 1
  state 1: #0
	<var>::int state 2
  state 2: #0
	<var>::int state 3
  state 3: #0
}
{
  rule #0: index s::string u::string = __C::string_index s u
  state 0: #0
	<var>::string state 1
  state 1: #0
	<var>::string state 2
  state 2: #0
}
{
  rule #0: strcat xs = s if stringp s when s = __C::string_concat_list xs end
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: join delim::string xs = s if stringp s when s = __C::string_join delim xs end
  state 0: #0
	<var>::string state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: split delim::string s::string = __C::string_split delim s if ~funp (:)
  rule #1: split delim::string s::string = list (__C::string_split delim s)
  rule #2: split n::int s::string = substr s 0 n,substr s n 2147483647
  state 0: #0 #1 #2
	<var>::int state 1
	<var>::string state 3
  state 1: #2
	<var>::string state 2
  state 2: #2
  state 3: #0 #1
	<var>::string state 4
  state 4: #0 #1
}
{
  rule #0: stream s::string = stream (chars s)
  state 0: #0
	<var>::string state 1
  state 1: #0
}
{
  rule #0: reverse_onto b::string s::string = strcat (reverse_onto [b] (chars s))
  rule #1: reverse_onto b::string s = reverse_onto (chars b) s
  rule #2: reverse_onto b s::string = strcat (reverse_onto [b] (chars s)) if stringp b when b = __C::string_concat_list b end
  rule #3: reverse_onto b s::string = reverse_onto b (chars s)
  state 0: #0 #1 #2 #3
	<var> state 1
	<var>::string state 3
  state 1: #2 #3
	<var>::string state 2
  state 2: #2 #3
  state 3: #0 #1 #2 #3
	<var> state 4
	<var>::string state 5
  state 4: #1
  state 5: #0 #1 #2 #3
}
{
  rule #0: catmap_onto f b::string s::string = catmap_onto f (chars b) (chars s)
  rule #1: catmap_onto f b s::string = catmap_onto f b (chars s)
  rule #2: catmap_onto f b::string s = catmap_onto f (chars b) s
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	<var>::string state 4
  state 2: #1
	<var>::string state 3
  state 3: #1
  state 4: #0 #1 #2
	<var> state 5
	<var>::string state 6
  state 5: #2
  state 6: #0 #1 #2
}
{
  rule #0: firstby p none s::string = firstby p none (chars s)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var>::string state 3
  state 3: #0
}
{
  rule #0: foldl2 f a s::string t::string = foldl2 f a (chars s) (chars t)
  rule #1: foldl2 f a s t::string = foldl2 f a s (chars t)
  rule #2: foldl2 f a s::string t = foldl2 f a (chars s) t
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
  state 2: #0 #1 #2
	<var> state 3
	<var>::string state 5
  state 3: #1
	<var>::string state 4
  state 4: #1
  state 5: #0 #1 #2
	<var> state 6
	<var>::string state 7
  state 6: #2
  state 7: #0 #1 #2
}
{
  rule #0: foldl3 f a s::string t::string u::string = foldl3 f a (chars s) (chars t) (chars u)
  rule #1: foldl3 f a s::string t::string u = foldl3 f a (chars s) (chars t) u
  rule #2: foldl3 f a s::string t u::string = foldl3 f a (chars s) t (chars u)
  rule #3: foldl3 f a s::string t u = foldl3 f a (chars s) t u
  rule #4: foldl3 f a s t::string u::string = foldl3 f a s (chars t) (chars u)
  rule #5: foldl3 f a s t::string u = foldl3 f a s (chars t) u
  rule #6: foldl3 f a s t u::string = foldl3 f a s t (chars u)
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5 #6
	<var> state 2
  state 2: #0 #1 #2 #3 #4 #5 #6
	<var> state 3
	<var>::string state 9
  state 3: #4 #5 #6
	<var> state 4
	<var>::string state 6
  state 4: #6
	<var>::string state 5
  state 5: #6
  state 6: #4 #5 #6
	<var> state 7
	<var>::string state 8
  state 7: #5
  state 8: #4 #5 #6
  state 9: #0 #1 #2 #3 #4 #5 #6
	<var> state 10
	<var>::string state 13
  state 10: #2 #3 #6
	<var> state 11
	<var>::string state 12
  state 11: #3
  state 12: #2 #3 #6
  state 13: #0 #1 #2 #3 #4 #5 #6
	<var> state 14
	<var>::string state 15
  state 14: #1 #3 #5
  state 15: #0 #1 #2 #3 #4 #5 #6
}
{
  rule #0: foldr2 f a s::string t::string = foldr2 f a (chars s) (chars t)
  rule #1: foldr2 f a s t::string = foldr2 f a s (chars t)
  rule #2: foldr2 f a s::string t = foldr2 f a (chars s) t
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
  state 2: #0 #1 #2
	<var> state 3
	<var>::string state 5
  state 3: #1
	<var>::string state 4
  state 4: #1
  state 5: #0 #1 #2
	<var> state 6
	<var>::string state 7
  state 6: #2
  state 7: #0 #1 #2
}
{
  rule #0: foldr3 f a s::string t::string u::string = foldr3 f a (chars s) (chars t) (chars u)
  rule #1: foldr3 f a s::string t::string u = foldr3 f a (chars s) (chars t) u
  rule #2: foldr3 f a s::string t u::string = foldr3 f a (chars s) t (chars u)
  rule #3: foldr3 f a s::string t u = foldr3 f a (chars s) t u
  rule #4: foldr3 f a s t::string u::string = foldr3 f a s (chars t) (chars u)
  rule #5: foldr3 f a s t::string u = foldr3 f a s (chars t) u
  rule #6: foldr3 f a s t u::string = foldr3 f a s t (chars u)
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5 #6
	<var> state 2
  state 2: #0 #1 #2 #3 #4 #5 #6
	<var> state 3
	<var>::string state 9
  state 3: #4 #5 #6
	<var> state 4
	<var>::string state 6
  state 4: #6
	<var>::string state 5
  state 5: #6
  state 6: #4 #5 #6
	<var> state 7
	<var>::string state 8
  state 7: #5
  state 8: #4 #5 #6
  state 9: #0 #1 #2 #3 #4 #5 #6
	<var> state 10
	<var>::string state 13
  state 10: #2 #3 #6
	<var> state 11
	<var>::string state 12
  state 11: #3
  state 12: #2 #3 #6
  state 13: #0 #1 #2 #3 #4 #5 #6
	<var> state 14
	<var>::string state 15
  state 14: #1 #3 #5
  state 15: #0 #1 #2 #3 #4 #5 #6
}
{
  rule #0: lastby p none s::string = lastby p none (chars s)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var>::string state 3
  state 3: #0
}
{
  rule #0: map_onto f b::string s::string = map_onto f (chars b) (chars s)
  rule #1: map_onto f b s::string = map_onto f b (chars s)
  rule #2: map_onto f b::string s = map_onto f (chars b) s
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	<var>::string state 4
  state 2: #1
	<var>::string state 3
  state 3: #1
  state 4: #0 #1 #2
	<var> state 5
	<var>::string state 6
  state 5: #2
  state 6: #0 #1 #2
}
{
  rule #0: partition p s::string = strcat yes,strcat no when yes,no = partition p (chars s) end
  state 0: #0
	<var> state 1
  state 1: #0
	<var>::string state 2
  state 2: #0
}
{
  rule #0: pickfirstby p s::string = case pickfirstby p (chars s) of () = (); c,cs = c,strcat cs end
  state 0: #0
	<var> state 1
  state 1: #0
	<var>::string state 2
  state 2: #0
}
{
  rule #0: picklastby p s::string = case picklastby p (chars s) of () = (); c,cs = c,strcat cs end
  state 0: #0
	<var> state 1
  state 1: #0
	<var>::string state 2
  state 2: #0
}
{
  rule #0: revmap f s::string = revmap f (chars s)
  state 0: #0
	<var> state 1
  state 1: #0
	<var>::string state 2
  state 2: #0
}
{
  rule #0: revmap_onto f b::string s::string = revmap_onto f (chars b) (chars s)
  rule #1: revmap_onto f b s::string = revmap_onto f b (chars s)
  rule #2: revmap_onto f b::string s = revmap_onto f (chars b) s
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	<var>::string state 4
  state 2: #1
	<var>::string state 3
  state 3: #1
  state 4: #0 #1 #2
	<var> state 5
	<var>::string state 6
  state 5: #2
  state 6: #0 #1 #2
}
{
  rule #0: rmfirstby p s::string = strcat (rmfirstby p (chars s))
  state 0: #0
	<var> state 1
  state 1: #0
	<var>::string state 2
  state 2: #0
}
{
  rule #0: rmlastby p s::string = strcat (rmfirstby p (chars s))
  state 0: #0
	<var> state 1
  state 1: #0
	<var>::string state 2
  state 2: #0
}
{
  rule #0: rotate n::int s::string = strcat (rotate n (chars s))
  state 0: #0
	<var>::int state 1
  state 1: #0
	<var>::string state 2
  state 2: #0
}
{
  rule #0: span p s::string = strcat pre,strcat post when pre,post = span p (chars s) end
  state 0: #0
	<var> state 1
  state 1: #0
	<var>::string state 2
  state 2: #0
}
{
  rule #0: zip_onto b::string s::string t::string = zip_onto (chars b) (chars s) (chars t)
  rule #1: zip_onto b::string s::string t = zip_onto (chars b) (chars s) t
  rule #2: zip_onto b::string s t::string = zip_onto (chars b) s (chars t)
  rule #3: zip_onto b::string s t = zip_onto (chars b) s t
  rule #4: zip_onto b s::string t::string = zip_onto b (chars s) (chars t)
  rule #5: zip_onto b s::string t = zip_onto b (chars s) t
  rule #6: zip_onto b s t::string = zip_onto b s (chars t)
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var> state 1
	<var>::string state 7
  state 1: #4 #5 #6
	<var> state 2
	<var>::string state 4
  state 2: #6
	<var>::string state 3
  state 3: #6
  state 4: #4 #5 #6
	<var> state 5
	<var>::string state 6
  state 5: #5
  state 6: #4 #5 #6
  state 7: #0 #1 #2 #3 #4 #5 #6
	<var> state 8
	<var>::string state 11
  state 8: #2 #3 #6
	<var> state 9
	<var>::string state 10
  state 9: #3
  state 10: #2 #3 #6
  state 11: #0 #1 #2 #3 #4 #5 #6
	<var> state 12
	<var>::string state 13
  state 12: #1 #3 #5
  state 13: #0 #1 #2 #3 #4 #5 #6
}
{
  rule #0: zip3_onto b::string s::string t::string u::string = zip3_onto (chars b) (chars s) (chars t) (chars u)
  rule #1: zip3_onto b::string s::string t::string u = zip3_onto (chars b) (chars s) (chars t) u
  rule #2: zip3_onto b::string s::string t u::string = zip3_onto (chars b) (chars s) t (chars u)
  rule #3: zip3_onto b::string s::string t u = zip3_onto (chars b) (chars s) t u
  rule #4: zip3_onto b::string s t::string u::string = zip3_onto (chars b) s (chars t) (chars u)
  rule #5: zip3_onto b::string s t::string u = zip3_onto (chars b) s (chars t) u
  rule #6: zip3_onto b::string s t u::string = zip3_onto (chars b) s t (chars u)
  rule #7: zip3_onto b::string s t u = zip3_onto (chars b) s t u
  rule #8: zip3_onto b s::string t::string u::string = zip3_onto b (chars s) (chars t) (chars u)
  rule #9: zip3_onto b s::string t::string u = zip3_onto b (chars s) (chars t) u
  rule #10: zip3_onto b s::string t u::string = zip3_onto b (chars s) t (chars u)
  rule #11: zip3_onto b s::string t u = zip3_onto b (chars s) t u
  rule #12: zip3_onto b s t::string u::string = zip3_onto b s (chars t) (chars u)
  rule #13: zip3_onto b s t::string u = zip3_onto b s (chars t) u
  rule #14: zip3_onto b s t u::string = zip3_onto b s t (chars u)
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14
	<var> state 1
	<var>::string state 15
  state 1: #8 #9 #10 #11 #12 #13 #14
	<var> state 2
	<var>::string state 8
  state 2: #12 #13 #14
	<var> state 3
	<var>::string state 5
  state 3: #14
	<var>::string state 4
  state 4: #14
  state 5: #12 #13 #14
	<var> state 6
	<var>::string state 7
  state 6: #13
  state 7: #12 #13 #14
  state 8: #8 #9 #10 #11 #12 #13 #14
	<var> state 9
	<var>::string state 12
  state 9: #10 #11 #14
	<var> state 10
	<var>::string state 11
  state 10: #11
  state 11: #10 #11 #14
  state 12: #8 #9 #10 #11 #12 #13 #14
	<var> state 13
	<var>::string state 14
  state 13: #9 #11 #13
  state 14: #8 #9 #10 #11 #12 #13 #14
  state 15: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14
	<var> state 16
	<var>::string state 23
  state 16: #4 #5 #6 #7 #12 #13 #14
	<var> state 17
	<var>::string state 20
  state 17: #6 #7 #14
	<var> state 18
	<var>::string state 19
  state 18: #7
  state 19: #6 #7 #14
  state 20: #4 #5 #6 #7 #12 #13 #14
	<var> state 21
	<var>::string state 22
  state 21: #5 #7 #13
  state 22: #4 #5 #6 #7 #12 #13 #14
  state 23: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14
	<var> state 24
	<var>::string state 27
  state 24: #2 #3 #6 #7 #10 #11 #14
	<var> state 25
	<var>::string state 26
  state 25: #3 #7 #11
  state 26: #2 #3 #6 #7 #10 #11 #14
  state 27: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14
	<var> state 28
	<var>::string state 29
  state 28: #1 #3 #5 #7 #9 #11 #13
  state 29: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14
}
{
  rule #0: zipwith_onto f b::string s::string t::string = zipwith_onto f (chars b) (chars s) (chars t)
  rule #1: zipwith_onto f b::string s::string t = zipwith_onto f (chars b) (chars s) t
  rule #2: zipwith_onto f b::string s t::string = zipwith_onto f (chars b) s (chars t)
  rule #3: zipwith_onto f b::string s t = zipwith_onto f (chars b) s t
  rule #4: zipwith_onto f b s::string t::string = zipwith_onto f b (chars s) (chars t)
  rule #5: zipwith_onto f b s::string t = zipwith_onto f b (chars s) t
  rule #6: zipwith_onto f b s t::string = zipwith_onto f b s (chars t)
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5 #6
	<var> state 2
	<var>::string state 8
  state 2: #4 #5 #6
	<var> state 3
	<var>::string state 5
  state 3: #6
	<var>::string state 4
  state 4: #6
  state 5: #4 #5 #6
	<var> state 6
	<var>::string state 7
  state 6: #5
  state 7: #4 #5 #6
  state 8: #0 #1 #2 #3 #4 #5 #6
	<var> state 9
	<var>::string state 12
  state 9: #2 #3 #6
	<var> state 10
	<var>::string state 11
  state 10: #3
  state 11: #2 #3 #6
  state 12: #0 #1 #2 #3 #4 #5 #6
	<var> state 13
	<var>::string state 14
  state 13: #1 #3 #5
  state 14: #0 #1 #2 #3 #4 #5 #6
}
{
  rule #0: zipwith3_onto f b::string s::string t::string u::string = zipwith3_onto f (chars b) (chars s) (chars t) (chars u)
  rule #1: zipwith3_onto f b::string s::string t::string u = zipwith3_onto f (chars b) (chars s) (chars t) u
  rule #2: zipwith3_onto f b::string s::string t u::string = zipwith3_onto f (chars b) (chars s) t (chars u)
  rule #3: zipwith3_onto f b::string s::string t u = zipwith3_onto f (chars b) (chars s) t u
  rule #4: zipwith3_onto f b::string s t::string u::string = zipwith3_onto f (chars b) s (chars t) (chars u)
  rule #5: zipwith3_onto f b::string s t::string u = zipwith3_onto f (chars b) s (chars t) u
  rule #6: zipwith3_onto f b::string s t u::string = zipwith3_onto f (chars b) s t (chars u)
  rule #7: zipwith3_onto f b::string s t u = zipwith3_onto f (chars b) s t u
  rule #8: zipwith3_onto f b s::string t::string u::string = zipwith3_onto f b (chars s) (chars t) (chars u)
  rule #9: zipwith3_onto f b s::string t::string u = zipwith3_onto f b (chars s) (chars t) u
  rule #10: zipwith3_onto f b s::string t u::string = zipwith3_onto f b (chars s) t (chars u)
  rule #11: zipwith3_onto f b s::string t u = zipwith3_onto f b (chars s) t u
  rule #12: zipwith3_onto f b s t::string u::string = zipwith3_onto f b s (chars t) (chars u)
  rule #13: zipwith3_onto f b s t::string u = zipwith3_onto f b s (chars t) u
  rule #14: zipwith3_onto f b s t u::string = zipwith3_onto f b s t (chars u)
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14
	<var> state 2
	<var>::string state 16
  state 2: #8 #9 #10 #11 #12 #13 #14
	<var> state 3
	<var>::string state 9
  state 3: #12 #13 #14
	<var> state 4
	<var>::string state 6
  state 4: #14
	<var>::string state 5
  state 5: #14
  state 6: #12 #13 #14
	<var> state 7
	<var>::string state 8
  state 7: #13
  state 8: #12 #13 #14
  state 9: #8 #9 #10 #11 #12 #13 #14
	<var> state 10
	<var>::string state 13
  state 10: #10 #11 #14
	<var> state 11
	<var>::string state 12
  state 11: #11
  state 12: #10 #11 #14
  state 13: #8 #9 #10 #11 #12 #13 #14
	<var> state 14
	<var>::string state 15
  state 14: #9 #11 #13
  state 15: #8 #9 #10 #11 #12 #13 #14
  state 16: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14
	<var> state 17
	<var>::string state 24
  state 17: #4 #5 #6 #7 #12 #13 #14
	<var> state 18
	<var>::string state 21
  state 18: #6 #7 #14
	<var> state 19
	<var>::string state 20
  state 19: #7
  state 20: #6 #7 #14
  state 21: #4 #5 #6 #7 #12 #13 #14
	<var> state 22
	<var>::string state 23
  state 22: #5 #7 #13
  state 23: #4 #5 #6 #7 #12 #13 #14
  state 24: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14
	<var> state 25
	<var>::string state 28
  state 25: #2 #3 #6 #7 #10 #11 #14
	<var> state 26
	<var>::string state 27
  state 26: #3 #7 #11
  state 27: #2 #3 #6 #7 #10 #11 #14
  state 28: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14
	<var> state 29
	<var>::string state 30
  state 29: #1 #3 #5 #7 #9 #11 #13
  state 30: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14
}
{
  rule #0: void _ = ()
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: id x = x
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: curry f x y = f (x,y)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}
{
  rule #0: curry3 f x y z = f (x,y,z)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
	<var> state 4
  state 4: #0
}
{
  rule #0: fix f = f (fix f&)
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: key (x=>v) = x
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	=> state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}
{
  rule #0: tuple2 x y = 'comma x y when comma = (,) end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: tuple3 x y z = 'comma x (comma y z) when comma = (,) end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}
{
  rule #0: mapfst f (a,b) = tuple2 (f a) b
  state 0: #0
	<var> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
}
{
  rule #0: mapsnd f (a,b) = tuple2 a (f b)
  state 0: #0
	<var> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
}
{
  rule #0: maptrd f (a,b,c) = tuple3 a b (f c)
  state 0: #0
	<var> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	<app> state 7
  state 7: #0
	, state 8
  state 8: #0
	<var> state 9
  state 9: #0
	<var> state 10
  state 10: #0
}
{
  rule #0: fst _ (a,_) = a
  rule #1: fst none () = none
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<app> state 2
	() state 7
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
}
{
  rule #0: snd _ (_,a) = a
  rule #1: snd none () = none
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<app> state 2
	() state 7
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
}
{
  rule #0: trd _ (_,_,a) = a
  rule #1: trd none () = none
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<app> state 2
	() state 11
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	<app> state 7
  state 7: #0
	, state 8
  state 8: #0
	<var> state 9
  state 9: #0
	<var> state 10
  state 10: #0
  state 11: #1
}
const __std__::SKIPSIZE = 4096;
__std__::reverse_onto base/*0:01*/ [] = base/*0:01*/;
__std__::reverse_onto base/*0:01*/ (x/*0:101*/:xs/*0:11*/) = __std__::reverse_onto (x/*0:101*/:base/*0:01*/) xs/*0:11*/;
reverse_onto base/*0:01*/ [] = base/*0:01*/;
reverse_onto base/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*0*/ (x/*0:101*/:base/*0:01*/) xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (x/*0:101*/:ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ [] = ys/*0:01*/; accum ys/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: accum ys (x:xs) = accum (x:ys) xs
  rule #1: accum ys [] = ys
  rule #2: accum ys xs = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
reverse [] = [];
reverse xs@(_/*0:101*/:_/*0:11*/) = reverse_onto [] xs/*0:1*/;
[]+ys/*0:1*/ = ys/*0:1*/;
xs@(_/*0:0101*/:_/*0:011*/)+ys/*0:1*/ = aux/*0*/ xs/*0:01*/ with aux xs/*0:1*/ = fold_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with fold_pre 0 _/*0:1*/ = folded_tail/*1:1*/; fold_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:fold_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/ {
  rule #0: fold_pre 0 _ = folded_tail
  rule #1: fold_pre n::int (x:xs) = x:fold_pre (n-1) xs
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ folded_tail/*0:1*/ = skip_ahead/*1*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ folded_tail = skip_ahead 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux xs = fold_pre len_pre xs with fold_pre 0 _ = folded_tail; fold_pre n::int (x:xs) = x:fold_pre (n-1) xs end when len_pre@_ folded_tail = skip_ahead 0 xs end
  state 0: #0
	<var> state 1
  state 1: #0
}; skip_ahead n/*0:01*/ :: int [] = n/*0:01*/ ys/*1:1*/; skip_ahead n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = n/*0:01*/ (aux/*1*/ xs/*0:1*/) if n/*0:01*/==4096; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ (x/*0:101*/:aux/*2*/ xs/*1:11*/&) if thunkp xs/*0:11*/; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = skip_ahead/*1*/ (n/*0:01*/+1) xs/*0:11*/; skip_ahead n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (xs/*0:1*/+ys/*1:1*/) {
  rule #0: skip_ahead n::int [] = n ys
  rule #1: skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096
  rule #2: skip_ahead n::int (x:xs) = n (x:aux xs&) if thunkp xs
  rule #3: skip_ahead n::int (x:xs) = skip_ahead (n+1) xs
  rule #4: skip_ahead n::int xs = n (xs+ys)
  state 0: #0 #1 #2 #3 #4
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #4
  state 3: #1 #2 #3 #4
	<var> state 4
	<app> state 6
  state 4: #4
	<var> state 5
  state 5: #4
  state 6: #1 #2 #3 #4
	<var> state 7
	: state 10
  state 7: #4
	<var> state 8
  state 8: #4
	<var> state 9
  state 9: #4
  state 10: #1 #2 #3 #4
	<var> state 11
  state 11: #1 #2 #3 #4
	<var> state 12
  state 12: #1 #2 #3 #4
  state 13: #0 #4
} end;
all p/*0:01*/ [] = 1;
all p/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ xs/*0:1*/ 1 with tick _/*0:01*/ 0 = 0; tick [] a/*0:1*/ = a/*0:1*/; tick (x/*0:0101*/:xs/*0:011*/) a/*0:1*/ = tick/*1*/ xs/*0:011*/ (a/*0:1*/&&p/*1:01*/ x/*0:0101*/); tick xs/*0:01*/ a/*0:1*/ = a/*0:1*/&&all p/*1:01*/ xs/*0:01*/ {
  rule #0: tick _ 0 = 0
  rule #1: tick [] a = a
  rule #2: tick (x:xs) a = tick xs (a&&p x)
  rule #3: tick xs a = a&&all p xs
  state 0: #0 #1 #2 #3
	<var> state 1
	<app> state 4
	[] state 20
  state 1: #0 #3
	<var> state 2
	0::int state 3
  state 2: #3
  state 3: #0 #3
  state 4: #0 #2 #3
	<var> state 5
	<app> state 9
  state 5: #0 #3
	<var> state 6
  state 6: #0 #3
	<var> state 7
	0::int state 8
  state 7: #3
  state 8: #0 #3
  state 9: #0 #2 #3
	<var> state 10
	: state 15
  state 10: #0 #3
	<var> state 11
  state 11: #0 #3
	<var> state 12
  state 12: #0 #3
	<var> state 13
	0::int state 14
  state 13: #3
  state 14: #0 #3
  state 15: #0 #2 #3
	<var> state 16
  state 16: #0 #2 #3
	<var> state 17
  state 17: #0 #2 #3
	<var> state 18
	0::int state 19
  state 18: #2 #3
  state 19: #0 #2 #3
  state 20: #0 #1 #3
	<var> state 21
	0::int state 22
  state 21: #1 #3
  state 22: #0 #1 #3
} end;
any p/*0:01*/ [] = 0;
any p/*0:01*/ (x/*0:101*/:xs/*0:11*/) = p/*0:01*/ x/*0:101*/||any p/*0:01*/ xs/*0:11*/;
delete [] y/*0:1*/ = [];
delete xs@(_/*0:0101*/:_/*0:011*/) y/*0:1*/ = tick/*0*/ xs/*0:01*/ [] with tick [] _/*0:1*/ = xs/*1:01*/; tick (x/*0:0101*/:xs/*0:011*/) ws/*0:1*/ = if y/*1:1*/==?x/*0:0101*/ then __std__::reverse_onto xs/*0:011*/ ws/*0:1*/ else tick/*1*/ xs/*0:011*/ (x/*0:0101*/:ws/*0:1*/); tick xs/*0:01*/ ws/*0:1*/ = __std__::reverse_onto (delete xs/*0:01*/ y/*1:1*/) ws/*0:1*/ {
  rule #0: tick [] _ = xs
  rule #1: tick (x:xs) ws = if y==?x then __std__::reverse_onto xs ws else tick xs (x:ws)
  rule #2: tick xs ws = __std__::reverse_onto (delete xs y) ws
  state 0: #0 #1 #2
	<var> state 1
	<app> state 3
	[] state 16
  state 1: #2
	<var> state 2
  state 2: #2
  state 3: #1 #2
	<var> state 4
	<app> state 7
  state 4: #2
	<var> state 5
  state 5: #2
	<var> state 6
  state 6: #2
  state 7: #1 #2
	<var> state 8
	: state 12
  state 8: #2
	<var> state 9
  state 9: #2
	<var> state 10
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #1 #2
	<var> state 13
  state 13: #1 #2
	<var> state 14
  state 14: #1 #2
	<var> state 15
  state 15: #1 #2
  state 16: #0 #2
	<var> state 17
  state 17: #0 #2
} end;
do f/*0:01*/ [] = ();
do f/*0:01*/ (x/*0:101*/:xs/*0:11*/) = f/*0:01*/ x/*0:101*/$$do f/*0:01*/ xs/*0:11*/;
drop n/*0:01*/ :: int [] = [];
drop n/*0:01*/ :: int ys@(x/*0:101*/:xs/*0:11*/) = drop (n/*0:01*/-1) xs/*0:11*/ if n/*0:01*/>1;
drop n/*0:01*/ :: int ys@(x/*0:101*/:xs/*0:11*/) = xs/*0:11*/ if n/*0:01*/==1;
drop n/*0:01*/ :: int ys@(x/*0:101*/:xs/*0:11*/) = ys/*0:1*/;
dropwhile p/*0:01*/ [] = [];
dropwhile p/*0:01*/ ys@(x/*0:101*/:xs/*0:11*/) = dropwhile p/*0:01*/ xs/*0:11*/ if p/*0:01*/ x/*0:101*/;
dropwhile p/*0:01*/ ys@(x/*0:101*/:xs/*0:11*/) = ys/*0:1*/;
filter p/*0:01*/ [] = [];
filter p/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = aux/*0*/ xs/*0:1*/ with aux xs/*0:1*/ = filter_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with filter_pre 0 _/*0:1*/ = filtered_tail/*1:1*/; filter_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = add/*3*/ p/*3:01*/ x/*0:101*/ (filter_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/) {
  rule #0: filter_pre 0 _ = filtered_tail
  rule #1: filter_pre n::int (x:xs) = add p x (filter_pre (n-1) xs)
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ filtered_tail/*0:1*/ = skip_ahead/*1*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ filtered_tail = skip_ahead 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux xs = filter_pre len_pre xs with filter_pre 0 _ = filtered_tail; filter_pre n::int (x:xs) = add p x (filter_pre (n-1) xs) end when len_pre@_ filtered_tail = skip_ahead 0 xs end
  state 0: #0
	<var> state 1
  state 1: #0
}; skip_ahead n/*0:01*/ :: int [] = n/*0:01*/ []; skip_ahead n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = n/*0:01*/ (aux/*1*/ xs/*0:1*/) if n/*0:01*/==4096; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ (add/*1*/ p/*1:01*/ x/*0:101*/ (aux/*2*/ xs/*1:11*/&)) if thunkp xs/*0:11*/; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = skip_ahead/*1*/ (n/*0:01*/+1) xs/*0:11*/; skip_ahead n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (filter p/*1:01*/ xs/*0:1*/) {
  rule #0: skip_ahead n::int [] = n []
  rule #1: skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096
  rule #2: skip_ahead n::int (x:xs) = n (add p x (aux xs&)) if thunkp xs
  rule #3: skip_ahead n::int (x:xs) = skip_ahead (n+1) xs
  rule #4: skip_ahead n::int xs = n (filter p xs)
  state 0: #0 #1 #2 #3 #4
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #4
  state 3: #1 #2 #3 #4
	<var> state 4
	<app> state 6
  state 4: #4
	<var> state 5
  state 5: #4
  state 6: #1 #2 #3 #4
	<var> state 7
	: state 10
  state 7: #4
	<var> state 8
  state 8: #4
	<var> state 9
  state 9: #4
  state 10: #1 #2 #3 #4
	<var> state 11
  state 11: #1 #2 #3 #4
	<var> state 12
  state 12: #1 #2 #3 #4
  state 13: #0 #4
}; add p/*0:001*/ x/*0:01*/ hs/*0:1*/ = if p/*0:001*/ x/*0:01*/ then x/*0:01*/:hs/*0:1*/ else hs/*0:1*/ {
  rule #0: add p x hs = if p x then x:hs else hs
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end;
firstby p/*0:001*/ none/*0:01*/ [] = none/*0:01*/;
firstby p/*0:001*/ none/*0:01*/ (x/*0:101*/:xs/*0:11*/) = if p/*0:001*/ x/*0:101*/ then x/*0:101*/ else firstby p/*0:001*/ none/*0:01*/ xs/*0:11*/;
pickfirstby p/*0:01*/ [] = ();
pickfirstby p/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ xs/*0:1*/ [] with tick [] _/*0:1*/ = (); tick (x/*0:0101*/:xs/*0:011*/) ws/*0:1*/ = if p/*1:01*/ x/*0:0101*/ then tuple2 x/*0:0101*/ (__std__::reverse_onto xs/*0:011*/ ws/*0:1*/) else tick/*1*/ xs/*0:011*/ (x/*0:0101*/:ws/*0:1*/); tick xs/*0:01*/ ws/*0:1*/ = throw (bad_list_value xs/*0:01*/) {
  rule #0: tick [] _ = ()
  rule #1: tick (x:xs) ws = if p x then tuple2 x (__std__::reverse_onto xs ws) else tick xs (x:ws)
  rule #2: tick xs ws = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 3
	[] state 16
  state 1: #2
	<var> state 2
  state 2: #2
  state 3: #1 #2
	<var> state 4
	<app> state 7
  state 4: #2
	<var> state 5
  state 5: #2
	<var> state 6
  state 6: #2
  state 7: #1 #2
	<var> state 8
	: state 12
  state 8: #2
	<var> state 9
  state 9: #2
	<var> state 10
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #1 #2
	<var> state 13
  state 13: #1 #2
	<var> state 14
  state 14: #1 #2
	<var> state 15
  state 15: #1 #2
  state 16: #0 #2
	<var> state 17
  state 17: #0 #2
} end;
rmfirstby p/*0:01*/ [] = [];
rmfirstby p/*0:01*/ ys@(_/*0:101*/:_/*0:11*/) = tick/*0*/ ys/*0:1*/ [] with tick [] _/*0:1*/ = ys/*1:1*/; tick (x/*0:0101*/:xs/*0:011*/) ws/*0:1*/ = if p/*1:01*/ x/*0:0101*/ then __std__::reverse_onto xs/*0:011*/ ws/*0:1*/ else tick/*1*/ xs/*0:011*/ (x/*0:0101*/:ws/*0:1*/); tick xs/*0:01*/ ws/*0:1*/ = __std__::reverse_onto (rmfirstby p/*1:01*/ xs/*0:01*/) ws/*0:1*/ {
  rule #0: tick [] _ = ys
  rule #1: tick (x:xs) ws = if p x then __std__::reverse_onto xs ws else tick xs (x:ws)
  rule #2: tick xs ws = __std__::reverse_onto (rmfirstby p xs) ws
  state 0: #0 #1 #2
	<var> state 1
	<app> state 3
	[] state 16
  state 1: #2
	<var> state 2
  state 2: #2
  state 3: #1 #2
	<var> state 4
	<app> state 7
  state 4: #2
	<var> state 5
  state 5: #2
	<var> state 6
  state 6: #2
  state 7: #1 #2
	<var> state 8
	: state 12
  state 8: #2
	<var> state 9
  state 9: #2
	<var> state 10
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #1 #2
	<var> state 13
  state 13: #1 #2
	<var> state 14
  state 14: #1 #2
	<var> state 15
  state 15: #1 #2
  state 16: #0 #2
	<var> state 17
  state 17: #0 #2
} end;
lastby p/*0:001*/ none/*0:01*/ [] = none/*0:01*/;
lastby p/*0:001*/ none/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ xs/*0:1*/ __std__::notfound with tick [] w/*0:1*/ = if w/*0:1*/===__std__::notfound then none/*1:01*/ else w/*0:1*/; tick (x/*0:0101*/:xs/*0:011*/) w/*0:1*/ = tick/*1*/ xs/*0:011*/ (if p/*1:001*/ x/*0:0101*/ then x/*0:0101*/ else w/*0:1*/); tick xs/*0:01*/ w/*0:1*/ = throw (bad_list_value xs/*0:01*/) {
  rule #0: tick [] w = if w===__std__::notfound then none else w
  rule #1: tick (x:xs) w = tick xs (if p x then x else w)
  rule #2: tick xs w = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 3
	[] state 16
  state 1: #2
	<var> state 2
  state 2: #2
  state 3: #1 #2
	<var> state 4
	<app> state 7
  state 4: #2
	<var> state 5
  state 5: #2
	<var> state 6
  state 6: #2
  state 7: #1 #2
	<var> state 8
	: state 12
  state 8: #2
	<var> state 9
  state 9: #2
	<var> state 10
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #1 #2
	<var> state 13
  state 13: #1 #2
	<var> state 14
  state 14: #1 #2
	<var> state 15
  state 15: #1 #2
  state 16: #0 #2
	<var> state 17
  state 17: #0 #2
} end;
picklastby p/*0:01*/ [] = ();
picklastby p/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = aux/*0*/ xs/*0:1*/ with aux xs/*0:1*/ = case skip_ahead/*1*/ 0 xs/*0:1*/ of len_pre@_/*0:0*/ () = pop_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with pop_pre 0 _/*0:1*/ = (); pop_pre n/*0:01*/ :: int xx@(x/*0:101*/:xs/*0:11*/) = case pop_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/ of () = if p/*4:01*/ x/*1:101*/ then xx/*1:1*/ else (); y/*0:01*/,ys/*0:1*/ = tuple2 y/*0:01*/ (x/*1:101*/:ys/*0:1*/) {
  rule #0: () = if p x then xx else ()
  rule #1: y,ys = tuple2 y (x:ys)
  state 0: #0 #1
	<app> state 1
	() state 6
  state 1: #1
	<app> state 2
  state 2: #1
	, state 3
  state 3: #1
	<var> state 4
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0
} end {
  rule #0: pop_pre 0 _ = ()
  rule #1: pop_pre n::int xx@(x:xs) = case pop_pre (n-1) xs of () = if p x then xx else (); y,ys = tuple2 y (x:ys) end
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end; len_pre@_/*0:0*/ (y/*0:101*/:ys/*0:11*/) = tuple2 y/*0:101*/ (append/*2*/ len_pre/*0:0*/ xs/*1:1*/ ys/*0:11*/) {
  rule #0: len_pre@_ () = pop_pre len_pre xs with pop_pre 0 _ = (); pop_pre n::int xx@(x:xs) = case pop_pre (n-1) xs of () = if p x then xx else (); y,ys = tuple2 y (x:ys) end end
  rule #1: len_pre@_ (y:ys) = tuple2 y (append len_pre xs ys)
  state 0: #0 #1
	<app> state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
	<app> state 3
	() state 8
  state 3: #1
	<app> state 4
  state 4: #1
	: state 5
  state 5: #1
	<var> state 6
  state 6: #1
	<var> state 7
  state 7: #1
  state 8: #0
} end {
  rule #0: aux xs = case skip_ahead 0 xs of len_pre@_ () = pop_pre len_pre xs with pop_pre 0 _ = (); pop_pre n::int xx@(x:xs) = case pop_pre (n-1) xs of () = if p x then xx else (); y,ys = tuple2 y (x:ys) end end; len_pre@_ (y:ys) = tuple2 y (append len_pre xs ys) end
  state 0: #0
	<var> state 1
  state 1: #0
}; skip_ahead n/*0:01*/ :: int [] = n/*0:01*/ (); skip_ahead n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (aux/*1*/ xs/*0:1*/) if n/*0:01*/==4096; skip_ahead n/*0:01*/ :: int (_/*0:101*/:xs/*0:11*/) = skip_ahead/*1*/ (n/*0:01*/+1) xs/*0:11*/; skip_ahead n/*0:01*/ :: int xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: skip_ahead n::int [] = n ()
  rule #1: skip_ahead n::int xs = n (aux xs) if n==4096
  rule #2: skip_ahead n::int (_:xs) = skip_ahead (n+1) xs
  rule #3: skip_ahead n::int xs = throw (bad_list_value xs)
  state 0: #0 #1 #2 #3
	<var>::int state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #1 #3
  state 3: #1 #2 #3
	<var> state 4
	<app> state 6
  state 4: #1 #3
	<var> state 5
  state 5: #1 #3
  state 6: #1 #2 #3
	<var> state 7
	: state 10
  state 7: #1 #3
	<var> state 8
  state 8: #1 #3
	<var> state 9
  state 9: #1 #3
  state 10: #1 #2 #3
	<var> state 11
  state 11: #1 #2 #3
	<var> state 12
  state 12: #1 #2 #3
  state 13: #0 #1 #3
}; append n/*0:001*/ :: int [] ys/*0:1*/ = ys/*0:1*/; append 0 _/*0:01*/ ys/*0:1*/ = ys/*0:1*/; append n/*0:001*/ :: int (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = x/*0:0101*/:append/*1*/ (n/*0:001*/-1) xs/*0:011*/ ys/*0:1*/ {
  rule #0: append n::int [] ys = ys
  rule #1: append 0 _ ys = ys
  rule #2: append n::int (x:xs) ys = x:append (n-1) xs ys
  state 0: #0 #1 #2
	<var>::int state 1
	0::int state 10
  state 1: #0 #2
	<app> state 2
	[] state 8
  state 2: #2
	<app> state 3
  state 3: #2
	: state 4
  state 4: #2
	<var> state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
  state 8: #0
	<var> state 9
  state 9: #0
  state 10: #0 #1 #2
	<var> state 11
	<app> state 13
	[] state 26
  state 11: #1
	<var> state 12
  state 12: #1
  state 13: #1 #2
	<var> state 14
	<app> state 17
  state 14: #1
	<var> state 15
  state 15: #1
	<var> state 16
  state 16: #1
  state 17: #1 #2
	<var> state 18
	: state 22
  state 18: #1
	<var> state 19
  state 19: #1
	<var> state 20
  state 20: #1
	<var> state 21
  state 21: #1
  state 22: #1 #2
	<var> state 23
  state 23: #1 #2
	<var> state 24
  state 24: #1 #2
	<var> state 25
  state 25: #1 #2
  state 26: #0 #1
	<var> state 27
  state 27: #0 #1
} end;
rmlastby p/*0:01*/ [] = [];
rmlastby p/*0:01*/ ys@(_/*0:101*/:_/*0:11*/) = case aux/*0*/ ys/*0:1*/ of __std__::notfound = ys/*1:1*/; ys/*0:*/ = ys/*0:*/ {
  rule #0: __std__::notfound = ys
  rule #1: ys = ys
  state 0: #0 #1
	<var> state 1
	__std__::notfound state 2
  state 1: #1
  state 2: #0 #1
} end with aux xs/*0:1*/ = case skip_ahead/*1*/ 0 xs/*0:1*/ of len_pre@_/*0:0*/ __std__::notfound = pop_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with pop_pre 0 _/*0:1*/ = __std__::notfound; pop_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = case pop_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/ of __std__::notfound = if p/*4:01*/ x/*1:101*/ then xs/*1:11*/ else __std__::notfound; ys/*0:*/ = x/*1:101*/:ys/*0:*/ {
  rule #0: __std__::notfound = if p x then xs else __std__::notfound
  rule #1: ys = x:ys
  state 0: #0 #1
	<var> state 1
	__std__::notfound state 2
  state 1: #1
  state 2: #0 #1
} end {
  rule #0: pop_pre 0 _ = __std__::notfound
  rule #1: pop_pre n::int (x:xs) = case pop_pre (n-1) xs of __std__::notfound = if p x then xs else __std__::notfound; ys = x:ys end
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end; len_pre@_/*0:0*/ ys/*0:1*/ = append/*2*/ len_pre/*0:0*/ xs/*1:1*/ ys/*0:1*/ {
  rule #0: len_pre@_ __std__::notfound = pop_pre len_pre xs with pop_pre 0 _ = __std__::notfound; pop_pre n::int (x:xs) = case pop_pre (n-1) xs of __std__::notfound = if p x then xs else __std__::notfound; ys = x:ys end end
  rule #1: len_pre@_ ys = append len_pre xs ys
  state 0: #0 #1
	<app> state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
	<var> state 3
	__std__::notfound state 4
  state 3: #1
  state 4: #0 #1
} end {
  rule #0: aux xs = case skip_ahead 0 xs of len_pre@_ __std__::notfound = pop_pre len_pre xs with pop_pre 0 _ = __std__::notfound; pop_pre n::int (x:xs) = case pop_pre (n-1) xs of __std__::notfound = if p x then xs else __std__::notfound; ys = x:ys end end; len_pre@_ ys = append len_pre xs ys end
  state 0: #0
	<var> state 1
  state 1: #0
}; skip_ahead n/*0:01*/ :: int [] = n/*0:01*/ __std__::notfound; skip_ahead n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (aux/*1*/ xs/*0:1*/) if n/*0:01*/==4096; skip_ahead n/*0:01*/ :: int (_/*0:101*/:xs/*0:11*/) = skip_ahead/*1*/ (n/*0:01*/+1) xs/*0:11*/; skip_ahead n/*0:01*/ :: int xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: skip_ahead n::int [] = n __std__::notfound
  rule #1: skip_ahead n::int xs = n (aux xs) if n==4096
  rule #2: skip_ahead n::int (_:xs) = skip_ahead (n+1) xs
  rule #3: skip_ahead n::int xs = throw (bad_list_value xs)
  state 0: #0 #1 #2 #3
	<var>::int state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #1 #3
  state 3: #1 #2 #3
	<var> state 4
	<app> state 6
  state 4: #1 #3
	<var> state 5
  state 5: #1 #3
  state 6: #1 #2 #3
	<var> state 7
	: state 10
  state 7: #1 #3
	<var> state 8
  state 8: #1 #3
	<var> state 9
  state 9: #1 #3
  state 10: #1 #2 #3
	<var> state 11
  state 11: #1 #2 #3
	<var> state 12
  state 12: #1 #2 #3
  state 13: #0 #1 #3
}; append n/*0:001*/ :: int [] ys/*0:1*/ = ys/*0:1*/; append 0 _/*0:01*/ ys/*0:1*/ = ys/*0:1*/; append n/*0:001*/ :: int (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = x/*0:0101*/:append/*1*/ (n/*0:001*/-1) xs/*0:011*/ ys/*0:1*/ {
  rule #0: append n::int [] ys = ys
  rule #1: append 0 _ ys = ys
  rule #2: append n::int (x:xs) ys = x:append (n-1) xs ys
  state 0: #0 #1 #2
	<var>::int state 1
	0::int state 10
  state 1: #0 #2
	<app> state 2
	[] state 8
  state 2: #2
	<app> state 3
  state 3: #2
	: state 4
  state 4: #2
	<var> state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
  state 8: #0
	<var> state 9
  state 9: #0
  state 10: #0 #1 #2
	<var> state 11
	<app> state 13
	[] state 26
  state 11: #1
	<var> state 12
  state 12: #1
  state 13: #1 #2
	<var> state 14
	<app> state 17
  state 14: #1
	<var> state 15
  state 15: #1
	<var> state 16
  state 16: #1
  state 17: #1 #2
	<var> state 18
	: state 22
  state 18: #1
	<var> state 19
  state 19: #1
	<var> state 20
  state 20: #1
	<var> state 21
  state 21: #1
  state 22: #1 #2
	<var> state 23
  state 23: #1 #2
	<var> state 24
  state 24: #1 #2
	<var> state 25
  state 25: #1 #2
  state 26: #0 #1
	<var> state 27
  state 27: #0 #1
} end;
foldl f/*0:001*/ a/*0:01*/ [] = a/*0:01*/;
foldl f/*0:001*/ a/*0:01*/ (x/*0:101*/:xs/*0:11*/) = foldl f/*0:001*/ (f/*0:001*/ a/*0:01*/ x/*0:101*/) xs/*0:11*/;
foldl1 f/*0:01*/ (x/*0:101*/:xs/*0:11*/) = foldl f/*0:01*/ x/*0:101*/ xs/*0:11*/;
foldl2 f/*0:0001*/ a/*0:001*/ _/*0:01*/ [] = a/*0:001*/;
foldl2 f/*0:0001*/ a/*0:001*/ [] _/*0:1*/ = a/*0:001*/;
foldl2 f/*0:0001*/ a/*0:001*/ (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = foldl2 f/*0:0001*/ (f/*0:0001*/ a/*0:001*/ x/*0:0101*/ y/*0:101*/) xs/*0:011*/ ys/*0:11*/;
foldl3 f/*0:00001*/ a/*0:0001*/ _/*0:001*/ _/*0:01*/ [] = a/*0:0001*/;
foldl3 f/*0:00001*/ a/*0:0001*/ _/*0:001*/ [] _/*0:1*/ = a/*0:0001*/;
foldl3 f/*0:00001*/ a/*0:0001*/ [] _/*0:01*/ _/*0:1*/ = a/*0:0001*/;
foldl3 f/*0:00001*/ a/*0:0001*/ (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = foldl3 f/*0:00001*/ (f/*0:00001*/ a/*0:0001*/ x/*0:00101*/ y/*0:0101*/ z/*0:101*/) xs/*0:0011*/ ys/*0:011*/ zs/*0:11*/;
foldr f/*0:001*/ a/*0:01*/ [] = a/*0:01*/;
foldr1 f/*0:01*/ [x/*0:101*/] = x/*0:101*/;
foldr2 f/*0:0001*/ a/*0:001*/ _/*0:01*/ [] = a/*0:001*/;
foldr2 f/*0:0001*/ a/*0:001*/ [] _/*0:1*/ = a/*0:001*/;
foldr3 f/*0:00001*/ a/*0:0001*/ _/*0:001*/ _/*0:01*/ [] = a/*0:0001*/;
foldr3 f/*0:00001*/ a/*0:0001*/ _/*0:001*/ [] _/*0:1*/ = a/*0:0001*/;
foldr3 f/*0:00001*/ a/*0:0001*/ [] _/*0:01*/ _/*0:1*/ = a/*0:0001*/;
foldr f/*0:001*/ a/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = aux/*0*/ xs/*0:1*/ with aux xs/*0:1*/ = fold_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with fold_pre 0 _/*0:1*/ = folded_tail/*1:1*/; fold_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = f/*3:001*/ x/*0:101*/ (fold_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/) {
  rule #0: fold_pre 0 _ = folded_tail
  rule #1: fold_pre n::int (x:xs) = f x (fold_pre (n-1) xs)
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ folded_tail/*0:1*/ = skip_ahead/*1*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ folded_tail = skip_ahead 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux xs = fold_pre len_pre xs with fold_pre 0 _ = folded_tail; fold_pre n::int (x:xs) = f x (fold_pre (n-1) xs) end when len_pre@_ folded_tail = skip_ahead 0 xs end
  state 0: #0
	<var> state 1
  state 1: #0
}; skip_ahead n/*0:01*/ :: int [] = n/*0:01*/ a/*1:01*/; skip_ahead n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = n/*0:01*/ (aux/*1*/ xs/*0:1*/) if n/*0:01*/==4096; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ (f/*1:001*/ x/*0:101*/ (aux/*2*/ xs/*1:11*/&)) if thunkp xs/*0:11*/; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = skip_ahead/*1*/ (n/*0:01*/+1) xs/*0:11*/; skip_ahead n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (foldr f/*1:001*/ a/*1:01*/ xs/*0:1*/) {
  rule #0: skip_ahead n::int [] = n a
  rule #1: skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096
  rule #2: skip_ahead n::int (x:xs) = n (f x (aux xs&)) if thunkp xs
  rule #3: skip_ahead n::int (x:xs) = skip_ahead (n+1) xs
  rule #4: skip_ahead n::int xs = n (foldr f a xs)
  state 0: #0 #1 #2 #3 #4
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #4
  state 3: #1 #2 #3 #4
	<var> state 4
	<app> state 6
  state 4: #4
	<var> state 5
  state 5: #4
  state 6: #1 #2 #3 #4
	<var> state 7
	: state 10
  state 7: #4
	<var> state 8
  state 8: #4
	<var> state 9
  state 9: #4
  state 10: #1 #2 #3 #4
	<var> state 11
  state 11: #1 #2 #3 #4
	<var> state 12
  state 12: #1 #2 #3 #4
  state 13: #0 #4
} end;
foldr1 f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = aux/*0*/ xs/*0:1*/ with aux xs/*0:1*/ = fold_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with fold_pre 0 _/*0:1*/ = folded_tail/*1:1*/; fold_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = f/*3:01*/ x/*0:101*/ (fold_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/) {
  rule #0: fold_pre 0 _ = folded_tail
  rule #1: fold_pre n::int (x:xs) = f x (fold_pre (n-1) xs)
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ folded_tail/*0:1*/ = skip_ahead/*1*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ folded_tail = skip_ahead 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux xs = fold_pre len_pre xs with fold_pre 0 _ = folded_tail; fold_pre n::int (x:xs) = f x (fold_pre (n-1) xs) end when len_pre@_ folded_tail = skip_ahead 0 xs end
  state 0: #0
	<var> state 1
  state 1: #0
}; skip_ahead n/*0:01*/ :: int ys@(_/*0:101*/:xs/*0:11*/) = n/*0:01*/ (aux/*1*/ ys/*0:1*/) if n/*0:01*/==4096; skip_ahead n/*0:01*/ :: int ys@(_/*0:101*/:xs/*0:11*/) = n/*0:01*/ (foldr1 f/*2:01*/ ys/*1:1*/&) if thunkp xs/*0:11*/; skip_ahead n/*0:01*/ :: int xs/*0:1*/ = case xs/*0:1*/ of [x/*0:01*/] = n/*1:01*/ x/*0:01*/; x/*0:01*/:xs/*0:1*/ = skip_ahead/*2*/ (n/*1:01*/+1) xs/*0:1*/; _/*0:*/ = n/*1:01*/ (foldr1 f/*2:01*/ xs/*1:1*/) {
  rule #0: [x] = n x
  rule #1: x:xs = skip_ahead (n+1) xs
  rule #2: _ = n (foldr1 f xs)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #1 #2
	<var> state 10
  state 10: #0 #1 #2
	<var> state 11
	[] state 12
  state 11: #1 #2
  state 12: #0 #1 #2
} end {
  rule #0: skip_ahead n::int ys@(_:xs) = n (aux ys) if n==4096
  rule #1: skip_ahead n::int ys@(_:xs) = n (foldr1 f ys&) if thunkp xs
  rule #2: skip_ahead n::int xs = case xs of [x] = n x; x:xs = skip_ahead (n+1) xs; _ = n (foldr1 f xs) end
  state 0: #0 #1 #2
	<var>::int state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
  state 2: #2
  state 3: #0 #1 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #1 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #1 #2
	<var> state 11
  state 11: #0 #1 #2
	<var> state 12
  state 12: #0 #1 #2
} end;
foldr2 f/*0:0001*/ a/*0:001*/ xs@(_/*0:0101*/:_/*0:011*/) ys@(_/*0:101*/:_/*0:11*/) = aux/*0*/ xs/*0:01*/ ys/*0:1*/ with aux xs/*0:01*/ ys/*0:1*/ = fold_pre/*0*/ len_pre/*0:0*/ xs/*1:01*/ ys/*1:1*/ with fold_pre 0 _/*0:01*/ _/*0:1*/ = folded_tail/*1:1*/; fold_pre n/*0:001*/ :: int (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = f/*3:0001*/ x/*0:0101*/ y/*0:101*/ (fold_pre/*1*/ (n/*0:001*/-1) xs/*0:011*/ ys/*0:11*/) {
  rule #0: fold_pre 0 _ _ = folded_tail
  rule #1: fold_pre n::int (x:xs) (y:ys) = f x y (fold_pre (n-1) xs ys)
  state 0: #0 #1
	<var>::int state 1
	0::int state 12
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
	<app> state 7
  state 7: #1
	<app> state 8
  state 8: #1
	: state 9
  state 9: #1
	<var> state 10
  state 10: #1
	<var> state 11
  state 11: #1
  state 12: #0 #1
	<var> state 13
	<app> state 15
  state 13: #0
	<var> state 14
  state 14: #0
  state 15: #0 #1
	<var> state 16
	<app> state 19
  state 16: #0
	<var> state 17
  state 17: #0
	<var> state 18
  state 18: #0
  state 19: #0 #1
	<var> state 20
	: state 24
  state 20: #0
	<var> state 21
  state 21: #0
	<var> state 22
  state 22: #0
	<var> state 23
  state 23: #0
  state 24: #0 #1
	<var> state 25
  state 25: #0 #1
	<var> state 26
  state 26: #0 #1
	<var> state 27
	<app> state 28
  state 27: #0
  state 28: #0 #1
	<var> state 29
	<app> state 31
  state 29: #0
	<var> state 30
  state 30: #0
  state 31: #0 #1
	<var> state 32
	: state 35
  state 32: #0
	<var> state 33
  state 33: #0
	<var> state 34
  state 34: #0
  state 35: #0 #1
	<var> state 36
  state 36: #0 #1
	<var> state 37
  state 37: #0 #1
} end when len_pre@_/*0:0*/ folded_tail/*0:1*/ = skip_ahead/*1*/ 0 xs/*0:01*/ ys/*0:1*/ {
  rule #0: len_pre@_ folded_tail = skip_ahead 0 xs ys
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux xs ys = fold_pre len_pre xs ys with fold_pre 0 _ _ = folded_tail; fold_pre n::int (x:xs) (y:ys) = f x y (fold_pre (n-1) xs ys) end when len_pre@_ folded_tail = skip_ahead 0 xs ys end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}; skip_ahead n/*0:001*/ :: int [] _/*0:1*/ = n/*0:001*/ a/*1:001*/; skip_ahead n/*0:001*/ :: int _/*0:01*/ [] = n/*0:001*/ a/*1:001*/; skip_ahead n/*0:001*/ :: int xs@(_/*0:0101*/:_/*0:011*/) ys@(_/*0:101*/:_/*0:11*/) = n/*0:001*/ (aux/*1*/ xs/*0:01*/ ys/*0:1*/) if n/*0:001*/==4096; skip_ahead n/*0:001*/ :: int (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = n/*0:001*/ (f/*1:0001*/ x/*0:0101*/ y/*0:101*/ (aux/*2*/ xs/*1:011*/ ys/*1:11*/&)) if thunkp xs/*0:011*/||thunkp ys/*0:11*/; skip_ahead n/*0:001*/ :: int (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = skip_ahead/*1*/ (n/*0:001*/+1) xs/*0:011*/ ys/*0:11*/; skip_ahead n/*0:001*/ :: int xs/*0:01*/ ys/*0:1*/ = n/*0:001*/ (foldr2 f/*1:0001*/ a/*1:001*/ xs/*0:01*/ ys/*0:1*/) {
  rule #0: skip_ahead n::int [] _ = n a
  rule #1: skip_ahead n::int _ [] = n a
  rule #2: skip_ahead n::int xs@(_:_) ys@(_:_) = n (aux xs ys) if n==4096
  rule #3: skip_ahead n::int (x:xs) (y:ys) = n (f x y (aux xs ys&)) if thunkp xs||thunkp ys
  rule #4: skip_ahead n::int (x:xs) (y:ys) = skip_ahead (n+1) xs ys
  rule #5: skip_ahead n::int xs ys = n (foldr2 f a xs ys)
  state 0: #0 #1 #2 #3 #4 #5
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4 #5
	<var> state 2
	<app> state 5
	[] state 31
  state 2: #1 #5
	<var> state 3
	[] state 4
  state 3: #5
  state 4: #1 #5
  state 5: #1 #2 #3 #4 #5
	<var> state 6
	<app> state 10
  state 6: #1 #5
	<var> state 7
  state 7: #1 #5
	<var> state 8
	[] state 9
  state 8: #5
  state 9: #1 #5
  state 10: #1 #2 #3 #4 #5
	<var> state 11
	: state 16
  state 11: #1 #5
	<var> state 12
  state 12: #1 #5
	<var> state 13
  state 13: #1 #5
	<var> state 14
	[] state 15
  state 14: #5
  state 15: #1 #5
  state 16: #1 #2 #3 #4 #5
	<var> state 17
  state 17: #1 #2 #3 #4 #5
	<var> state 18
  state 18: #1 #2 #3 #4 #5
	<var> state 19
	<app> state 20
	[] state 30
  state 19: #5
  state 20: #2 #3 #4 #5
	<var> state 21
	<app> state 23
  state 21: #5
	<var> state 22
  state 22: #5
  state 23: #2 #3 #4 #5
	<var> state 24
	: state 27
  state 24: #5
	<var> state 25
  state 25: #5
	<var> state 26
  state 26: #5
  state 27: #2 #3 #4 #5
	<var> state 28
  state 28: #2 #3 #4 #5
	<var> state 29
  state 29: #2 #3 #4 #5
  state 30: #1 #5
  state 31: #0 #1 #5
	<var> state 32
	[] state 33
  state 32: #0 #5
  state 33: #0 #1 #5
} end;
foldr3 f/*0:00001*/ a/*0:0001*/ xs@(_/*0:00101*/:_/*0:0011*/) ys@(_/*0:0101*/:_/*0:011*/) zs@(_/*0:101*/:_/*0:11*/) = aux/*0*/ xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ with aux xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ = fold_pre/*0*/ len_pre/*0:0*/ xs/*1:001*/ ys/*1:01*/ zs/*1:1*/ with fold_pre 0 _/*0:001*/ _/*0:01*/ _/*0:1*/ = folded_tail/*1:1*/; fold_pre n/*0:0001*/ :: int (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = f/*3:00001*/ x/*0:00101*/ y/*0:0101*/ z/*0:101*/ (fold_pre/*1*/ (n/*0:0001*/-1) xs/*0:0011*/ ys/*0:011*/ zs/*0:11*/) {
  rule #0: fold_pre 0 _ _ _ = folded_tail
  rule #1: fold_pre n::int (x:xs) (y:ys) (z:zs) = f x y z (fold_pre (n-1) xs ys zs)
  state 0: #0 #1
	<var>::int state 1
	0::int state 17
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
	<app> state 7
  state 7: #1
	<app> state 8
  state 8: #1
	: state 9
  state 9: #1
	<var> state 10
  state 10: #1
	<var> state 11
  state 11: #1
	<app> state 12
  state 12: #1
	<app> state 13
  state 13: #1
	: state 14
  state 14: #1
	<var> state 15
  state 15: #1
	<var> state 16
  state 16: #1
  state 17: #0 #1
	<var> state 18
	<app> state 21
  state 18: #0
	<var> state 19
  state 19: #0
	<var> state 20
  state 20: #0
  state 21: #0 #1
	<var> state 22
	<app> state 26
  state 22: #0
	<var> state 23
  state 23: #0
	<var> state 24
  state 24: #0
	<var> state 25
  state 25: #0
  state 26: #0 #1
	<var> state 27
	: state 32
  state 27: #0
	<var> state 28
  state 28: #0
	<var> state 29
  state 29: #0
	<var> state 30
  state 30: #0
	<var> state 31
  state 31: #0
  state 32: #0 #1
	<var> state 33
  state 33: #0 #1
	<var> state 34
  state 34: #0 #1
	<var> state 35
	<app> state 37
  state 35: #0
	<var> state 36
  state 36: #0
  state 37: #0 #1
	<var> state 38
	<app> state 41
  state 38: #0
	<var> state 39
  state 39: #0
	<var> state 40
  state 40: #0
  state 41: #0 #1
	<var> state 42
	: state 46
  state 42: #0
	<var> state 43
  state 43: #0
	<var> state 44
  state 44: #0
	<var> state 45
  state 45: #0
  state 46: #0 #1
	<var> state 47
  state 47: #0 #1
	<var> state 48
  state 48: #0 #1
	<var> state 49
	<app> state 50
  state 49: #0
  state 50: #0 #1
	<var> state 51
	<app> state 53
  state 51: #0
	<var> state 52
  state 52: #0
  state 53: #0 #1
	<var> state 54
	: state 57
  state 54: #0
	<var> state 55
  state 55: #0
	<var> state 56
  state 56: #0
  state 57: #0 #1
	<var> state 58
  state 58: #0 #1
	<var> state 59
  state 59: #0 #1
} end when len_pre@_/*0:0*/ folded_tail/*0:1*/ = skip_ahead/*1*/ 0 xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ {
  rule #0: len_pre@_ folded_tail = skip_ahead 0 xs ys zs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux xs ys zs = fold_pre len_pre xs ys zs with fold_pre 0 _ _ _ = folded_tail; fold_pre n::int (x:xs) (y:ys) (z:zs) = f x y z (fold_pre (n-1) xs ys zs) end when len_pre@_ folded_tail = skip_ahead 0 xs ys zs end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}; skip_ahead n/*0:0001*/ :: int [] _/*0:01*/ _/*0:1*/ = n/*0:0001*/ a/*1:0001*/; skip_ahead n/*0:0001*/ :: int _/*0:001*/ [] _/*0:1*/ = n/*0:0001*/ a/*1:0001*/; skip_ahead n/*0:0001*/ :: int _/*0:001*/ _/*0:01*/ [] = n/*0:0001*/ a/*1:0001*/; skip_ahead n/*0:0001*/ :: int xs@(_/*0:00101*/:_/*0:0011*/) ys@(_/*0:0101*/:_/*0:011*/) zs@(_/*0:101*/:_/*0:11*/) = n/*0:0001*/ (aux/*1*/ xs/*0:001*/ ys/*0:01*/ zs/*0:1*/) if n/*0:0001*/==4096; skip_ahead n/*0:0001*/ :: int (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = n/*0:0001*/ (f/*1:00001*/ x/*0:00101*/ y/*0:0101*/ z/*0:101*/ (aux/*2*/ xs/*1:0011*/ ys/*1:011*/ zs/*1:11*/&)) if thunkp xs/*0:0011*/||thunkp ys/*0:011*/||thunkp zs/*0:11*/; skip_ahead n/*0:0001*/ :: int (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = skip_ahead/*1*/ (n/*0:0001*/+1) xs/*0:0011*/ ys/*0:011*/ zs/*0:11*/; skip_ahead n/*0:0001*/ :: int xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ = n/*0:0001*/ (foldr3 f/*1:00001*/ a/*1:0001*/ xs/*0:001*/ ys/*0:01*/ zs/*0:1*/) {
  rule #0: skip_ahead n::int [] _ _ = n a
  rule #1: skip_ahead n::int _ [] _ = n a
  rule #2: skip_ahead n::int _ _ [] = n a
  rule #3: skip_ahead n::int xs@(_:_) ys@(_:_) zs@(_:_) = n (aux xs ys zs) if n==4096
  rule #4: skip_ahead n::int (x:xs) (y:ys) (z:zs) = n (f x y z (aux xs ys zs&)) if thunkp xs||thunkp ys||thunkp zs
  rule #5: skip_ahead n::int (x:xs) (y:ys) (z:zs) = skip_ahead (n+1) xs ys zs
  rule #6: skip_ahead n::int xs ys zs = n (foldr3 f a xs ys zs)
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4 #5 #6
	<var> state 2
	<app> state 9
	[] state 63
  state 2: #1 #2 #6
	<var> state 3
	[] state 6
  state 3: #2 #6
	<var> state 4
	[] state 5
  state 4: #6
  state 5: #2 #6
  state 6: #1 #2 #6
	<var> state 7
	[] state 8
  state 7: #1 #6
  state 8: #1 #2 #6
  state 9: #1 #2 #3 #4 #5 #6
	<var> state 10
	<app> state 18
  state 10: #1 #2 #6
	<var> state 11
  state 11: #1 #2 #6
	<var> state 12
	[] state 15
  state 12: #2 #6
	<var> state 13
	[] state 14
  state 13: #6
  state 14: #2 #6
  state 15: #1 #2 #6
	<var> state 16
	[] state 17
  state 16: #1 #6
  state 17: #1 #2 #6
  state 18: #1 #2 #3 #4 #5 #6
	<var> state 19
	: state 28
  state 19: #1 #2 #6
	<var> state 20
  state 20: #1 #2 #6
	<var> state 21
  state 21: #1 #2 #6
	<var> state 22
	[] state 25
  state 22: #2 #6
	<var> state 23
	[] state 24
  state 23: #6
  state 24: #2 #6
  state 25: #1 #2 #6
	<var> state 26
	[] state 27
  state 26: #1 #6
  state 27: #1 #2 #6
  state 28: #1 #2 #3 #4 #5 #6
	<var> state 29
  state 29: #1 #2 #3 #4 #5 #6
	<var> state 30
  state 30: #1 #2 #3 #4 #5 #6
	<var> state 31
	<app> state 34
	[] state 60
  state 31: #2 #6
	<var> state 32
	[] state 33
  state 32: #6
  state 33: #2 #6
  state 34: #2 #3 #4 #5 #6
	<var> state 35
	<app> state 39
  state 35: #2 #6
	<var> state 36
  state 36: #2 #6
	<var> state 37
	[] state 38
  state 37: #6
  state 38: #2 #6
  state 39: #2 #3 #4 #5 #6
	<var> state 40
	: state 45
  state 40: #2 #6
	<var> state 41
  state 41: #2 #6
	<var> state 42
  state 42: #2 #6
	<var> state 43
	[] state 44
  state 43: #6
  state 44: #2 #6
  state 45: #2 #3 #4 #5 #6
	<var> state 46
  state 46: #2 #3 #4 #5 #6
	<var> state 47
  state 47: #2 #3 #4 #5 #6
	<var> state 48
	<app> state 49
	[] state 59
  state 48: #6
  state 49: #3 #4 #5 #6
	<var> state 50
	<app> state 52
  state 50: #6
	<var> state 51
  state 51: #6
  state 52: #3 #4 #5 #6
	<var> state 53
	: state 56
  state 53: #6
	<var> state 54
  state 54: #6
	<var> state 55
  state 55: #6
  state 56: #3 #4 #5 #6
	<var> state 57
  state 57: #3 #4 #5 #6
	<var> state 58
  state 58: #3 #4 #5 #6
  state 59: #2 #6
  state 60: #1 #2 #6
	<var> state 61
	[] state 62
  state 61: #1 #6
  state 62: #1 #2 #6
  state 63: #0 #1 #2 #6
	<var> state 64
	[] state 67
  state 64: #0 #2 #6
	<var> state 65
	[] state 66
  state 65: #0 #6
  state 66: #0 #2 #6
  state 67: #0 #1 #2 #6
	<var> state 68
	[] state 69
  state 68: #0 #1 #6
  state 69: #0 #1 #2 #6
} end;
head (x/*0:101*/:xs/*0:11*/) = x/*0:101*/;
init [_/*0:101*/] = [];
init xs@(_/*0:101*/:_/*0:11*/) = aux/*0*/ xs/*0:1*/ with aux xs/*0:1*/ = init_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with init_pre 0 _/*0:1*/ = chopped_tail/*1:1*/; init_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:init_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/ {
  rule #0: init_pre 0 _ = chopped_tail
  rule #1: init_pre n::int (x:xs) = x:init_pre (n-1) xs
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ chopped_tail/*0:1*/ = skip_ahead/*1*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ chopped_tail = skip_ahead 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux xs = init_pre len_pre xs with init_pre 0 _ = chopped_tail; init_pre n::int (x:xs) = x:init_pre (n-1) xs end when len_pre@_ chopped_tail = skip_ahead 0 xs end
  state 0: #0
	<var> state 1
  state 1: #0
}; skip_ahead n/*0:01*/ :: int ys@(x/*0:101*/:xs/*0:11*/) = n/*0:01*/ (aux/*1*/ ys/*0:1*/) if n/*0:01*/==4096; skip_ahead n/*0:01*/ :: int ys@(x/*0:101*/:xs/*0:11*/) = n/*0:01*/ (init ys/*1:1*/&) if thunkp xs/*0:11*/; skip_ahead n/*0:01*/ :: int xs/*0:1*/ = case xs/*0:1*/ of [_/*0:01*/] = n/*1:01*/ []; _/*0:01*/:xs/*0:1*/ = skip_ahead/*2*/ (n/*1:01*/+1) xs/*0:1*/; _/*0:*/ = n/*1:01*/ (init xs/*1:1*/) {
  rule #0: [_] = n []
  rule #1: _:xs = skip_ahead (n+1) xs
  rule #2: _ = n (init xs)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #1 #2
	<var> state 10
  state 10: #0 #1 #2
	<var> state 11
	[] state 12
  state 11: #1 #2
  state 12: #0 #1 #2
} end {
  rule #0: skip_ahead n::int ys@(x:xs) = n (aux ys) if n==4096
  rule #1: skip_ahead n::int ys@(x:xs) = n (init ys&) if thunkp xs
  rule #2: skip_ahead n::int xs = case xs of [_] = n []; _:xs = skip_ahead (n+1) xs; _ = n (init xs) end
  state 0: #0 #1 #2
	<var>::int state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
  state 2: #2
  state 3: #0 #1 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #1 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #1 #2
	<var> state 11
  state 11: #0 #1 #2
	<var> state 12
  state 12: #0 #1 #2
} end;
last [x/*0:101*/] = x/*0:101*/;
last (x/*0:101*/:xs/*0:11*/) = last xs/*0:11*/;
map_onto f/*0:001*/ base/*0:01*/ [] = base/*0:01*/;
map f/*0:01*/ [] = [];
map_onto f/*0:001*/ base/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = aux/*0*/ xs/*0:1*/ with aux xs/*0:1*/ = map_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with map_pre 0 _/*0:1*/ = mapped_tail/*1:1*/; map_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = f/*3:001*/ x/*0:101*/:map_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/ {
  rule #0: map_pre 0 _ = mapped_tail
  rule #1: map_pre n::int (x:xs) = f x:map_pre (n-1) xs
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ mapped_tail/*0:1*/ = skip_ahead/*1*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ mapped_tail = skip_ahead 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux xs = map_pre len_pre xs with map_pre 0 _ = mapped_tail; map_pre n::int (x:xs) = f x:map_pre (n-1) xs end when len_pre@_ mapped_tail = skip_ahead 0 xs end
  state 0: #0
	<var> state 1
  state 1: #0
}; skip_ahead n/*0:01*/ :: int [] = n/*0:01*/ base/*1:01*/; skip_ahead n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = n/*0:01*/ (aux/*1*/ xs/*0:1*/) if n/*0:01*/==4096; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ (f/*1:001*/ x/*0:101*/:aux/*2*/ xs/*1:11*/&) if thunkp xs/*0:11*/; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = skip_ahead/*1*/ (n/*0:01*/+1) xs/*0:11*/; skip_ahead n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (map_onto f/*1:001*/ base/*1:01*/ xs/*0:1*/) {
  rule #0: skip_ahead n::int [] = n base
  rule #1: skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096
  rule #2: skip_ahead n::int (x:xs) = n (f x:aux xs&) if thunkp xs
  rule #3: skip_ahead n::int (x:xs) = skip_ahead (n+1) xs
  rule #4: skip_ahead n::int xs = n (map_onto f base xs)
  state 0: #0 #1 #2 #3 #4
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #4
  state 3: #1 #2 #3 #4
	<var> state 4
	<app> state 6
  state 4: #4
	<var> state 5
  state 5: #4
  state 6: #1 #2 #3 #4
	<var> state 7
	: state 10
  state 7: #4
	<var> state 8
  state 8: #4
	<var> state 9
  state 9: #4
  state 10: #1 #2 #3 #4
	<var> state 11
  state 11: #1 #2 #3 #4
	<var> state 12
  state 12: #1 #2 #3 #4
  state 13: #0 #4
} end;
map f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = aux/*0*/ xs/*0:1*/ with aux xs/*0:1*/ = map_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with map_pre 0 _/*0:1*/ = mapped_tail/*1:1*/; map_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = f/*3:01*/ x/*0:101*/:map_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/ {
  rule #0: map_pre 0 _ = mapped_tail
  rule #1: map_pre n::int (x:xs) = f x:map_pre (n-1) xs
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ mapped_tail/*0:1*/ = skip_ahead/*1*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ mapped_tail = skip_ahead 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux xs = map_pre len_pre xs with map_pre 0 _ = mapped_tail; map_pre n::int (x:xs) = f x:map_pre (n-1) xs end when len_pre@_ mapped_tail = skip_ahead 0 xs end
  state 0: #0
	<var> state 1
  state 1: #0
}; skip_ahead n/*0:01*/ :: int [] = n/*0:01*/ []; skip_ahead n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = n/*0:01*/ (aux/*1*/ xs/*0:1*/) if n/*0:01*/==4096; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ (f/*1:01*/ x/*0:101*/:aux/*2*/ xs/*1:11*/&) if thunkp xs/*0:11*/; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = skip_ahead/*1*/ (n/*0:01*/+1) xs/*0:11*/; skip_ahead n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (map f/*1:01*/ xs/*0:1*/) {
  rule #0: skip_ahead n::int [] = n []
  rule #1: skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096
  rule #2: skip_ahead n::int (x:xs) = n (f x:aux xs&) if thunkp xs
  rule #3: skip_ahead n::int (x:xs) = skip_ahead (n+1) xs
  rule #4: skip_ahead n::int xs = n (map f xs)
  state 0: #0 #1 #2 #3 #4
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #4
  state 3: #1 #2 #3 #4
	<var> state 4
	<app> state 6
  state 4: #4
	<var> state 5
  state 5: #4
  state 6: #1 #2 #3 #4
	<var> state 7
	: state 10
  state 7: #4
	<var> state 8
  state 8: #4
	<var> state 9
  state 9: #4
  state 10: #1 #2 #3 #4
	<var> state 11
  state 11: #1 #2 #3 #4
	<var> state 12
  state 12: #1 #2 #3 #4
  state 13: #0 #4
} end;
partition p/*0:01*/ [] = [],[];
partition p/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = aux/*0*/ xs/*0:1*/ with aux xs/*0:1*/ = split_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with split_pre 0 _/*0:1*/ = split_tails/*1:1*/; split_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = add/*3*/ p/*3:01*/ x/*0:101*/ (split_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/) {
  rule #0: split_pre 0 _ = split_tails
  rule #1: split_pre n::int (x:xs) = add p x (split_pre (n-1) xs)
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ split_tails/*0:1*/ = skip_ahead/*1*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ split_tails = skip_ahead 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux xs = split_pre len_pre xs with split_pre 0 _ = split_tails; split_pre n::int (x:xs) = add p x (split_pre (n-1) xs) end when len_pre@_ split_tails = skip_ahead 0 xs end
  state 0: #0
	<var> state 1
  state 1: #0
}; skip_ahead n/*0:01*/ :: int [] = n/*0:01*/ ([],[]); skip_ahead n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = n/*0:01*/ (aux/*1*/ xs/*0:1*/) if n/*0:01*/==4096; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ (add/*1*/ p/*1:01*/ x/*0:101*/ (filter p/*2:01*/ xs/*1:11*/&,filter ((~).p/*2:01*/) xs/*1:11*/&)) if thunkp xs/*0:11*/; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = skip_ahead/*1*/ (n/*0:01*/+1) xs/*0:11*/; skip_ahead n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (filter p/*1:01*/ xs/*0:1*/,filter ((~).p/*1:01*/) xs/*0:1*/) {
  rule #0: skip_ahead n::int [] = n ([],[])
  rule #1: skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096
  rule #2: skip_ahead n::int (x:xs) = n (add p x (filter p xs&,filter ((~).p) xs&)) if thunkp xs
  rule #3: skip_ahead n::int (x:xs) = skip_ahead (n+1) xs
  rule #4: skip_ahead n::int xs = n (filter p xs,filter ((~).p) xs)
  state 0: #0 #1 #2 #3 #4
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #4
  state 3: #1 #2 #3 #4
	<var> state 4
	<app> state 6
  state 4: #4
	<var> state 5
  state 5: #4
  state 6: #1 #2 #3 #4
	<var> state 7
	: state 10
  state 7: #4
	<var> state 8
  state 8: #4
	<var> state 9
  state 9: #4
  state 10: #1 #2 #3 #4
	<var> state 11
  state 11: #1 #2 #3 #4
	<var> state 12
  state 12: #1 #2 #3 #4
  state 13: #0 #4
}; add p/*0:001*/ x/*0:01*/ (yes/*0:101*/,no/*0:11*/) = if p/*0:001*/ x/*0:01*/ then x/*0:01*/:yes/*0:101*/,no/*0:11*/ else yes/*0:101*/,x/*0:01*/:no/*0:11*/ {
  rule #0: add p x (yes,no) = if p x then x:yes,no else yes,x:no
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	<app> state 4
  state 4: #0
	, state 5
  state 5: #0
	<var> state 6
  state 6: #0
	<var> state 7
  state 7: #0
} end;
revmap_onto f/*0:001*/ base/*0:01*/ [] = base/*0:01*/;
revmap_onto f/*0:001*/ base/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ base/*0:01*/ xs/*0:1*/ with tick a/*0:01*/ [] = a/*0:01*/; tick a/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tick/*1*/ (f/*1:001*/ x/*0:101*/:a/*0:01*/) xs/*0:11*/; tick _/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: tick a [] = a
  rule #1: tick a (x:xs) = tick (f x:a) xs
  rule #2: tick _ xs = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #1 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #1 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #1 #2
	<var> state 11
  state 11: #1 #2
	<var> state 12
  state 12: #1 #2
  state 13: #0 #2
} end;
revmap f/*0:01*/ [] = [];
revmap f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = revmap_onto f/*0:01*/ [] xs/*0:1*/;
rotate 1 xs@(_/*0:101*/:_/*0:11*/) = aux/*0*/ xs/*0:1*/ with aux xs/*0:1*/ = lastx/*0:101*/:rotate_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with rotate_pre 0 _/*0:1*/ = chopped_tail/*1:11*/; rotate_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:rotate_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/ {
  rule #0: rotate_pre 0 _ = chopped_tail
  rule #1: rotate_pre n::int (x:xs) = x:rotate_pre (n-1) xs
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ (lastx/*0:101*/:chopped_tail/*0:11*/) = skip_ahead/*1*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ (lastx:chopped_tail) = skip_ahead 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	<app> state 4
  state 4: #0
	: state 5
  state 5: #0
	<var> state 6
  state 6: #0
	<var> state 7
  state 7: #0
} end {
  rule #0: aux xs = lastx:rotate_pre len_pre xs with rotate_pre 0 _ = chopped_tail; rotate_pre n::int (x:xs) = x:rotate_pre (n-1) xs end when len_pre@_ (lastx:chopped_tail) = skip_ahead 0 xs end
  state 0: #0
	<var> state 1
  state 1: #0
}; skip_ahead n/*0:01*/ :: int x@_/*0:101*/:[] = n/*0:01*/ x/*0:1*/; skip_ahead n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = n/*0:01*/ (aux/*1*/ xs/*0:1*/) if n/*0:01*/==4096; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = skip_ahead/*1*/ (n/*0:01*/+1) xs/*0:11*/; skip_ahead n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (rotate xs/*0:1*/) {
  rule #0: skip_ahead n::int x@_:[] = n x
  rule #1: skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096
  rule #2: skip_ahead n::int (x:xs) = skip_ahead (n+1) xs
  rule #3: skip_ahead n::int xs = n (rotate xs)
  state 0: #0 #1 #2 #3
	<var>::int state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<app> state 3
  state 2: #3
  state 3: #0 #1 #2 #3
	<var> state 4
	<app> state 6
  state 4: #3
	<var> state 5
  state 5: #3
  state 6: #0 #1 #2 #3
	<var> state 7
	: state 10
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #0 #1 #2 #3
	<var> state 11
  state 11: #0 #1 #2 #3
	<var> state 12
	[] state 13
  state 12: #1 #2 #3
  state 13: #0 #1 #2 #3
} end;
rotate _/*0:01*/ :: int [] = [];
rotate 0 xs@(_/*0:101*/:_/*0:11*/) = xs/*0:1*/;
rotate n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = post/*0:1*/+pre/*0:01*/ when xn/*0:*/ = #xs/*0:1*/; n/*0:*/ = (xn/*0:*/-n/*1:01*/) mod xn/*0:*/; pre/*0:01*/,post/*0:1*/ = if n/*0:*/>0 then split n/*0:*/ xs/*2:1*/ else if n/*0:*/<0 then split (xn/*1:*/+n/*0:*/) xs/*2:1*/ else xs/*2:1*/,[] {
  rule #0: pre,post = if n>0 then split n xs else if n<0 then split (xn+n) xs else xs,[]
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} {
  rule #0: n = (xn-n) mod xn
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: xn = #xs
  state 0: #0
	<var> state 1
  state 1: #0
} end;
scanl f/*0:001*/ a/*0:01*/ [] = [a/*0:01*/];
scanl f/*0:001*/ a/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ a/*0:01*/ [] xs/*0:1*/ with tick a/*0:001*/ zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = __std__::reverse_onto (tick/*2*/ (f/*2:001*/ a/*1:001*/ x/*1:101*/) xs/*1:11*/&) (a/*0:001*/:zs/*0:01*/) if thunkp xs/*0:11*/; tick a/*0:001*/ zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tick/*1*/ (f/*1:001*/ a/*0:001*/ x/*0:101*/) (a/*0:001*/:zs/*0:01*/) xs/*0:11*/; tick a/*0:001*/ zs/*0:01*/ [] = __std__::reverse_onto [a/*0:001*/] zs/*0:01*/; tick a/*0:001*/ zs/*0:01*/ xs/*0:1*/ = __std__::reverse_onto (scanl f/*1:001*/ a/*0:001*/ xs/*0:1*/) zs/*0:01*/ {
  rule #0: tick a zs (x:xs) = __std__::reverse_onto (tick (f a x) xs&) (a:zs) if thunkp xs
  rule #1: tick a zs (x:xs) = tick (f a x) (a:zs) xs
  rule #2: tick a zs [] = __std__::reverse_onto [a] zs
  rule #3: tick a zs xs = __std__::reverse_onto (scanl f a xs) zs
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
  state 2: #0 #1 #2 #3
	<var> state 3
	<app> state 4
	[] state 14
  state 3: #3
  state 4: #0 #1 #3
	<var> state 5
	<app> state 7
  state 5: #3
	<var> state 6
  state 6: #3
  state 7: #0 #1 #3
	<var> state 8
	: state 11
  state 8: #3
	<var> state 9
  state 9: #3
	<var> state 10
  state 10: #3
  state 11: #0 #1 #3
	<var> state 12
  state 12: #0 #1 #3
	<var> state 13
  state 13: #0 #1 #3
  state 14: #2 #3
} end;
scanl1 f/*0:01*/ [] = [];
scanl1 f/*0:01*/ (x/*0:101*/:xs/*0:11*/) = scanl f/*0:01*/ x/*0:101*/ xs/*0:11*/;
scanr f/*0:001*/ a/*0:01*/ [] = [a/*0:01*/];
scanr f/*0:001*/ a/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*4*/ zs/*3:01*/ us/*0:*/ when ys/*0:*/ = scanr f/*2:001*/ a/*2:01*/ xs/*1:11*/&; y/*0:*/ = (case ys/*1:*/ of y/*0:01*/:_/*0:1*/ = y/*0:01*/; scanr _/*0:001*/ _/*0:01*/ ys/*0:1*/ = throw (bad_list_value ys/*0:1*/); _/*0:*/ = throw (bad_list_value ys/*2:*/) {
  rule #0: y:_ = y
  rule #1: scanr _ _ ys = throw (bad_list_value ys)
  rule #2: _ = throw (bad_list_value ys)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	<app> state 9
	: state 18
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
	scanr state 14
  state 10: #2
	<var> state 11
  state 11: #2
	<var> state 12
  state 12: #2
	<var> state 13
  state 13: #2
  state 14: #1 #2
	<var> state 15
  state 15: #1 #2
	<var> state 16
  state 16: #1 #2
	<var> state 17
  state 17: #1 #2
  state 18: #0 #2
	<var> state 19
  state 19: #0 #2
	<var> state 20
  state 20: #0 #2
} end)&; us/*0:*/ = f/*3:001*/ x/*2:101*/ y/*0:*/:ys/*1:*/ {
  rule #0: us = f x y:ys
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: y = (case ys of y:_ = y; scanr _ _ ys = throw (bad_list_value ys); _ = throw (bad_list_value ys) end)&
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: ys = scanr f a xs&
  state 0: #0
	<var> state 1
  state 1: #0
} end if thunkp xs/*0:11*/; tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*1*/ zs/*0:01*/ (f/*3:001*/ x/*2:101*/ (y/*0:01*/ when y/*0:01*/:_/*0:1*/ = ys/*1:*/ {
  rule #0: y:_ = ys
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end)&:ys/*0:*/ when ys/*0:*/ = scanr f/*2:001*/ a/*2:01*/ xs/*1:11*/& {
  rule #0: ys = scanr f a xs&
  state 0: #0
	<var> state 1
  state 1: #0
} end) if thunkp xs/*0:11*/; tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tick/*1*/ (x/*0:101*/:zs/*0:01*/) xs/*0:11*/; tick zs/*0:01*/ [] = tack/*1*/ zs/*0:01*/ [a/*1:01*/]; tick zs/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: tick zs (x:xs) = tack zs us when ys = scanr f a xs&; y = (case ys of y:_ = y; scanr _ _ ys = throw (bad_list_value ys); _ = throw (bad_list_value ys) end)&; us = f x y:ys end if thunkp xs
  rule #1: tick zs (x:xs) = tack zs (f x (y when y:_ = ys end)&:ys when ys = scanr f a xs& end) if thunkp xs
  rule #2: tick zs (x:xs) = tick (x:zs) xs
  rule #3: tick zs [] = tack zs [a]
  rule #4: tick zs xs = throw (bad_list_value xs)
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #4
  state 3: #0 #1 #2 #4
	<var> state 4
	<app> state 6
  state 4: #4
	<var> state 5
  state 5: #4
  state 6: #0 #1 #2 #4
	<var> state 7
	: state 10
  state 7: #4
	<var> state 8
  state 8: #4
	<var> state 9
  state 9: #4
  state 10: #0 #1 #2 #4
	<var> state 11
  state 11: #0 #1 #2 #4
	<var> state 12
  state 12: #0 #1 #2 #4
  state 13: #3 #4
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*2*/ xs/*1:011*/ (f/*2:001*/ x/*1:0101*/ y/*0:01*/:ys/*1:1*/) when y/*0:01*/:_/*0:1*/ = ys/*0:1*/ {
  rule #0: y:_ = ys
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end; tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (f x y:ys) when y:_ = ys end
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
scanr1 f/*0:01*/ [] = [];
scanr1 f/*0:01*/ [x/*0:101*/] = [x/*0:101*/];
scanr1 f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*4*/ zs/*3:01*/ us/*0:*/ when ys/*0:*/ = scanr1 f/*2:01*/ xs/*1:11*/&; y/*0:*/ = (case ys/*1:*/ of y/*0:01*/:_/*0:1*/ = y/*0:01*/; scanr1 _/*0:01*/ ys/*0:1*/ = throw (bad_list_value ys/*0:1*/); _/*0:*/ = throw (bad_list_value ys/*2:*/) {
  rule #0: y:_ = y
  rule #1: scanr1 _ ys = throw (bad_list_value ys)
  rule #2: _ = throw (bad_list_value ys)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
	scanr1 state 12
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #2
	<var> state 10
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
  state 12: #1 #2
	<var> state 13
  state 13: #1 #2
	<var> state 14
  state 14: #1 #2
} end)&; us/*0:*/ = f/*3:01*/ x/*2:101*/ y/*0:*/:ys/*1:*/ {
  rule #0: us = f x y:ys
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: y = (case ys of y:_ = y; scanr1 _ ys = throw (bad_list_value ys); _ = throw (bad_list_value ys) end)&
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: ys = scanr1 f xs&
  state 0: #0
	<var> state 1
  state 1: #0
} end if thunkp xs/*0:11*/; tick zs/*0:01*/ xs/*0:1*/ = case xs/*0:1*/ of [x/*0:01*/] = tack/*2*/ zs/*1:01*/ [x/*0:01*/]; x/*0:01*/:xs/*0:1*/ = tick/*2*/ (x/*0:01*/:zs/*1:01*/) xs/*0:1*/; _/*0:*/ = throw (bad_list_value xs/*1:1*/) {
  rule #0: [x] = tack zs [x]
  rule #1: x:xs = tick (x:zs) xs
  rule #2: _ = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #1 #2
	<var> state 10
  state 10: #0 #1 #2
	<var> state 11
	[] state 12
  state 11: #1 #2
  state 12: #0 #1 #2
} end {
  rule #0: tick zs (x:xs) = tack zs us when ys = scanr1 f xs&; y = (case ys of y:_ = y; scanr1 _ ys = throw (bad_list_value ys); _ = throw (bad_list_value ys) end)&; us = f x y:ys end if thunkp xs
  rule #1: tick zs xs = case xs of [x] = tack zs [x]; x:xs = tick (x:zs) xs; _ = throw (bad_list_value xs) end
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	: state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*2*/ xs/*1:011*/ (f/*2:01*/ x/*1:0101*/ y/*0:01*/:ys/*1:1*/) when y/*0:01*/:_/*0:1*/ = ys/*0:1*/ {
  rule #0: y:_ = ys
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end; tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (f x y:ys) when y:_ = ys end
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
span p/*0:01*/ [] = [],[];
span p/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = aux/*0*/ xs/*0:1*/ with aux xs/*0:1*/ = split_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with add x/*0:01*/ (pre/*0:101*/,post/*0:11*/) = x/*0:01*/:pre/*0:101*/,post/*0:11*/ {
  rule #0: add x (pre,post) = x:pre,post
  state 0: #0
	<var> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
}; split_pre 0 _/*0:1*/ = split_tails/*1:1*/; split_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = add/*1*/ x/*0:101*/ (split_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/) {
  rule #0: split_pre 0 _ = split_tails
  rule #1: split_pre n::int (x:xs) = add x (split_pre (n-1) xs)
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ split_tails/*0:1*/ = skip_ahead/*1*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ split_tails = skip_ahead 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux xs = split_pre len_pre xs with add x (pre,post) = x:pre,post; split_pre 0 _ = split_tails; split_pre n::int (x:xs) = add x (split_pre (n-1) xs) end when len_pre@_ split_tails = skip_ahead 0 xs end
  state 0: #0
	<var> state 1
  state 1: #0
}; skip_ahead n/*0:01*/ :: int [] = n/*0:01*/ ([],[]); skip_ahead n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = n/*0:01*/ (aux/*1*/ xs/*0:1*/) if n/*0:01*/==4096; skip_ahead n/*0:01*/ :: int xx@(x/*0:101*/:xs/*0:11*/) = n/*0:01*/ ([],xx/*0:1*/) if ~p/*1:01*/ x/*0:101*/; skip_ahead n/*0:01*/ :: int xx@(x/*0:101*/:xs/*0:11*/) = n/*0:01*/ (x/*0:101*/:takewhile p/*2:01*/ xs/*1:11*/&,dropwhile p/*2:01*/ xs/*1:11*/&) if thunkp xs/*0:11*/; skip_ahead n/*0:01*/ :: int xx@(x/*0:101*/:xs/*0:11*/) = skip_ahead/*1*/ (n/*0:01*/+1) xs/*0:11*/; skip_ahead n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (takewhile p/*1:01*/ xs/*0:1*/,dropwhile p/*1:01*/ xs/*0:1*/) {
  rule #0: skip_ahead n::int [] = n ([],[])
  rule #1: skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096
  rule #2: skip_ahead n::int xx@(x:xs) = n ([],xx) if ~p x
  rule #3: skip_ahead n::int xx@(x:xs) = n (x:takewhile p xs&,dropwhile p xs&) if thunkp xs
  rule #4: skip_ahead n::int xx@(x:xs) = skip_ahead (n+1) xs
  rule #5: skip_ahead n::int xs = n (takewhile p xs,dropwhile p xs)
  state 0: #0 #1 #2 #3 #4 #5
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4 #5
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #5
  state 3: #1 #2 #3 #4 #5
	<var> state 4
	<app> state 6
  state 4: #5
	<var> state 5
  state 5: #5
  state 6: #1 #2 #3 #4 #5
	<var> state 7
	: state 10
  state 7: #5
	<var> state 8
  state 8: #5
	<var> state 9
  state 9: #5
  state 10: #1 #2 #3 #4 #5
	<var> state 11
  state 11: #1 #2 #3 #4 #5
	<var> state 12
  state 12: #1 #2 #3 #4 #5
  state 13: #0 #5
} end;
split m/*0:01*/ :: int [] = [],[];
split m/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = aux/*0*/ m/*0:01*/ xs/*0:1*/ with aux m/*0:01*/ :: int xs/*0:1*/ = split_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with split_pre 0 _/*0:1*/ = split_tails/*1:1*/; split_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = add/*3*/ x/*0:101*/ (split_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/) {
  rule #0: split_pre 0 _ = split_tails
  rule #1: split_pre n::int (x:xs) = add x (split_pre (n-1) xs)
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ split_tails/*0:1*/ = skip_ahead/*1*/ m/*0:01*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ split_tails = skip_ahead m 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux m::int xs = split_pre len_pre xs with split_pre 0 _ = split_tails; split_pre n::int (x:xs) = add x (split_pre (n-1) xs) end when len_pre@_ split_tails = skip_ahead m 0 xs end
  state 0: #0
	<var>::int state 1
  state 1: #0
	<var> state 2
  state 2: #0
}; skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int [] = n/*0:01*/ ([],[]); skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = n/*0:01*/ (aux/*1*/ m/*0:001*/ xs/*0:1*/) if n/*0:01*/==4096; skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ ([],xs/*0:1*/) if m/*0:001*/<=0; skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ (x/*0:101*/:take (m/*1:001*/-1) xs/*1:11*/&,drop (m/*1:001*/-1) xs/*1:11*/&) if thunkp xs/*0:11*/; skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = skip_ahead/*1*/ (m/*0:001*/-1) (n/*0:01*/+1) xs/*0:11*/; skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (take m/*0:001*/ xs/*0:1*/,drop m/*0:001*/ xs/*0:1*/) {
  rule #0: skip_ahead m::int n::int [] = n ([],[])
  rule #1: skip_ahead m::int n::int xs@(_:_) = n (aux m xs) if n==4096
  rule #2: skip_ahead m::int n::int xs = n ([],xs) if m<=0
  rule #3: skip_ahead m::int n::int (x:xs) = n (x:take (m-1) xs&,drop (m-1) xs&) if thunkp xs
  rule #4: skip_ahead m::int n::int (x:xs) = skip_ahead (m-1) (n+1) xs
  rule #5: skip_ahead m::int n::int xs = n (take m xs,drop m xs)
  state 0: #0 #1 #2 #3 #4 #5
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4 #5
	<var>::int state 2
  state 2: #0 #1 #2 #3 #4 #5
	<var> state 3
	<app> state 4
	[] state 14
  state 3: #2 #5
  state 4: #1 #2 #3 #4 #5
	<var> state 5
	<app> state 7
  state 5: #2 #5
	<var> state 6
  state 6: #2 #5
  state 7: #1 #2 #3 #4 #5
	<var> state 8
	: state 11
  state 8: #2 #5
	<var> state 9
  state 9: #2 #5
	<var> state 10
  state 10: #2 #5
  state 11: #1 #2 #3 #4 #5
	<var> state 12
  state 12: #1 #2 #3 #4 #5
	<var> state 13
  state 13: #1 #2 #3 #4 #5
  state 14: #0 #2 #5
}; add x/*0:01*/ (front/*0:101*/,back/*0:11*/) = x/*0:01*/:front/*0:101*/,back/*0:11*/ {
  rule #0: add x (front,back) = x:front,back
  state 0: #0
	<var> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	<app> state 3
  state 3: #0
	, state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
} end;
tail (x/*0:101*/:xs/*0:11*/) = xs/*0:11*/;
take m/*0:01*/ :: int [] = [];
takewhile p/*0:01*/ [] = [];
take m/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = aux/*0*/ m/*0:01*/ xs/*0:1*/ with aux 0 xs/*0:1*/ = []; aux m/*0:01*/ :: int xs/*0:1*/ = take_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with take_pre 0 _/*0:1*/ = front_tail/*1:1*/; take_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:take_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/ {
  rule #0: take_pre 0 _ = front_tail
  rule #1: take_pre n::int (x:xs) = x:take_pre (n-1) xs
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ front_tail/*0:1*/ = skip_ahead/*1*/ m/*0:01*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ front_tail = skip_ahead m 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux 0 xs = []
  rule #1: aux m::int xs = take_pre len_pre xs with take_pre 0 _ = front_tail; take_pre n::int (x:xs) = x:take_pre (n-1) xs end when len_pre@_ front_tail = skip_ahead m 0 xs end
  state 0: #0 #1
	<var>::int state 1
	0::int state 3
  state 1: #1
	<var> state 2
  state 2: #1
  state 3: #0 #1
	<var> state 4
  state 4: #0 #1
}; skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int [] = n/*0:01*/ []; skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = n/*0:01*/ (aux/*1*/ m/*0:001*/ xs/*0:1*/) if n/*0:01*/==4096; skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ [] if m/*0:001*/<=0; skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ (x/*0:101*/:aux/*2*/ (m/*1:001*/-1) xs/*1:11*/&) if thunkp xs/*0:11*/; skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = skip_ahead/*1*/ (m/*0:001*/-1) (n/*0:01*/+1) xs/*0:11*/; skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (take m/*0:001*/ xs/*0:1*/) {
  rule #0: skip_ahead m::int n::int [] = n []
  rule #1: skip_ahead m::int n::int xs@(_:_) = n (aux m xs) if n==4096
  rule #2: skip_ahead m::int n::int (x:xs) = n [] if m<=0
  rule #3: skip_ahead m::int n::int (x:xs) = n (x:aux (m-1) xs&) if thunkp xs
  rule #4: skip_ahead m::int n::int (x:xs) = skip_ahead (m-1) (n+1) xs
  rule #5: skip_ahead m::int n::int xs = n (take m xs)
  state 0: #0 #1 #2 #3 #4 #5
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4 #5
	<var>::int state 2
  state 2: #0 #1 #2 #3 #4 #5
	<var> state 3
	<app> state 4
	[] state 14
  state 3: #5
  state 4: #1 #2 #3 #4 #5
	<var> state 5
	<app> state 7
  state 5: #5
	<var> state 6
  state 6: #5
  state 7: #1 #2 #3 #4 #5
	<var> state 8
	: state 11
  state 8: #5
	<var> state 9
  state 9: #5
	<var> state 10
  state 10: #5
  state 11: #1 #2 #3 #4 #5
	<var> state 12
  state 12: #1 #2 #3 #4 #5
	<var> state 13
  state 13: #1 #2 #3 #4 #5
  state 14: #0 #5
} end;
takewhile p/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = aux/*0*/ xs/*0:1*/ with aux xs/*0:1*/ = take_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with take_pre 0 _/*0:1*/ = front_tail/*1:1*/; take_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:take_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/ {
  rule #0: take_pre 0 _ = front_tail
  rule #1: take_pre n::int (x:xs) = x:take_pre (n-1) xs
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ front_tail/*0:1*/ = skip_ahead/*1*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ front_tail = skip_ahead 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux xs = take_pre len_pre xs with take_pre 0 _ = front_tail; take_pre n::int (x:xs) = x:take_pre (n-1) xs end when len_pre@_ front_tail = skip_ahead 0 xs end
  state 0: #0
	<var> state 1
  state 1: #0
}; skip_ahead n/*0:01*/ :: int [] = n/*0:01*/ []; skip_ahead n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = n/*0:01*/ (aux/*1*/ xs/*0:1*/) if n/*0:01*/==4096; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ [] if ~p/*1:01*/ x/*0:101*/; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ (x/*0:101*/:aux/*2*/ xs/*1:11*/&) if thunkp xs/*0:11*/; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = skip_ahead/*1*/ (n/*0:01*/+1) xs/*0:11*/; skip_ahead n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (takewhile p/*1:01*/ xs/*0:1*/) {
  rule #0: skip_ahead n::int [] = n []
  rule #1: skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096
  rule #2: skip_ahead n::int (x:xs) = n [] if ~p x
  rule #3: skip_ahead n::int (x:xs) = n (x:aux xs&) if thunkp xs
  rule #4: skip_ahead n::int (x:xs) = skip_ahead (n+1) xs
  rule #5: skip_ahead n::int xs = n (takewhile p xs)
  state 0: #0 #1 #2 #3 #4 #5
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4 #5
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #5
  state 3: #1 #2 #3 #4 #5
	<var> state 4
	<app> state 6
  state 4: #5
	<var> state 5
  state 5: #5
  state 6: #1 #2 #3 #4 #5
	<var> state 7
	: state 10
  state 7: #5
	<var> state 8
  state 8: #5
	<var> state 9
  state 9: #5
  state 10: #1 #2 #3 #4 #5
	<var> state 11
  state 11: #1 #2 #3 #4 #5
	<var> state 12
  state 12: #1 #2 #3 #4 #5
  state 13: #0 #5
} end;
cat [] = [];
cat (xs/*0:101*/ :: list:yss/*0:11*/) = aux/*0*/ xs/*0:101*/ with aux xs/*0:1*/ = cat_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with cat_pre 0 _/*0:1*/ = catted_tail/*1:1*/; cat_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:cat_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/ {
  rule #0: cat_pre 0 _ = catted_tail
  rule #1: cat_pre n::int (x:xs) = x:cat_pre (n-1) xs
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ catted_tail/*0:1*/ = skip_ahead/*1*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ catted_tail = skip_ahead 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux xs = cat_pre len_pre xs with cat_pre 0 _ = catted_tail; cat_pre n::int (x:xs) = x:cat_pre (n-1) xs end when len_pre@_ catted_tail = skip_ahead 0 xs end
  state 0: #0
	<var> state 1
  state 1: #0
}; skip_ahead n/*0:01*/ :: int [] = n/*0:01*/ (cat yss/*1:11*/); skip_ahead n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = n/*0:01*/ (aux/*1*/ xs/*0:1*/) if n/*0:01*/==4096; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ (x/*0:101*/:aux/*2*/ xs/*1:11*/&) if thunkp xs/*0:11*/; skip_ahead n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = skip_ahead/*1*/ (n/*0:01*/+1) xs/*0:11*/; skip_ahead n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (xs/*0:1*/+cat yss/*1:11*/) {
  rule #0: skip_ahead n::int [] = n (cat yss)
  rule #1: skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096
  rule #2: skip_ahead n::int (x:xs) = n (x:aux xs&) if thunkp xs
  rule #3: skip_ahead n::int (x:xs) = skip_ahead (n+1) xs
  rule #4: skip_ahead n::int xs = n (xs+cat yss)
  state 0: #0 #1 #2 #3 #4
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #4
  state 3: #1 #2 #3 #4
	<var> state 4
	<app> state 6
  state 4: #4
	<var> state 5
  state 5: #4
  state 6: #1 #2 #3 #4
	<var> state 7
	: state 10
  state 7: #4
	<var> state 8
  state 8: #4
	<var> state 9
  state 9: #4
  state 10: #1 #2 #3 #4
	<var> state 11
  state 11: #1 #2 #3 #4
	<var> state 12
  state 12: #1 #2 #3 #4
  state 13: #0 #4
} end;
catmap_onto f/*0:001*/ base/*0:01*/ [] = base/*0:01*/;
catmap f/*0:01*/ [] = [];
catmap_onto f/*0:001*/ base/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = aux/*0*/ xs/*0:1*/ with aux xs/*0:1*/ = map_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with map_pre 0 _/*0:1*/ = mapped_tail/*1:1*/; map_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = lazy_cat/*3*/ (f/*3:001*/ x/*0:101*/) (map_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/) {
  rule #0: map_pre 0 _ = mapped_tail
  rule #1: map_pre n::int (x:xs) = lazy_cat (f x) (map_pre (n-1) xs)
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ mapped_tail/*0:1*/ = skip_map/*1*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ mapped_tail = skip_map 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux xs = map_pre len_pre xs with map_pre 0 _ = mapped_tail; map_pre n::int (x:xs) = lazy_cat (f x) (map_pre (n-1) xs) end when len_pre@_ mapped_tail = skip_map 0 xs end
  state 0: #0
	<var> state 1
  state 1: #0
}; lazy_cat xs/*0:01*/ yss/*0:1*/ = cat_pre/*0*/ len_pre/*0:0*/ xs/*1:01*/ with cat_pre 0 _/*0:1*/ = catted_tail/*1:1*/; cat_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:cat_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/ {
  rule #0: cat_pre 0 _ = catted_tail
  rule #1: cat_pre n::int (x:xs) = x:cat_pre (n-1) xs
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ catted_tail/*0:1*/ = skip_cat/*1*/ yss/*0:1*/ 0 xs/*0:01*/ {
  rule #0: len_pre@_ catted_tail = skip_cat yss 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: lazy_cat xs yss = cat_pre len_pre xs with cat_pre 0 _ = catted_tail; cat_pre n::int (x:xs) = x:cat_pre (n-1) xs end when len_pre@_ catted_tail = skip_cat yss 0 xs end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}; skip_map n/*0:01*/ :: int [] = n/*0:01*/ base/*1:01*/; skip_map n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = n/*0:01*/ (aux/*1*/ xs/*0:1*/) if n/*0:01*/==4096; skip_map n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ (lazy_cat/*1*/ (f/*1:001*/ x/*0:101*/) (aux/*2*/ xs/*1:11*/&)) if thunkp xs/*0:11*/; skip_map n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = skip_map/*1*/ (n/*0:01*/+1) xs/*0:11*/; skip_map n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (catmap_onto f/*1:001*/ base/*1:01*/ xs/*0:1*/) {
  rule #0: skip_map n::int [] = n base
  rule #1: skip_map n::int xs@(_:_) = n (aux xs) if n==4096
  rule #2: skip_map n::int (x:xs) = n (lazy_cat (f x) (aux xs&)) if thunkp xs
  rule #3: skip_map n::int (x:xs) = skip_map (n+1) xs
  rule #4: skip_map n::int xs = n (catmap_onto f base xs)
  state 0: #0 #1 #2 #3 #4
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #4
  state 3: #1 #2 #3 #4
	<var> state 4
	<app> state 6
  state 4: #4
	<var> state 5
  state 5: #4
  state 6: #1 #2 #3 #4
	<var> state 7
	: state 10
  state 7: #4
	<var> state 8
  state 8: #4
	<var> state 9
  state 9: #4
  state 10: #1 #2 #3 #4
	<var> state 11
  state 11: #1 #2 #3 #4
	<var> state 12
  state 12: #1 #2 #3 #4
  state 13: #0 #4
}; skip_cat yss/*0:001*/ n/*0:01*/ :: int [] = n/*0:01*/ yss/*0:001*/; skip_cat yss/*0:001*/ n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = n/*0:01*/ (aux/*1*/ xs/*0:1*/) if n/*0:01*/==4096; skip_cat yss/*0:001*/ n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ (x/*0:101*/:lazy_cat/*2*/ xs/*1:11*/ yss/*1:001*/&) if thunkp xs/*0:11*/; skip_cat yss/*0:001*/ n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = skip_cat/*1*/ yss/*0:001*/ (n/*0:01*/+1) xs/*0:11*/; skip_cat yss/*0:001*/ n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (xs/*0:1*/+yss/*0:001*/) {
  rule #0: skip_cat yss n::int [] = n yss
  rule #1: skip_cat yss n::int xs@(_:_) = n (aux xs) if n==4096
  rule #2: skip_cat yss n::int (x:xs) = n (x:lazy_cat xs yss&) if thunkp xs
  rule #3: skip_cat yss n::int (x:xs) = skip_cat yss (n+1) xs
  rule #4: skip_cat yss n::int xs = n (xs+yss)
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var>::int state 2
  state 2: #0 #1 #2 #3 #4
	<var> state 3
	<app> state 4
	[] state 14
  state 3: #4
  state 4: #1 #2 #3 #4
	<var> state 5
	<app> state 7
  state 5: #4
	<var> state 6
  state 6: #4
  state 7: #1 #2 #3 #4
	<var> state 8
	: state 11
  state 8: #4
	<var> state 9
  state 9: #4
	<var> state 10
  state 10: #4
  state 11: #1 #2 #3 #4
	<var> state 12
  state 12: #1 #2 #3 #4
	<var> state 13
  state 13: #1 #2 #3 #4
  state 14: #0 #4
} end;
catmap f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = aux/*0*/ xs/*0:1*/ with aux xs/*0:1*/ = map_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with map_pre 0 _/*0:1*/ = mapped_tail/*1:1*/; map_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = lazy_cat/*3*/ (f/*3:01*/ x/*0:101*/) (map_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/) {
  rule #0: map_pre 0 _ = mapped_tail
  rule #1: map_pre n::int (x:xs) = lazy_cat (f x) (map_pre (n-1) xs)
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ mapped_tail/*0:1*/ = skip_map/*1*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ mapped_tail = skip_map 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux xs = map_pre len_pre xs with map_pre 0 _ = mapped_tail; map_pre n::int (x:xs) = lazy_cat (f x) (map_pre (n-1) xs) end when len_pre@_ mapped_tail = skip_map 0 xs end
  state 0: #0
	<var> state 1
  state 1: #0
}; lazy_cat xs/*0:01*/ yss/*0:1*/ = cat_pre/*0*/ len_pre/*0:0*/ xs/*1:01*/ with cat_pre 0 _/*0:1*/ = catted_tail/*1:1*/; cat_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:cat_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/ {
  rule #0: cat_pre 0 _ = catted_tail
  rule #1: cat_pre n::int (x:xs) = x:cat_pre (n-1) xs
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ catted_tail/*0:1*/ = skip_cat/*1*/ yss/*0:1*/ 0 xs/*0:01*/ {
  rule #0: len_pre@_ catted_tail = skip_cat yss 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: lazy_cat xs yss = cat_pre len_pre xs with cat_pre 0 _ = catted_tail; cat_pre n::int (x:xs) = x:cat_pre (n-1) xs end when len_pre@_ catted_tail = skip_cat yss 0 xs end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}; skip_map n/*0:01*/ :: int [] = n/*0:01*/ []; skip_map n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = n/*0:01*/ (aux/*1*/ xs/*0:1*/) if n/*0:01*/==4096; skip_map n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ (lazy_cat/*1*/ (f/*1:01*/ x/*0:101*/) (aux/*2*/ xs/*1:11*/&)) if thunkp xs/*0:11*/; skip_map n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = skip_map/*1*/ (n/*0:01*/+1) xs/*0:11*/; skip_map n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (catmap f/*1:01*/ xs/*0:1*/) {
  rule #0: skip_map n::int [] = n []
  rule #1: skip_map n::int xs@(_:_) = n (aux xs) if n==4096
  rule #2: skip_map n::int (x:xs) = n (lazy_cat (f x) (aux xs&)) if thunkp xs
  rule #3: skip_map n::int (x:xs) = skip_map (n+1) xs
  rule #4: skip_map n::int xs = n (catmap f xs)
  state 0: #0 #1 #2 #3 #4
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #4
  state 3: #1 #2 #3 #4
	<var> state 4
	<app> state 6
  state 4: #4
	<var> state 5
  state 5: #4
  state 6: #1 #2 #3 #4
	<var> state 7
	: state 10
  state 7: #4
	<var> state 8
  state 8: #4
	<var> state 9
  state 9: #4
  state 10: #1 #2 #3 #4
	<var> state 11
  state 11: #1 #2 #3 #4
	<var> state 12
  state 12: #1 #2 #3 #4
  state 13: #0 #4
}; skip_cat yss/*0:001*/ n/*0:01*/ :: int [] = n/*0:01*/ yss/*0:001*/; skip_cat yss/*0:001*/ n/*0:01*/ :: int xs@(_/*0:101*/:_/*0:11*/) = n/*0:01*/ (aux/*1*/ xs/*0:1*/) if n/*0:01*/==4096; skip_cat yss/*0:001*/ n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ (x/*0:101*/:lazy_cat/*2*/ xs/*1:11*/ yss/*1:001*/&) if thunkp xs/*0:11*/; skip_cat yss/*0:001*/ n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = skip_cat/*1*/ yss/*0:001*/ (n/*0:01*/+1) xs/*0:11*/; skip_cat yss/*0:001*/ n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (xs/*0:1*/+yss/*0:001*/) {
  rule #0: skip_cat yss n::int [] = n yss
  rule #1: skip_cat yss n::int xs@(_:_) = n (aux xs) if n==4096
  rule #2: skip_cat yss n::int (x:xs) = n (x:lazy_cat xs yss&) if thunkp xs
  rule #3: skip_cat yss n::int (x:xs) = skip_cat yss (n+1) xs
  rule #4: skip_cat yss n::int xs = n (xs+yss)
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var>::int state 2
  state 2: #0 #1 #2 #3 #4
	<var> state 3
	<app> state 4
	[] state 14
  state 3: #4
  state 4: #1 #2 #3 #4
	<var> state 5
	<app> state 7
  state 5: #4
	<var> state 6
  state 6: #4
  state 7: #1 #2 #3 #4
	<var> state 8
	: state 11
  state 8: #4
	<var> state 9
  state 9: #4
	<var> state 10
  state 10: #4
  state 11: #1 #2 #3 #4
	<var> state 12
  state 12: #1 #2 #3 #4
	<var> state 13
  state 13: #1 #2 #3 #4
  state 14: #0 #4
} end;
listmap f/*0:01*/ [] = [];
listmap f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = map f/*0:01*/ xs/*0:1*/;
index [] _/*0:1*/ = -1;
index (x/*0:0101*/:xs/*0:011*/) y/*0:1*/ = search/*0*/ 0 (x/*0:0101*/:xs/*0:011*/) with search _/*0:01*/ [] = -1; search n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ if x/*0:101*/==?y/*1:1*/; search n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = search/*1*/ (n/*0:01*/+1) xs/*0:11*/; search _/*0:01*/ xs/*0:1*/ = index xs/*0:1*/ y/*1:1*/ {
  rule #0: search _ [] = -1
  rule #1: search n::int (x:xs) = n if x==?y
  rule #2: search n::int (x:xs) = search (n+1) xs
  rule #3: search _ xs = index xs y
  state 0: #0 #1 #2 #3
	<var> state 1
	<var>::int state 4
  state 1: #0 #3
	<var> state 2
	[] state 3
  state 2: #3
  state 3: #0 #3
  state 4: #0 #1 #2 #3
	<var> state 5
	<app> state 6
	[] state 16
  state 5: #3
  state 6: #1 #2 #3
	<var> state 7
	<app> state 9
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #1 #2 #3
	<var> state 10
	: state 13
  state 10: #3
	<var> state 11
  state 11: #3
	<var> state 12
  state 12: #3
  state 13: #1 #2 #3
	<var> state 14
  state 14: #1 #2 #3
	<var> state 15
  state 15: #1 #2 #3
  state 16: #0 #3
} end;
member [] y/*0:1*/ = 0;
member (x/*0:0101*/:xs/*0:011*/) y/*0:1*/ = 1 if y/*0:1*/==?x/*0:0101*/;
member (x/*0:0101*/:xs/*0:011*/) y/*0:1*/ = member xs/*0:011*/ y/*0:1*/;
n1/*0:0101*/:n2/*0:011*/..m/*0:1*/ = if nanp n1/*2:0101*/||nanp m/*2:1*/||double m/*2:1*/===-s/*0:01*/ then [] else if double m/*2:1*/===s/*0:01*/ then iterate (flip (+) k/*1:*/) n1/*2:0101*/ else iterwhile (p/*0:1*/ (m/*2:1*/+0.5*k/*1:*/)) (flip (+) k/*1:*/) n1/*2:0101*/ when s/*0:01*/,p/*0:1*/ = if k/*0:*/>0 then inf,(>=) else -inf,(<=) {
  rule #0: s,p = if k>0 then inf,(>=) else -inf,(<=)
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end if realp k/*0:*/&&k/*0:*/~=0&&~infp n1/*1:0101*/&&~infp n2/*1:011*/ when k/*0:*/ = n2/*0:011*/-n1/*0:0101*/ {
  rule #0: k = n2-n1
  state 0: #0
	<var> state 1
  state 1: #0
} end;
n/*0:01*/..m/*0:1*/ = if nanp n/*0:01*/||nanp m/*0:1*/||double m/*0:1*/===-inf then [] else if double m/*0:1*/===inf then iterate (flip (+) 1) n/*0:01*/ else iterwhile ((>=) m/*0:1*/) (flip (+) 1) n/*0:01*/ if ~listp n/*0:01*/&&~infp n/*0:01*/;
iterate f/*0:01*/ x/*0:1*/ = x/*0:1*/:iterate f/*1:01*/ (f/*1:01*/ x/*1:1*/)&;
repeat x/*0:1*/ = x/*0:1*/:repeat x/*1:1*/&;
cycle ys@(x/*0:101*/:xs/*0:11*/) = x/*0:101*/:(xs/*1:11*/+cycle ys/*1:1*/)&;
iterwhile p/*0:001*/ f/*0:01*/ x/*0:1*/ = accum/*0*/ [] p/*0:001*/ f/*0:01*/ x/*0:1*/ with accum xs/*0:0001*/ p/*0:001*/ f/*0:01*/ x/*0:1*/ = accum/*1*/ (x/*0:1*/:xs/*0:0001*/) p/*0:001*/ f/*0:01*/ (f/*0:01*/ x/*0:1*/) if p/*0:001*/ x/*0:1*/; accum xs/*0:0001*/ p/*0:001*/ f/*0:01*/ x/*0:1*/ = __std__::reverse_onto [] xs/*0:0001*/ {
  rule #0: accum xs p f x = accum (x:xs) p f (f x) if p x
  rule #1: accum xs p f x = __std__::reverse_onto [] xs
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
	<var> state 3
  state 3: #0 #1
	<var> state 4
  state 4: #0 #1
} end;
iteraten n/*0:001*/ :: int f/*0:01*/ x/*0:1*/ = [] if n/*0:001*/<=0;
iteraten n/*0:001*/ :: int f/*0:01*/ x/*0:1*/ = accum/*0*/ [] n/*0:001*/ f/*0:01*/ x/*0:1*/ with accum xs/*0:0001*/ n/*0:001*/ :: int f/*0:01*/ x/*0:1*/ = __std__::reverse_onto [] (x/*0:1*/:xs/*0:0001*/) if n/*0:001*/==1; accum xs/*0:0001*/ n/*0:001*/ :: int f/*0:01*/ x/*0:1*/ = accum/*1*/ (x/*0:1*/:xs/*0:0001*/) (n/*0:001*/-1) f/*0:01*/ (f/*0:01*/ x/*0:1*/) {
  rule #0: accum xs n::int f x = __std__::reverse_onto [] (x:xs) if n==1
  rule #1: accum xs n::int f x = accum (x:xs) (n-1) f (f x)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::int state 2
  state 2: #0 #1
	<var> state 3
  state 3: #0 #1
	<var> state 4
  state 4: #0 #1
} end;
repeatn n/*0:01*/ :: int x/*0:1*/ = accum/*0*/ [] n/*0:01*/ x/*0:1*/ with accum xs/*0:001*/ n/*0:01*/ :: int x/*0:1*/ = xs/*0:001*/ if n/*0:01*/<=0; accum xs/*0:001*/ n/*0:01*/ :: int x/*0:1*/ = accum/*1*/ (x/*0:1*/:xs/*0:001*/) (n/*0:01*/-1) x/*0:1*/ {
  rule #0: accum xs n::int x = xs if n<=0
  rule #1: accum xs n::int x = accum (x:xs) (n-1) x
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::int state 2
  state 2: #0 #1
	<var> state 3
  state 3: #0 #1
} end;
cyclen n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = [] if n/*0:01*/<=0;
cyclen n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = accum/*0*/ [] n/*2:01*/ with accum ys/*0:01*/ n/*0:1*/ :: int = cat ys/*0:01*/+take n/*0:1*/ xs/*2:*/ if n/*0:1*/<=m/*1:*/; accum ys/*0:01*/ n/*0:1*/ :: int = accum/*1*/ (xs/*2:*/:ys/*0:01*/) (n/*0:1*/-m/*1:*/) {
  rule #0: accum ys n::int = cat ys+take n xs if n<=m
  rule #1: accum ys n::int = accum (xs:ys) (n-m)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::int state 2
  state 2: #0 #1
} end when xs/*0:*/ = x/*0:101*/:xs/*0:11*/; m/*0:*/ :: int = #xs/*0:*/ {
  rule #0: m::int = #xs
  state 0: #0
	<var>::int state 1
  state 1: #0
} {
  rule #0: xs = x:xs
  state 0: #0
	<var> state 1
  state 1: #0
} end if rlistp xs/*0:11*/;
zip [] _/*0:1*/ = [];
zip _/*0:01*/ [] = [];
zipwith f/*0:001*/ [] _/*0:1*/ = [];
zipwith f/*0:001*/ _/*0:01*/ [] = [];
zip3 [] _/*0:01*/ _/*0:1*/ = [];
zip3 _/*0:001*/ [] _/*0:1*/ = [];
zip3 _/*0:001*/ _/*0:01*/ [] = [];
zipwith3 f/*0:0001*/ [] _/*0:01*/ _/*0:1*/ = [];
zipwith3 f/*0:0001*/ _/*0:001*/ [] _/*0:1*/ = [];
zipwith3 f/*0:0001*/ _/*0:001*/ _/*0:01*/ [] = [];
zip_onto base/*0:001*/ [] _/*0:1*/ = base/*0:001*/;
zip_onto base/*0:001*/ _/*0:01*/ [] = base/*0:001*/;
zipwith_onto f/*0:0001*/ base/*0:001*/ [] _/*0:1*/ = base/*0:001*/;
zipwith_onto f/*0:0001*/ base/*0:001*/ _/*0:01*/ [] = base/*0:001*/;
zip3_onto base/*0:0001*/ [] _/*0:01*/ _/*0:1*/ = base/*0:0001*/;
zip3_onto base/*0:0001*/ _/*0:001*/ [] _/*0:1*/ = base/*0:0001*/;
zip3_onto base/*0:0001*/ _/*0:001*/ _/*0:01*/ [] = base/*0:0001*/;
zipwith3_onto f/*0:00001*/ base/*0:0001*/ [] _/*0:01*/ _/*0:1*/ = base/*0:0001*/;
zipwith3_onto f/*0:00001*/ base/*0:0001*/ _/*0:001*/ [] _/*0:1*/ = base/*0:0001*/;
zipwith3_onto f/*0:00001*/ base/*0:0001*/ _/*0:001*/ _/*0:01*/ [] = base/*0:0001*/;
__std__::zip f/*0:00001*/ base/*0:0001*/ improper/*0:001*/ xs@(_/*0:0101*/:_/*0:011*/) ys@(_/*0:101*/:_/*0:11*/) = aux/*0*/ xs/*0:01*/ ys/*0:1*/ with aux xs/*0:01*/ ys/*0:1*/ = zip_pre/*0*/ len_pre/*0:0*/ xs/*1:01*/ ys/*1:1*/ with zip_pre 0 _/*0:01*/ _/*0:1*/ = zipped_tail/*1:1*/; zip_pre n/*0:001*/ :: int (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = f/*3:00001*/ x/*0:0101*/ y/*0:101*/:zip_pre/*1*/ (n/*0:001*/-1) xs/*0:011*/ ys/*0:11*/ {
  rule #0: zip_pre 0 _ _ = zipped_tail
  rule #1: zip_pre n::int (x:xs) (y:ys) = f x y:zip_pre (n-1) xs ys
  state 0: #0 #1
	<var>::int state 1
	0::int state 12
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
	<app> state 7
  state 7: #1
	<app> state 8
  state 8: #1
	: state 9
  state 9: #1
	<var> state 10
  state 10: #1
	<var> state 11
  state 11: #1
  state 12: #0 #1
	<var> state 13
	<app> state 15
  state 13: #0
	<var> state 14
  state 14: #0
  state 15: #0 #1
	<var> state 16
	<app> state 19
  state 16: #0
	<var> state 17
  state 17: #0
	<var> state 18
  state 18: #0
  state 19: #0 #1
	<var> state 20
	: state 24
  state 20: #0
	<var> state 21
  state 21: #0
	<var> state 22
  state 22: #0
	<var> state 23
  state 23: #0
  state 24: #0 #1
	<var> state 25
  state 25: #0 #1
	<var> state 26
  state 26: #0 #1
	<var> state 27
	<app> state 28
  state 27: #0
  state 28: #0 #1
	<var> state 29
	<app> state 31
  state 29: #0
	<var> state 30
  state 30: #0
  state 31: #0 #1
	<var> state 32
	: state 35
  state 32: #0
	<var> state 33
  state 33: #0
	<var> state 34
  state 34: #0
  state 35: #0 #1
	<var> state 36
  state 36: #0 #1
	<var> state 37
  state 37: #0 #1
} end when len_pre@_/*0:0*/ zipped_tail/*0:1*/ = skip_ahead/*1*/ 0 xs/*0:01*/ ys/*0:1*/ {
  rule #0: len_pre@_ zipped_tail = skip_ahead 0 xs ys
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux xs ys = zip_pre len_pre xs ys with zip_pre 0 _ _ = zipped_tail; zip_pre n::int (x:xs) (y:ys) = f x y:zip_pre (n-1) xs ys end when len_pre@_ zipped_tail = skip_ahead 0 xs ys end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}; skip_ahead n/*0:001*/ :: int [] _/*0:1*/ = n/*0:001*/ base/*1:0001*/; skip_ahead n/*0:001*/ :: int _/*0:01*/ [] = n/*0:001*/ base/*1:0001*/; skip_ahead n/*0:001*/ :: int xs@(_/*0:0101*/:_/*0:011*/) ys@(_/*0:101*/:_/*0:11*/) = n/*0:001*/ (aux/*1*/ xs/*0:01*/ ys/*0:1*/) if n/*0:001*/==4096; skip_ahead n/*0:001*/ :: int (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = n/*0:001*/ (f/*1:00001*/ x/*0:0101*/ y/*0:101*/:aux/*2*/ xs/*1:011*/ ys/*1:11*/&) if thunkp xs/*0:011*/||thunkp ys/*0:11*/; skip_ahead n/*0:001*/ :: int (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = skip_ahead/*1*/ (n/*0:001*/+1) xs/*0:011*/ ys/*0:11*/; skip_ahead n/*0:001*/ :: int xs/*0:01*/ ys/*0:1*/ = n/*0:001*/ (improper/*1:001*/ xs/*0:01*/ ys/*0:1*/) {
  rule #0: skip_ahead n::int [] _ = n base
  rule #1: skip_ahead n::int _ [] = n base
  rule #2: skip_ahead n::int xs@(_:_) ys@(_:_) = n (aux xs ys) if n==4096
  rule #3: skip_ahead n::int (x:xs) (y:ys) = n (f x y:aux xs ys&) if thunkp xs||thunkp ys
  rule #4: skip_ahead n::int (x:xs) (y:ys) = skip_ahead (n+1) xs ys
  rule #5: skip_ahead n::int xs ys = n (improper xs ys)
  state 0: #0 #1 #2 #3 #4 #5
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4 #5
	<var> state 2
	<app> state 5
	[] state 31
  state 2: #1 #5
	<var> state 3
	[] state 4
  state 3: #5
  state 4: #1 #5
  state 5: #1 #2 #3 #4 #5
	<var> state 6
	<app> state 10
  state 6: #1 #5
	<var> state 7
  state 7: #1 #5
	<var> state 8
	[] state 9
  state 8: #5
  state 9: #1 #5
  state 10: #1 #2 #3 #4 #5
	<var> state 11
	: state 16
  state 11: #1 #5
	<var> state 12
  state 12: #1 #5
	<var> state 13
  state 13: #1 #5
	<var> state 14
	[] state 15
  state 14: #5
  state 15: #1 #5
  state 16: #1 #2 #3 #4 #5
	<var> state 17
  state 17: #1 #2 #3 #4 #5
	<var> state 18
  state 18: #1 #2 #3 #4 #5
	<var> state 19
	<app> state 20
	[] state 30
  state 19: #5
  state 20: #2 #3 #4 #5
	<var> state 21
	<app> state 23
  state 21: #5
	<var> state 22
  state 22: #5
  state 23: #2 #3 #4 #5
	<var> state 24
	: state 27
  state 24: #5
	<var> state 25
  state 25: #5
	<var> state 26
  state 26: #5
  state 27: #2 #3 #4 #5
	<var> state 28
  state 28: #2 #3 #4 #5
	<var> state 29
  state 29: #2 #3 #4 #5
  state 30: #1 #5
  state 31: #0 #1 #5
	<var> state 32
	[] state 33
  state 32: #0 #5
  state 33: #0 #1 #5
} end;
__std__::zip3 f/*0:000001*/ base/*0:00001*/ improper/*0:0001*/ xs@(_/*0:00101*/:_/*0:0011*/) ys@(_/*0:0101*/:_/*0:011*/) zs@(_/*0:101*/:_/*0:11*/) = aux/*0*/ xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ with aux xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ = zip_pre/*0*/ len_pre/*0:0*/ xs/*1:001*/ ys/*1:01*/ zs/*1:1*/ with zip_pre 0 _/*0:001*/ _/*0:01*/ _/*0:1*/ = zipped_tail/*1:1*/; zip_pre n/*0:0001*/ :: int (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = f/*3:000001*/ x/*0:00101*/ y/*0:0101*/ z/*0:101*/:zip_pre/*1*/ (n/*0:0001*/-1) xs/*0:0011*/ ys/*0:011*/ zs/*0:11*/ {
  rule #0: zip_pre 0 _ _ _ = zipped_tail
  rule #1: zip_pre n::int (x:xs) (y:ys) (z:zs) = f x y z:zip_pre (n-1) xs ys zs
  state 0: #0 #1
	<var>::int state 1
	0::int state 17
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
	<app> state 7
  state 7: #1
	<app> state 8
  state 8: #1
	: state 9
  state 9: #1
	<var> state 10
  state 10: #1
	<var> state 11
  state 11: #1
	<app> state 12
  state 12: #1
	<app> state 13
  state 13: #1
	: state 14
  state 14: #1
	<var> state 15
  state 15: #1
	<var> state 16
  state 16: #1
  state 17: #0 #1
	<var> state 18
	<app> state 21
  state 18: #0
	<var> state 19
  state 19: #0
	<var> state 20
  state 20: #0
  state 21: #0 #1
	<var> state 22
	<app> state 26
  state 22: #0
	<var> state 23
  state 23: #0
	<var> state 24
  state 24: #0
	<var> state 25
  state 25: #0
  state 26: #0 #1
	<var> state 27
	: state 32
  state 27: #0
	<var> state 28
  state 28: #0
	<var> state 29
  state 29: #0
	<var> state 30
  state 30: #0
	<var> state 31
  state 31: #0
  state 32: #0 #1
	<var> state 33
  state 33: #0 #1
	<var> state 34
  state 34: #0 #1
	<var> state 35
	<app> state 37
  state 35: #0
	<var> state 36
  state 36: #0
  state 37: #0 #1
	<var> state 38
	<app> state 41
  state 38: #0
	<var> state 39
  state 39: #0
	<var> state 40
  state 40: #0
  state 41: #0 #1
	<var> state 42
	: state 46
  state 42: #0
	<var> state 43
  state 43: #0
	<var> state 44
  state 44: #0
	<var> state 45
  state 45: #0
  state 46: #0 #1
	<var> state 47
  state 47: #0 #1
	<var> state 48
  state 48: #0 #1
	<var> state 49
	<app> state 50
  state 49: #0
  state 50: #0 #1
	<var> state 51
	<app> state 53
  state 51: #0
	<var> state 52
  state 52: #0
  state 53: #0 #1
	<var> state 54
	: state 57
  state 54: #0
	<var> state 55
  state 55: #0
	<var> state 56
  state 56: #0
  state 57: #0 #1
	<var> state 58
  state 58: #0 #1
	<var> state 59
  state 59: #0 #1
} end when len_pre@_/*0:0*/ zipped_tail/*0:1*/ = skip_ahead/*1*/ 0 xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ {
  rule #0: len_pre@_ zipped_tail = skip_ahead 0 xs ys zs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: aux xs ys zs = zip_pre len_pre xs ys zs with zip_pre 0 _ _ _ = zipped_tail; zip_pre n::int (x:xs) (y:ys) (z:zs) = f x y z:zip_pre (n-1) xs ys zs end when len_pre@_ zipped_tail = skip_ahead 0 xs ys zs end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}; skip_ahead n/*0:0001*/ :: int [] _/*0:01*/ _/*0:1*/ = n/*0:0001*/ base/*1:00001*/; skip_ahead n/*0:0001*/ :: int _/*0:001*/ [] _/*0:1*/ = n/*0:0001*/ base/*1:00001*/; skip_ahead n/*0:0001*/ :: int _/*0:001*/ _/*0:01*/ [] = n/*0:0001*/ base/*1:00001*/; skip_ahead n/*0:0001*/ :: int xs@(_/*0:00101*/:_/*0:0011*/) ys@(_/*0:0101*/:_/*0:011*/) zs@(_/*0:101*/:_/*0:11*/) = n/*0:0001*/ (aux/*1*/ xs/*0:001*/ ys/*0:01*/ zs/*0:1*/) if n/*0:0001*/==4096; skip_ahead n/*0:0001*/ :: int (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = n/*0:0001*/ (f/*1:000001*/ x/*0:00101*/ y/*0:0101*/ z/*0:101*/:aux/*2*/ xs/*1:0011*/ ys/*1:011*/ zs/*1:11*/&) if thunkp xs/*0:0011*/||thunkp ys/*0:011*/||thunkp zs/*0:11*/; skip_ahead n/*0:0001*/ :: int (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = skip_ahead/*1*/ (n/*0:0001*/+1) xs/*0:0011*/ ys/*0:011*/ zs/*0:11*/; skip_ahead n/*0:0001*/ :: int xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ = n/*0:0001*/ (improper/*1:0001*/ xs/*0:001*/ ys/*0:01*/ zs/*0:1*/) {
  rule #0: skip_ahead n::int [] _ _ = n base
  rule #1: skip_ahead n::int _ [] _ = n base
  rule #2: skip_ahead n::int _ _ [] = n base
  rule #3: skip_ahead n::int xs@(_:_) ys@(_:_) zs@(_:_) = n (aux xs ys zs) if n==4096
  rule #4: skip_ahead n::int (x:xs) (y:ys) (z:zs) = n (f x y z:aux xs ys zs&) if thunkp xs||thunkp ys||thunkp zs
  rule #5: skip_ahead n::int (x:xs) (y:ys) (z:zs) = skip_ahead (n+1) xs ys zs
  rule #6: skip_ahead n::int xs ys zs = n (improper xs ys zs)
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4 #5 #6
	<var> state 2
	<app> state 9
	[] state 63
  state 2: #1 #2 #6
	<var> state 3
	[] state 6
  state 3: #2 #6
	<var> state 4
	[] state 5
  state 4: #6
  state 5: #2 #6
  state 6: #1 #2 #6
	<var> state 7
	[] state 8
  state 7: #1 #6
  state 8: #1 #2 #6
  state 9: #1 #2 #3 #4 #5 #6
	<var> state 10
	<app> state 18
  state 10: #1 #2 #6
	<var> state 11
  state 11: #1 #2 #6
	<var> state 12
	[] state 15
  state 12: #2 #6
	<var> state 13
	[] state 14
  state 13: #6
  state 14: #2 #6
  state 15: #1 #2 #6
	<var> state 16
	[] state 17
  state 16: #1 #6
  state 17: #1 #2 #6
  state 18: #1 #2 #3 #4 #5 #6
	<var> state 19
	: state 28
  state 19: #1 #2 #6
	<var> state 20
  state 20: #1 #2 #6
	<var> state 21
  state 21: #1 #2 #6
	<var> state 22
	[] state 25
  state 22: #2 #6
	<var> state 23
	[] state 24
  state 23: #6
  state 24: #2 #6
  state 25: #1 #2 #6
	<var> state 26
	[] state 27
  state 26: #1 #6
  state 27: #1 #2 #6
  state 28: #1 #2 #3 #4 #5 #6
	<var> state 29
  state 29: #1 #2 #3 #4 #5 #6
	<var> state 30
  state 30: #1 #2 #3 #4 #5 #6
	<var> state 31
	<app> state 34
	[] state 60
  state 31: #2 #6
	<var> state 32
	[] state 33
  state 32: #6
  state 33: #2 #6
  state 34: #2 #3 #4 #5 #6
	<var> state 35
	<app> state 39
  state 35: #2 #6
	<var> state 36
  state 36: #2 #6
	<var> state 37
	[] state 38
  state 37: #6
  state 38: #2 #6
  state 39: #2 #3 #4 #5 #6
	<var> state 40
	: state 45
  state 40: #2 #6
	<var> state 41
  state 41: #2 #6
	<var> state 42
  state 42: #2 #6
	<var> state 43
	[] state 44
  state 43: #6
  state 44: #2 #6
  state 45: #2 #3 #4 #5 #6
	<var> state 46
  state 46: #2 #3 #4 #5 #6
	<var> state 47
  state 47: #2 #3 #4 #5 #6
	<var> state 48
	<app> state 49
	[] state 59
  state 48: #6
  state 49: #3 #4 #5 #6
	<var> state 50
	<app> state 52
  state 50: #6
	<var> state 51
  state 51: #6
  state 52: #3 #4 #5 #6
	<var> state 53
	: state 56
  state 53: #6
	<var> state 54
  state 54: #6
	<var> state 55
  state 55: #6
  state 56: #3 #4 #5 #6
	<var> state 57
  state 57: #3 #4 #5 #6
	<var> state 58
  state 58: #3 #4 #5 #6
  state 59: #2 #6
  state 60: #1 #2 #6
	<var> state 61
	[] state 62
  state 61: #1 #6
  state 62: #1 #2 #6
  state 63: #0 #1 #2 #6
	<var> state 64
	[] state 67
  state 64: #0 #2 #6
	<var> state 65
	[] state 66
  state 65: #0 #6
  state 66: #0 #2 #6
  state 67: #0 #1 #2 #6
	<var> state 68
	[] state 69
  state 68: #0 #1 #6
  state 69: #0 #1 #2 #6
} end;
zip xs@(_/*0:0101*/:_/*0:011*/) ys@(_/*0:101*/:_/*0:11*/) = __std__::zip (,) [] zip xs/*0:01*/ ys/*0:1*/;
zipwith f/*0:001*/ xs@(_/*0:0101*/:_/*0:011*/) ys@(_/*0:101*/:_/*0:11*/) = __std__::zip f/*0:001*/ [] (zipwith f/*0:001*/) xs/*0:01*/ ys/*0:1*/;
zip_onto base/*0:001*/ xs@(_/*0:0101*/:_/*0:011*/) ys@(_/*0:101*/:_/*0:11*/) = __std__::zip (,) base/*0:001*/ (zip_onto base/*0:001*/) xs/*0:01*/ ys/*0:1*/;
zipwith_onto f/*0:0001*/ base/*0:001*/ xs@(_/*0:0101*/:_/*0:011*/) ys@(_/*0:101*/:_/*0:11*/) = __std__::zip f/*0:0001*/ base/*0:001*/ (zipwith_onto f/*0:0001*/ base/*0:001*/) xs/*0:01*/ ys/*0:1*/;
zip3 xs@(_/*0:00101*/:_/*0:0011*/) ys@(_/*0:0101*/:_/*0:011*/) zs@(_/*0:101*/:_/*0:11*/) = __std__::zip3 comma/*0*/ [] zip3 xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ with comma x/*0:001*/ y/*0:01*/ z/*0:1*/ = x/*0:001*/,y/*0:01*/,z/*0:1*/ {
  rule #0: comma x y z = x,y,z
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end;
zipwith3 f/*0:0001*/ xs@(_/*0:00101*/:_/*0:0011*/) ys@(_/*0:0101*/:_/*0:011*/) zs@(_/*0:101*/:_/*0:11*/) = __std__::zip3 f/*0:0001*/ [] (zipwith3 f/*0:0001*/) xs/*0:001*/ ys/*0:01*/ zs/*0:1*/;
zip3_onto base/*0:0001*/ xs@(_/*0:00101*/:_/*0:0011*/) ys@(_/*0:0101*/:_/*0:011*/) zs@(_/*0:101*/:_/*0:11*/) = __std__::zip3 comma/*0*/ base/*0:0001*/ (zip3_onto base/*0:0001*/) xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ with comma x/*0:001*/ y/*0:01*/ z/*0:1*/ = x/*0:001*/,y/*0:01*/,z/*0:1*/ {
  rule #0: comma x y z = x,y,z
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end;
zipwith3_onto f/*0:00001*/ base/*0:0001*/ xs@(_/*0:00101*/:_/*0:0011*/) ys@(_/*0:0101*/:_/*0:011*/) zs@(_/*0:101*/:_/*0:11*/) = __std__::zip3 f/*0:00001*/ base/*0:0001*/ (zipwith3_onto f/*0:00001*/ base/*0:0001*/) xs/*0:001*/ ys/*0:01*/ zs/*0:1*/;
unzip [] = [],[];
unzip us@(_/*0:101*/:_/*0:11*/) = foldr accum/*0*/ ([],[]) us/*0:1*/ with check us@(_/*0:101*/,_/*0:11*/) = us/*0:1*/; check (foldr _/*0:1001*/ _/*0:101*/ us/*0:11*/) = throw (bad_list_value us/*0:11*/); check us/*0:1*/ = throw (bad_tuple_value us/*0:1*/) {
  rule #0: check us@(_,_) = us
  rule #1: check (foldr _ _ us) = throw (bad_list_value us)
  rule #2: check us = throw (bad_tuple_value us)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	<app> state 9
	, state 18
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
	foldr state 14
  state 10: #2
	<var> state 11
  state 11: #2
	<var> state 12
  state 12: #2
	<var> state 13
  state 13: #2
  state 14: #1 #2
	<var> state 15
  state 15: #1 #2
	<var> state 16
  state 16: #1 #2
	<var> state 17
  state 17: #1 #2
  state 18: #0 #2
	<var> state 19
  state 19: #0 #2
	<var> state 20
  state 20: #0 #2
}; accum u@(x/*0:0101*/,y/*0:011*/) us/*0:1*/ = x/*0:0101*/:(xs/*0:01*/ when xs/*0:01*/,_/*0:1*/ = check/*2*/ us/*1:1*/ {
  rule #0: xs,_ = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end)&,y/*0:011*/:(ys/*0:1*/ when _/*0:01*/,ys/*0:1*/ = check/*2*/ us/*1:1*/ {
  rule #0: _,ys = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end)& if thunkp us/*0:1*/; accum u@(x/*0:0101*/,y/*0:011*/) us/*0:1*/ = x/*1:0101*/:xs/*0:01*/,y/*1:011*/:ys/*0:1*/ when xs/*0:01*/,ys/*0:1*/ = check/*1*/ us/*0:1*/ {
  rule #0: xs,ys = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end; accum u/*0:01*/ _/*0:1*/ = throw (bad_tuple_value u/*0:01*/) {
  rule #0: accum u@(x,y) us = x:(xs when xs,_ = check us end)&,y:(ys when _,ys = check us end)& if thunkp us
  rule #1: accum u@(x,y) us = x:xs,y:ys when xs,ys = check us end
  rule #2: accum u _ = throw (bad_tuple_value u)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 3
  state 1: #2
	<var> state 2
  state 2: #2
  state 3: #0 #1 #2
	<var> state 4
	<app> state 7
  state 4: #2
	<var> state 5
  state 5: #2
	<var> state 6
  state 6: #2
  state 7: #0 #1 #2
	<var> state 8
	, state 12
  state 8: #2
	<var> state 9
  state 9: #2
	<var> state 10
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #0 #1 #2
	<var> state 13
  state 13: #0 #1 #2
	<var> state 14
  state 14: #0 #1 #2
	<var> state 15
  state 15: #0 #1 #2
} end;
unzip3 [] = [],[],[];
unzip3 us@(_/*0:101*/:_/*0:11*/) = foldr accum/*0*/ ([],[],[]) us/*0:1*/ with check us@(_/*0:101*/,_/*0:1101*/,_/*0:111*/) = us/*0:1*/; check (foldr _/*0:1001*/ _/*0:101*/ us/*0:11*/) = throw (bad_list_value us/*0:11*/); check us/*0:1*/ = throw (bad_tuple_value us/*0:1*/) {
  rule #0: check us@(_,_,_) = us
  rule #1: check (foldr _ _ us) = throw (bad_list_value us)
  rule #2: check us = throw (bad_tuple_value us)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	<app> state 9
	, state 18
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
	foldr state 14
  state 10: #2
	<var> state 11
  state 11: #2
	<var> state 12
  state 12: #2
	<var> state 13
  state 13: #2
  state 14: #1 #2
	<var> state 15
  state 15: #1 #2
	<var> state 16
  state 16: #1 #2
	<var> state 17
  state 17: #1 #2
  state 18: #0 #2
	<var> state 19
  state 19: #0 #2
	<var> state 20
	<app> state 21
  state 20: #2
  state 21: #0 #2
	<var> state 22
	<app> state 24
  state 22: #2
	<var> state 23
  state 23: #2
  state 24: #0 #2
	<var> state 25
	, state 28
  state 25: #2
	<var> state 26
  state 26: #2
	<var> state 27
  state 27: #2
  state 28: #0 #2
	<var> state 29
  state 29: #0 #2
	<var> state 30
  state 30: #0 #2
}; accum u@(x/*0:0101*/,y/*0:01101*/,z/*0:0111*/) us/*0:1*/ = x/*0:0101*/:(xs/*0:01*/ when xs/*0:01*/,_/*0:101*/,_/*0:11*/ = check/*2*/ us/*1:1*/ {
  rule #0: xs,_,_ = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	, state 7
  state 7: #0
	<var> state 8
  state 8: #0
	<var> state 9
  state 9: #0
} end)&,y/*0:01101*/:(ys/*0:101*/ when _/*0:01*/,ys/*0:101*/,_/*0:11*/ = check/*2*/ us/*1:1*/ {
  rule #0: _,ys,_ = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	, state 7
  state 7: #0
	<var> state 8
  state 8: #0
	<var> state 9
  state 9: #0
} end)&,z/*0:0111*/:(zs/*0:11*/ when _/*0:01*/,_/*0:101*/,zs/*0:11*/ = check/*2*/ us/*1:1*/ {
  rule #0: _,_,zs = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	, state 7
  state 7: #0
	<var> state 8
  state 8: #0
	<var> state 9
  state 9: #0
} end)& if thunkp us/*0:1*/; accum u@(x/*0:0101*/,y/*0:01101*/,z/*0:0111*/) us/*0:1*/ = x/*1:0101*/:xs/*0:01*/,y/*1:01101*/:ys/*0:101*/,z/*1:0111*/:zs/*0:11*/ when xs/*0:01*/,ys/*0:101*/,zs/*0:11*/ = check/*1*/ us/*0:1*/ {
  rule #0: xs,ys,zs = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	, state 7
  state 7: #0
	<var> state 8
  state 8: #0
	<var> state 9
  state 9: #0
} end; accum u/*0:01*/ _/*0:1*/ = throw (bad_tuple_value u/*0:01*/) {
  rule #0: accum u@(x,y,z) us = x:(xs when xs,_,_ = check us end)&,y:(ys when _,ys,_ = check us end)&,z:(zs when _,_,zs = check us end)& if thunkp us
  rule #1: accum u@(x,y,z) us = x:xs,y:ys,z:zs when xs,ys,zs = check us end
  rule #2: accum u _ = throw (bad_tuple_value u)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 3
  state 1: #2
	<var> state 2
  state 2: #2
  state 3: #0 #1 #2
	<var> state 4
	<app> state 7
  state 4: #2
	<var> state 5
  state 5: #2
	<var> state 6
  state 6: #2
  state 7: #0 #1 #2
	<var> state 8
	, state 12
  state 8: #2
	<var> state 9
  state 9: #2
	<var> state 10
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #0 #1 #2
	<var> state 13
  state 13: #0 #1 #2
	<var> state 14
	<app> state 16
  state 14: #2
	<var> state 15
  state 15: #2
  state 16: #0 #1 #2
	<var> state 17
	<app> state 20
  state 17: #2
	<var> state 18
  state 18: #2
	<var> state 19
  state 19: #2
  state 20: #0 #1 #2
	<var> state 21
	, state 25
  state 21: #2
	<var> state 22
  state 22: #2
	<var> state 23
  state 23: #2
	<var> state 24
  state 24: #2
  state 25: #0 #1 #2
	<var> state 26
  state 26: #0 #1 #2
	<var> state 27
  state 27: #0 #1 #2
	<var> state 28
  state 28: #0 #1 #2
} end;
dowith f/*0:001*/ (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = f/*0:001*/ x/*0:0101*/ y/*0:101*/$$dowith f/*0:001*/ xs/*0:011*/ ys/*0:11*/;
dowith f/*0:001*/ _/*0:01*/ _/*0:1*/ = ();
dowith3 f/*0:0001*/ (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = f/*0:0001*/ x/*0:00101*/ y/*0:0101*/ z/*0:101*/$$dowith3 f/*0:0001*/ xs/*0:0011*/ ys/*0:011*/ zs/*0:11*/;
dowith3 f/*0:0001*/ _/*0:001*/ _/*0:01*/ _/*0:1*/ = ();
xs/*0:01*/!!ns/*0:1*/ = ys/*0:*/ if ok/*1*/ ys/*0:*/ when ys/*0:*/ = case ns/*0:1*/ of ns@(n/*0:01*/ :: int:_/*0:1*/) = list (take (count/*1*/ ns/*0:*/) (drop n/*0:01*/ xs/*1:01*/)) if listp xs/*1:01*/&&cont/*1*/ ns/*0:*/; _/*0:*/ = catmap (nth/*1*/ xs/*1:01*/) ns/*1:1*/ {
  rule #0: ns@(n::int:_) = list (take (count ns) (drop n xs)) if listp xs&&cont ns
  rule #1: _ = catmap (nth xs) ns
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	: state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
	<var>::int state 12
  state 10: #1
	<var> state 11
  state 11: #1
  state 12: #0 #1
	<var> state 13
  state 13: #0 #1
} end {
  rule #0: ys = case ns of ns@(n::int:_) = list (take (count ns) (drop n xs)) if listp xs&&cont ns; _ = catmap (nth xs) ns end
  state 0: #0
	<var> state 1
  state 1: #0
} end with ok (catmap (nth _/*0:1011*/) _/*0:11*/) = 0; ok _/*0:1*/ = 1 {
  rule #0: ok (catmap (nth _) _) = 0
  rule #1: ok _ = 1
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	catmap state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #1
	<var> state 11
  state 11: #1
  state 12: #0 #1
	<var> state 13
	nth state 16
  state 13: #1
	<var> state 14
  state 14: #1
	<var> state 15
  state 15: #1
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
}; cont (n/*0:101*/ :: int:ns/*0:11*/) = ~thunkp ns/*0:11*/&&(case ns/*0:11*/ of [] = 1; m/*0:01*/ :: int:_/*0:1*/ = cont/*2*/ ns/*1:11*/ if m/*0:01*/==n/*1:101*/+1; _/*0:*/ = 0 {
  rule #0: [] = 1
  rule #1: m::int:_ = cont ns if m==n+1
  rule #2: _ = 0
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
	[] state 14
  state 1: #2
  state 2: #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
	<var>::int state 12
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #1 #2
	<var> state 13
  state 13: #1 #2
  state 14: #0 #2
} end) {
  rule #0: cont (n::int:ns) = ~thunkp ns&&(case ns of [] = 1; m::int:_ = cont ns if m==n+1; _ = 0 end)
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var>::int state 4
  state 4: #0
	<var> state 5
  state 5: #0
}; nth xs/*0:01*/ n/*0:1*/ = catch (cst []) [xs/*1:01*/!n/*1:1*/] {
  rule #0: nth xs n = catch (cst []) [xs!n]
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}; count ns/*0:1*/ = #dropwhile (\n/*0:1*/ :: int -> n/*0:1*/<0 {
  rule #0: _ n::int = n<0
  state 0: #0
	<var>::int state 1
  state 1: #0
}) ns/*0:1*/ {
  rule #0: count ns = #dropwhile (\n::int -> n<0) ns
  state 0: #0
	<var> state 1
  state 1: #0
} end;
subseq [] a/*0:01*/ :: int b/*0:1*/ :: int = [];
subseq xs@(_/*0:00101*/:_/*0:0011*/) a/*0:01*/ :: int b/*0:1*/ :: int = take/*0*/ (b/*0:1*/-a/*0:01*/+1) (drop a/*0:01*/ xs/*0:001*/) with take 0 xs/*0:1*/ = []; take m/*0:01*/ :: int xs/*0:1*/ = take_pre/*0*/ len_pre/*0:0*/ xs/*1:1*/ with take_pre 0 _/*0:1*/ = front_tail/*1:1*/; take_pre n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:take_pre/*1*/ (n/*0:01*/-1) xs/*0:11*/ {
  rule #0: take_pre 0 _ = front_tail
  rule #1: take_pre n::int (x:xs) = x:take_pre (n-1) xs
  state 0: #0 #1
	<var>::int state 1
	0::int state 7
  state 1: #1
	<app> state 2
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0 #1
	<var> state 8
	<app> state 9
  state 8: #0
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #0
	<var> state 11
  state 11: #0
  state 12: #0 #1
	<var> state 13
	: state 16
  state 13: #0
	<var> state 14
  state 14: #0
	<var> state 15
  state 15: #0
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end when len_pre@_/*0:0*/ front_tail/*0:1*/ = skip_ahead/*1*/ m/*0:01*/ 0 xs/*0:1*/ {
  rule #0: len_pre@_ front_tail = skip_ahead m 0 xs
  state 0: #0
	<app> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end {
  rule #0: take 0 xs = []
  rule #1: take m::int xs = take_pre len_pre xs with take_pre 0 _ = front_tail; take_pre n::int (x:xs) = x:take_pre (n-1) xs end when len_pre@_ front_tail = skip_ahead m 0 xs end
  state 0: #0 #1
	<var>::int state 1
	0::int state 3
  state 1: #1
	<var> state 2
  state 2: #1
  state 3: #0 #1
	<var> state 4
  state 4: #0 #1
}; skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ [] if m/*0:001*/<=0||xs/*0:1*/===[]; skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int (x/*0:101*/:xs/*0:11*/) = skip_ahead/*1*/ (m/*0:001*/-1) (n/*0:01*/+1) xs/*0:11*/ if n/*0:01*/<4096; skip_ahead m/*0:001*/ :: int n/*0:01*/ :: int xs/*0:1*/ = n/*0:01*/ (take/*1*/ m/*0:001*/ xs/*0:1*/) {
  rule #0: skip_ahead m::int n::int xs = n [] if m<=0||xs===[]
  rule #1: skip_ahead m::int n::int (x:xs) = skip_ahead (m-1) (n+1) xs if n<4096
  rule #2: skip_ahead m::int n::int xs = n (take m xs)
  state 0: #0 #1 #2
	<var>::int state 1
  state 1: #0 #1 #2
	<var>::int state 2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 4
  state 3: #0 #2
  state 4: #0 #1 #2
	<var> state 5
	<app> state 7
  state 5: #0 #2
	<var> state 6
  state 6: #0 #2
  state 7: #0 #1 #2
	<var> state 8
	: state 11
  state 8: #0 #2
	<var> state 9
  state 9: #0 #2
	<var> state 10
  state 10: #0 #2
  state 11: #0 #1 #2
	<var> state 12
  state 12: #0 #1 #2
	<var> state 13
  state 13: #0 #1 #2
} end;
subseq x/*0:001*/ a/*0:01*/ b/*0:1*/ = slice x/*0:001*/ (a/*0:01*/..b/*0:1*/);
def x/*0:01*/!!(a/*0:101*/..b/*0:11*/) = subseq x/*0:01*/ a/*0:101*/ b/*0:11*/;
list () = [];
list (x/*0:101*/,xs/*0:11*/) = accum/*0*/ [x/*0:101*/] xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/,xs/*0:11*/) = accum/*1*/ (x/*0:101*/:ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ x/*0:1*/ = __std__::reverse_onto [] (x/*0:1*/:ys/*0:01*/) {
  rule #0: accum ys (x,xs) = accum (x:ys) xs
  rule #1: accum ys x = __std__::reverse_onto [] (x:ys)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	, state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
} end;
tuple [] = ();
tuple (x/*0:101*/:xs/*0:11*/) = accum/*0*/ (t/*0*/ x/*0:101*/) xs/*0:11*/ with t x@(_/*0:101*/,_/*0:11*/) = reverse x/*0:1*/; t x/*0:1*/ = x/*0:1*/ {
  rule #0: t x@(_,_) = reverse x
  rule #1: t x = x
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	, state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
}; accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (t/*1*/ x/*0:101*/,ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ [] = t/*1*/ ys/*0:01*/; accum ys/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: accum ys (x:xs) = accum (t x,ys) xs
  rule #1: accum ys [] = t ys
  rule #2: accum ys xs = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
tuple x@() = x/*0:1*/;
tuple x@(_/*0:101*/,_/*0:11*/) = x/*0:1*/;
list [] = [];
list (x/*0:101*/:xs/*0:11*/) = accum/*0*/ [x/*0:101*/] xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (x/*0:101*/:ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ [] = __std__::reverse_onto [] ys/*0:01*/; accum ys/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: accum ys (x:xs) = accum (x:ys) xs
  rule #1: accum ys [] = __std__::reverse_onto [] ys
  rule #2: accum ys xs = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
stream [] = [];
stream (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:xs/*0:11*/ if thunkp xs/*0:11*/;
stream (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:stream xs/*1:11*/&;
stream () = [];
stream xs@(_/*0:101*/,_/*0:11*/) = stream (list xs/*0:1*/);
catstream [] = [];
catstream ((x/*0:10101*/:xs/*0:1011*/):yss/*0:11*/) = x/*0:10101*/:catstream (xs/*1:1011*/:yss/*1:11*/)&;
catstream ([]:yss/*0:11*/) = catstream yss/*0:11*/;
catstream (xs/*0:101*/ :: string:yss/*0:11*/) = catstream (chars xs/*0:101*/:yss/*0:11*/);
catstream (xs/*0:101*/:yss/*0:11*/) = xs/*0:101*/+catstream yss/*0:11*/;
x/*0:01*/ :: smatrix==?y/*0:1*/ :: matrix = 0 if dim x/*0:01*/~=dim y/*0:1*/;
x/*0:01*/ :: matrix==?y/*0:1*/ :: smatrix = 0 if dim x/*0:01*/~=dim y/*0:1*/;
x/*0:01*/ :: smatrix==?y/*0:1*/ :: matrix = compare/*0*/ 0 with compare i/*0:1*/ :: int = 1 if i/*0:1*/>=n/*1:*/; compare i/*0:1*/ :: int = 0 if x/*2:01*/!i/*0:1*/~=?y/*2:1*/!i/*0:1*/; compare i/*0:1*/ :: int = compare/*1*/ (i/*0:1*/+1) {
  rule #0: compare i::int = 1 if i>=n
  rule #1: compare i::int = 0 if x!i~=?y!i
  rule #2: compare i::int = compare (i+1)
  state 0: #0 #1 #2
	<var>::int state 1
  state 1: #0 #1 #2
} end when n/*0:*/ :: int = #x/*0:01*/ {
  rule #0: n::int = #x
  state 0: #0
	<var>::int state 1
  state 1: #0
} end;
x/*0:01*/ :: matrix==?y/*0:1*/ :: smatrix = compare/*0*/ 0 with compare i/*0:1*/ :: int = 1 if i/*0:1*/>=n/*1:*/; compare i/*0:1*/ :: int = 0 if x/*2:01*/!i/*0:1*/~=?y/*2:1*/!i/*0:1*/; compare i/*0:1*/ :: int = compare/*1*/ (i/*0:1*/+1) {
  rule #0: compare i::int = 1 if i>=n
  rule #1: compare i::int = 0 if x!i~=?y!i
  rule #2: compare i::int = compare (i+1)
  state 0: #0 #1 #2
	<var>::int state 1
  state 1: #0 #1 #2
} end when n/*0:*/ :: int = #x/*0:01*/ {
  rule #0: n::int = #x
  state 0: #0
	<var>::int state 1
  state 1: #0
} end;
x/*0:01*/ :: smatrix~=?y/*0:1*/ :: matrix = ~x/*0:01*/==?y/*0:1*/;
x/*0:01*/ :: matrix~=?y/*0:1*/ :: smatrix = ~x/*0:01*/==?y/*0:1*/;
(x/*0:0101*/=>v/*0:011*/)==?(y/*0:101*/=>w/*0:11*/) = x/*0:0101*/==?y/*0:101*/&&v/*0:011*/==?w/*0:11*/;
(x/*0:0101*/=>v/*0:011*/)~=?(y/*0:101*/=>w/*0:11*/) = x/*0:0101*/~=?y/*0:101*/||v/*0:011*/~=?w/*0:11*/;
(x/*0:0101*/,xs/*0:011*/)==?(y/*0:101*/,ys/*0:11*/) = x/*0:0101*/==?y/*0:101*/&&xs/*0:011*/==?ys/*0:11*/;
(x/*0:0101*/,xs/*0:011*/)~=?(y/*0:101*/,ys/*0:11*/) = x/*0:0101*/~=?y/*0:101*/||xs/*0:011*/~=?ys/*0:11*/;
x/*0:0101*/:xs/*0:011*/==?y/*0:101*/:ys/*0:11*/ = x/*0:0101*/==?y/*0:101*/&&xs/*0:011*/==?ys/*0:11*/;
x/*0:0101*/:xs/*0:011*/~=?y/*0:101*/:ys/*0:11*/ = x/*0:0101*/~=?y/*0:101*/||xs/*0:011*/~=?ys/*0:11*/;
x/*0:01*/==?y/*0:1*/ = case x/*0:01*/==y/*0:1*/ of res/*0:*/ :: int = res/*0:*/; _/*0:*/ = case x/*1:01*/:y/*1:1*/ of xh@_/*0:010*/ xv/*0:011*/:yh@_/*0:10*/ yv/*0:11*/ = xh/*0:010*/==?yh/*0:10*/&&xv/*0:011*/==?yv/*0:11*/; x/*0:01*/:x/*0:1*/ = 1; _/*0:*/ = 0 {
  rule #0: xh@_ xv:yh@_ yv = xh==?yh&&xv==?yv
  rule #1: x:x = 1
  rule #2: _ = 0
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #1 #2
	<var> state 10
	<app> state 12
  state 10: #1 #2
	<var> state 11
  state 11: #1 #2
  state 12: #0 #1 #2
	<var> state 13
  state 13: #0 #1 #2
	<var> state 14
  state 14: #0 #1 #2
	<var> state 15
	<app> state 16
  state 15: #1 #2
  state 16: #0 #1 #2
	<var> state 17
  state 17: #0 #1 #2
	<var> state 18
  state 18: #0 #1 #2
} end {
  rule #0: res::int = res
  rule #1: _ = case x:y of xh@_ xv:yh@_ yv = xh==?yh&&xv==?yv; x:x = 1; _ = 0 end
  state 0: #0 #1
	<var> state 1
	<var>::int state 2
  state 1: #1
  state 2: #0 #1
} end;
x/*0:01*/~=?y/*0:1*/ = case x/*0:01*/==y/*0:1*/ of res/*0:*/ :: int = res/*0:*/==0; _/*0:*/ = case x/*1:01*/:y/*1:1*/ of xh@_/*0:010*/ xv/*0:011*/:yh@_/*0:10*/ yv/*0:11*/ = xh/*0:010*/~=?yh/*0:10*/||xv/*0:011*/~=?yv/*0:11*/; x/*0:01*/:x/*0:1*/ = 0; _/*0:*/ = 1 {
  rule #0: xh@_ xv:yh@_ yv = xh~=?yh||xv~=?yv
  rule #1: x:x = 0
  rule #2: _ = 1
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #1 #2
	<var> state 10
	<app> state 12
  state 10: #1 #2
	<var> state 11
  state 11: #1 #2
  state 12: #0 #1 #2
	<var> state 13
  state 13: #0 #1 #2
	<var> state 14
  state 14: #0 #1 #2
	<var> state 15
	<app> state 16
  state 15: #1 #2
  state 16: #0 #1 #2
	<var> state 17
  state 17: #0 #1 #2
	<var> state 18
  state 18: #0 #1 #2
} end {
  rule #0: res::int = res==0
  rule #1: _ = case x:y of xh@_ xv:yh@_ yv = xh~=?yh||xv~=?yv; x:x = 0; _ = 1 end
  state 0: #0 #1
	<var> state 1
	<var>::int state 2
  state 1: #1
  state 2: #0 #1
} end;
def void (catmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (listmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (rowcatmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (colcatmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (rowmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (colmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void x/*0:1*/ = __std__::__voidchk__ x/*0:1*/ x/*0:1*/;
def __std__::__voidchk__ (__ifelse__ y/*0:1001*/ z/*0:101*/ []) = __std__::__voidchk1__ (__ifelse__ y/*0:1001*/ (void z/*0:101*/) ());
def __std__::__voidchk__ (__ifelse__ y/*0:1001*/ z/*0:101*/ {}) = __std__::__voidchk1__ (__ifelse__ y/*0:1001*/ (void z/*0:101*/) ());
def __std__::__voidchk1__ x/*0:01*/ y/*0:1*/ = x/*0:01*/;
{
  rule #0: x::int+y::int = x+y
  rule #1: x::double+y::double = x+y
  rule #2: x::int+y::double = x+y
  rule #3: x::double+y::int = x+y
  rule #4: x::bigint+y::bigint = __C::bigint_add x y
  rule #5: x::int+y::bigint = bigint x+y
  rule #6: x::bigint+y::int = x+bigint y
  rule #7: x::bigint+y::double = double x+y
  rule #8: x::double+y::bigint = x+double y
  rule #9: s::string+n::int = chr (ord s+n) if #s==1
  rule #10: s::string+t::string = __C::string_concat s t
  rule #11: s::string+[] = chars s
  rule #12: s::string+xs@(_:_) = chars s+xs
  rule #13: []+s::string = chars s
  rule #14: xs@(_:_)+s::string = xs+chars s
  rule #15: []+ys = ys
  rule #16: xs@(_:_)+ys = aux xs with aux xs = fold_pre len_pre xs with fold_pre 0 _ = folded_tail; fold_pre n::int (x:xs) = x:fold_pre (n-1) xs end when len_pre@_ folded_tail = skip_ahead 0 xs end; skip_ahead n::int [] = n ys; skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096; skip_ahead n::int (x:xs) = n (x:aux xs&) if thunkp xs; skip_ahead n::int (x:xs) = skip_ahead (n+1) xs; skip_ahead n::int xs = n (xs+ys) end
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16
	<var>::int state 1
	<var>::bigint state 5
	<var>::double state 9
	<var>::string state 13
	<app> state 22
	[] state 29
  state 1: #0 #2 #5
	<var>::int state 2
	<var>::bigint state 3
	<var>::double state 4
  state 2: #0
  state 3: #5
  state 4: #2
  state 5: #4 #6 #7
	<var>::int state 6
	<var>::bigint state 7
	<var>::double state 8
  state 6: #6
  state 7: #4
  state 8: #7
  state 9: #1 #3 #8
	<var>::int state 10
	<var>::bigint state 11
	<var>::double state 12
  state 10: #3
  state 11: #8
  state 12: #1
  state 13: #9 #10 #11 #12
	<var>::int state 14
	<var>::string state 15
	<app> state 16
	[] state 21
  state 14: #9
  state 15: #10
  state 16: #12
	<app> state 17
  state 17: #12
	: state 18
  state 18: #12
	<var> state 19
  state 19: #12
	<var> state 20
  state 20: #12
  state 21: #11
  state 22: #14 #16
	<app> state 23
  state 23: #14 #16
	: state 24
  state 24: #14 #16
	<var> state 25
  state 25: #14 #16
	<var> state 26
  state 26: #14 #16
	<var> state 27
	<var>::string state 28
  state 27: #16
  state 28: #14 #16
  state 29: #13 #15
	<var> state 30
	<var>::string state 31
  state 30: #15
  state 31: #13 #15
}
{
  rule #0: catmap f x::matrix = cat (list (map f x))
  rule #1: catmap f s::string = catmap f (chars s)
  rule #2: catmap f [] = []
  rule #3: catmap f xs@(_:_) = aux xs with aux xs = map_pre len_pre xs with map_pre 0 _ = mapped_tail; map_pre n::int (x:xs) = lazy_cat (f x) (map_pre (n-1) xs) end when len_pre@_ mapped_tail = skip_map 0 xs end; lazy_cat xs yss = cat_pre len_pre xs with cat_pre 0 _ = catted_tail; cat_pre n::int (x:xs) = x:cat_pre (n-1) xs end when len_pre@_ catted_tail = skip_cat yss 0 xs end; skip_map n::int [] = n []; skip_map n::int xs@(_:_) = n (aux xs) if n==4096; skip_map n::int (x:xs) = n (lazy_cat (f x) (aux xs&)) if thunkp xs; skip_map n::int (x:xs) = skip_map (n+1) xs; skip_map n::int xs = n (catmap f xs); skip_cat yss n::int [] = n yss; skip_cat yss n::int xs@(_:_) = n (aux xs) if n==4096; skip_cat yss n::int (x:xs) = n (x:lazy_cat xs yss&) if thunkp xs; skip_cat yss n::int (x:xs) = skip_cat yss (n+1) xs; skip_cat yss n::int xs = n (xs+yss) end
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: listmap f x::matrix = list (map f x)
  rule #1: listmap f s::string = map f (chars s)
  rule #2: listmap f [] = []
  rule #3: listmap f xs@(_:_) = map f xs
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: n::int..m::int = __C::pure_int_seq n m 1
  rule #1: n1::int:n2::int..m::int = __C::pure_int_seq n1 m (n2-n1) if n1~=n2
  rule #2: n::double..m::double = __C::pure_double_seq n m 1.0 if ~infp n&&~infp m
  rule #3: n::int..m::double = __C::pure_double_seq (double n) m 1.0 if ~infp m
  rule #4: n::double..m::int = __C::pure_double_seq n (double m) 1.0 if ~infp n
  rule #5: n1::double:n2::double..m::double = __C::pure_double_seq n1 m (n2-n1) if ~infp n1&&~infp m&&n1~=n2
  rule #6: n1::int:n2::double..m::double = __C::pure_double_seq (double n1) m (n2-n1) if ~infp m&&n1~=n2
  rule #7: n1::double:n2::int..m::double = __C::pure_double_seq n1 m (n2-n1) if ~infp n1&&~infp m&&n1~=n2
  rule #8: n1::double:n2::double..m::int = __C::pure_double_seq n1 (double m) (n2-n1) if ~infp n1&&n1~=n2
  rule #9: n1::int:n2::int..m::double = __C::pure_double_seq (double n1) m (double (n2-n1)) if ~infp m&&n1~=n2
  rule #10: n1::int:n2::double..m::int = __C::pure_double_seq (double n1) (double m) (n2-n1) if n1~=n2
  rule #11: n1::double:n2::int..m::int = __C::pure_double_seq n1 (double m) (n2-n1) if ~infp n1&&n1~=n2
  rule #12: a::string..b::string = map chr (ord a..ord b) if charp a&&charp b
  rule #13: a::string:b::string..c::string = map chr (ord a:ord b..ord c) if charp a&&charp b&&charp c
  rule #14: n1:n2..m = if nanp n1||nanp m||double m===-s then [] else if double m===s then iterate (flip (+) k) n1 else iterwhile (p (m+0.5*k)) (flip (+) k) n1 when s,p = if k>0 then inf,(>=) else -inf,(<=) end if realp k&&k~=0&&~infp n1&&~infp n2 when k = n2-n1 end
  rule #15: n..m = if nanp n||nanp m||double m===-inf then [] else if double m===inf then iterate (flip (+) 1) n else iterwhile ((>=) m) (flip (+) 1) n if ~listp n&&~infp n
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15
	<var> state 1
	<var>::int state 3
	<var>::double state 7
	<var>::string state 11
	<app> state 14
  state 1: #15
	<var> state 2
  state 2: #15
  state 3: #0 #3 #15
	<var> state 4
	<var>::int state 5
	<var>::double state 6
  state 4: #15
  state 5: #0 #15
  state 6: #3 #15
  state 7: #2 #4 #15
	<var> state 8
	<var>::int state 9
	<var>::double state 10
  state 8: #15
  state 9: #4 #15
  state 10: #2 #15
  state 11: #12 #15
	<var> state 12
	<var>::string state 13
  state 12: #15
  state 13: #12 #15
  state 14: #1 #5 #6 #7 #8 #9 #10 #11 #13 #14 #15
	<var> state 15
	<app> state 18
  state 15: #15
	<var> state 16
  state 16: #15
	<var> state 17
  state 17: #15
  state 18: #1 #5 #6 #7 #8 #9 #10 #11 #13 #14 #15
	<var> state 19
	: state 23
  state 19: #15
	<var> state 20
  state 20: #15
	<var> state 21
  state 21: #15
	<var> state 22
  state 22: #15
  state 23: #1 #5 #6 #7 #8 #9 #10 #11 #13 #14 #15
	<var> state 24
	<var>::int state 27
	<var>::double state 38
	<var>::string state 49
  state 24: #14 #15
	<var> state 25
  state 25: #14 #15
	<var> state 26
  state 26: #14 #15
  state 27: #1 #6 #9 #10 #14 #15
	<var> state 28
	<var>::int state 30
	<var>::double state 34
  state 28: #14 #15
	<var> state 29
  state 29: #14 #15
  state 30: #1 #9 #14 #15
	<var> state 31
	<var>::int state 32
	<var>::double state 33
  state 31: #14 #15
  state 32: #1 #14 #15
  state 33: #9 #14 #15
  state 34: #6 #10 #14 #15
	<var> state 35
	<var>::int state 36
	<var>::double state 37
  state 35: #14 #15
  state 36: #10 #14 #15
  state 37: #6 #14 #15
  state 38: #5 #7 #8 #11 #14 #15
	<var> state 39
	<var>::int state 41
	<var>::double state 45
  state 39: #14 #15
	<var> state 40
  state 40: #14 #15
  state 41: #7 #11 #14 #15
	<var> state 42
	<var>::int state 43
	<var>::double state 44
  state 42: #14 #15
  state 43: #11 #14 #15
  state 44: #7 #14 #15
  state 45: #5 #8 #14 #15
	<var> state 46
	<var>::int state 47
	<var>::double state 48
  state 46: #14 #15
  state 47: #8 #14 #15
  state 48: #5 #14 #15
  state 49: #13 #14 #15
	<var> state 50
	<var>::string state 52
  state 50: #14 #15
	<var> state 51
  state 51: #14 #15
  state 52: #13 #14 #15
	<var> state 53
	<var>::string state 54
  state 53: #14 #15
  state 54: #13 #14 #15
}
{
  rule #0: x::smatrix==?y::matrix = 0 if dim x~=dim y
  rule #1: x::matrix==?y::smatrix = 0 if dim x~=dim y
  rule #2: x::smatrix==?y::matrix = compare 0 with compare i::int = 1 if i>=n; compare i::int = 0 if x!i~=?y!i; compare i::int = compare (i+1) end when n::int = #x end
  rule #3: x::matrix==?y::smatrix = compare 0 with compare i::int = 1 if i>=n; compare i::int = 0 if x!i~=?y!i; compare i::int = compare (i+1) end when n::int = #x end
  rule #4: (x=>v)==?(y=>w) = x==?y&&v==?w
  rule #5: (x,xs)==?(y,ys) = x==?y&&xs==?ys
  rule #6: x:xs==?y:ys = x==?y&&xs==?ys
  rule #7: x==?y = case x==y of res::int = res; _ = case x:y of xh@_ xv:yh@_ yv = xh==?yh&&xv==?yv; x:x = 1; _ = 0 end end
  state 0: #0 #1 #2 #3 #4 #5 #6 #7
	<var> state 1
	<var>::matrix state 4
	<app> state 7
  state 1: #0 #2 #7
	<var> state 2
	<var>::matrix state 3
  state 2: #7
  state 3: #0 #2 #7
  state 4: #0 #1 #2 #3 #7
	<var> state 5
	<var>::matrix state 6
  state 5: #1 #3 #7
  state 6: #0 #1 #2 #3 #7
  state 7: #0 #2 #4 #5 #6 #7
	<var> state 8
	<app> state 12
  state 8: #0 #2 #7
	<var> state 9
  state 9: #0 #2 #7
	<var> state 10
	<var>::matrix state 11
  state 10: #7
  state 11: #0 #2 #7
  state 12: #0 #2 #4 #5 #6 #7
	<var> state 13
	: state 18
	, state 33
	=> state 48
  state 13: #0 #2 #7
	<var> state 14
  state 14: #0 #2 #7
	<var> state 15
  state 15: #0 #2 #7
	<var> state 16
	<var>::matrix state 17
  state 16: #7
  state 17: #0 #2 #7
  state 18: #0 #2 #6 #7
	<var> state 19
  state 19: #0 #2 #6 #7
	<var> state 20
  state 20: #0 #2 #6 #7
	<var> state 21
	<var>::matrix state 22
	<app> state 23
  state 21: #7
  state 22: #0 #2 #7
  state 23: #6 #7
	<var> state 24
	<app> state 26
  state 24: #7
	<var> state 25
  state 25: #7
  state 26: #6 #7
	<var> state 27
	: state 30
  state 27: #7
	<var> state 28
  state 28: #7
	<var> state 29
  state 29: #7
  state 30: #6 #7
	<var> state 31
  state 31: #6 #7
	<var> state 32
  state 32: #6 #7
  state 33: #0 #2 #5 #7
	<var> state 34
  state 34: #0 #2 #5 #7
	<var> state 35
  state 35: #0 #2 #5 #7
	<var> state 36
	<var>::matrix state 37
	<app> state 38
  state 36: #7
  state 37: #0 #2 #7
  state 38: #5 #7
	<var> state 39
	<app> state 41
  state 39: #7
	<var> state 40
  state 40: #7
  state 41: #5 #7
	<var> state 42
	, state 45
  state 42: #7
	<var> state 43
  state 43: #7
	<var> state 44
  state 44: #7
  state 45: #5 #7
	<var> state 46
  state 46: #5 #7
	<var> state 47
  state 47: #5 #7
  state 48: #0 #2 #4 #7
	<var> state 49
  state 49: #0 #2 #4 #7
	<var> state 50
  state 50: #0 #2 #4 #7
	<var> state 51
	<var>::matrix state 52
	<app> state 53
  state 51: #7
  state 52: #0 #2 #7
  state 53: #4 #7
	<var> state 54
	<app> state 56
  state 54: #7
	<var> state 55
  state 55: #7
  state 56: #4 #7
	<var> state 57
	=> state 60
  state 57: #7
	<var> state 58
  state 58: #7
	<var> state 59
  state 59: #7
  state 60: #4 #7
	<var> state 61
  state 61: #4 #7
	<var> state 62
  state 62: #4 #7
}
{
  rule #0: x::smatrix~=?y::matrix = ~x==?y
  rule #1: x::matrix~=?y::smatrix = ~x==?y
  rule #2: (x=>v)~=?(y=>w) = x~=?y||v~=?w
  rule #3: (x,xs)~=?(y,ys) = x~=?y||xs~=?ys
  rule #4: x:xs~=?y:ys = x~=?y||xs~=?ys
  rule #5: x~=?y = case x==y of res::int = res==0; _ = case x:y of xh@_ xv:yh@_ yv = xh~=?yh||xv~=?yv; x:x = 0; _ = 1 end end
  state 0: #0 #1 #2 #3 #4 #5
	<var> state 1
	<var>::matrix state 4
	<app> state 7
  state 1: #0 #5
	<var> state 2
	<var>::matrix state 3
  state 2: #5
  state 3: #0 #5
  state 4: #0 #1 #5
	<var> state 5
	<var>::matrix state 6
  state 5: #1 #5
  state 6: #0 #1 #5
  state 7: #0 #2 #3 #4 #5
	<var> state 8
	<app> state 12
  state 8: #0 #5
	<var> state 9
  state 9: #0 #5
	<var> state 10
	<var>::matrix state 11
  state 10: #5
  state 11: #0 #5
  state 12: #0 #2 #3 #4 #5
	<var> state 13
	: state 18
	, state 33
	=> state 48
  state 13: #0 #5
	<var> state 14
  state 14: #0 #5
	<var> state 15
  state 15: #0 #5
	<var> state 16
	<var>::matrix state 17
  state 16: #5
  state 17: #0 #5
  state 18: #0 #4 #5
	<var> state 19
  state 19: #0 #4 #5
	<var> state 20
  state 20: #0 #4 #5
	<var> state 21
	<var>::matrix state 22
	<app> state 23
  state 21: #5
  state 22: #0 #5
  state 23: #4 #5
	<var> state 24
	<app> state 26
  state 24: #5
	<var> state 25
  state 25: #5
  state 26: #4 #5
	<var> state 27
	: state 30
  state 27: #5
	<var> state 28
  state 28: #5
	<var> state 29
  state 29: #5
  state 30: #4 #5
	<var> state 31
  state 31: #4 #5
	<var> state 32
  state 32: #4 #5
  state 33: #0 #3 #5
	<var> state 34
  state 34: #0 #3 #5
	<var> state 35
  state 35: #0 #3 #5
	<var> state 36
	<var>::matrix state 37
	<app> state 38
  state 36: #5
  state 37: #0 #5
  state 38: #3 #5
	<var> state 39
	<app> state 41
  state 39: #5
	<var> state 40
  state 40: #5
  state 41: #3 #5
	<var> state 42
	, state 45
  state 42: #5
	<var> state 43
  state 43: #5
	<var> state 44
  state 44: #5
  state 45: #3 #5
	<var> state 46
  state 46: #3 #5
	<var> state 47
  state 47: #3 #5
  state 48: #0 #2 #5
	<var> state 49
  state 49: #0 #2 #5
	<var> state 50
  state 50: #0 #2 #5
	<var> state 51
	<var>::matrix state 52
	<app> state 53
  state 51: #5
  state 52: #0 #5
  state 53: #2 #5
	<var> state 54
	<app> state 56
  state 54: #5
	<var> state 55
  state 55: #5
  state 56: #2 #5
	<var> state 57
	=> state 60
  state 57: #5
	<var> state 58
  state 58: #5
	<var> state 59
  state 59: #5
  state 60: #2 #5
	<var> state 61
  state 61: #2 #5
	<var> state 62
  state 62: #2 #5
}
{
  rule #0: x!!ns::matrix = x!!list ns
  rule #1: x!!(ns::matrix,ms) = x!!(list ns,ms) if ~tuplep ms
  rule #2: x!!(ns,ms::matrix) = x!!(ns,list ms)
  rule #3: x!!(ns::int,ms) = x!!([ns],ms) if ~tuplep ms
  rule #4: x!!(ns,ms::int) = x!!(ns,[ms])
  rule #5: x::matrix!!(ns,ms) = case ns,ms of ns@(n:_),ms@(m:_) = submat x (n,m) (#ns,#ms) if cont ns&&cont ms; _ = colcatmap (mth (rowcatmap (nth x) ns)) ms end with cont [n::int] = 1; cont (n::int:ns@(m::int:_)) = cont ns if m==n+1; cont _ = 0; mth x m = catch (cst {}) (col x m); nth x n = catch (cst {}) (row x n) end
  rule #6: x::matrix!!ns = if all intp ns&&packed x then rowvector x!!([0],ns) else colcatmap (nth x) ns with nth x n = catch (cst {}) {x!n} end
  rule #7: s::string!!ns = case ns of ns@(n:_) = substr s n (count ns) if cont ns; _ = string (chars s!!ns) end with cont [n::int] = 1; cont (n::int:ns@(m::int:_)) = cont ns if m==n+1; cont _ = 0; count ns = #dropwhile (\n::int -> n<0) ns end
  rule #8: xs@()!!ns = tuple (list xs!!ns)
  rule #9: xs@(_,_)!!ns = tuple (list xs!!ns)
  rule #10: xs!!ns = ys if ok ys when ys = case ns of ns@(n::int:_) = list (take (count ns) (drop n xs)) if listp xs&&cont ns; _ = catmap (nth xs) ns end end with ok (catmap (nth _) _) = 0; ok _ = 1; cont (n::int:ns) = ~thunkp ns&&(case ns of [] = 1; m::int:_ = cont ns if m==n+1; _ = 0 end); nth xs n = catch (cst []) [xs!n]; count ns = #dropwhile (\n::int -> n<0) ns end
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10
	<var> state 1
	<var>::string state 24
	<var>::matrix state 47
	<app> state 70
	() state 146
  state 1: #0 #1 #2 #3 #4 #10
	<var> state 2
	<var>::matrix state 3
	<app> state 4
  state 2: #10
  state 3: #0 #10
  state 4: #1 #2 #3 #4 #10
	<var> state 5
	<app> state 7
  state 5: #10
	<var> state 6
  state 6: #10
  state 7: #1 #2 #3 #4 #10
	<var> state 8
	, state 11
  state 8: #10
	<var> state 9
  state 9: #10
	<var> state 10
  state 10: #10
  state 11: #1 #2 #3 #4 #10
	<var> state 12
	<var>::int state 16
	<var>::matrix state 20
  state 12: #2 #4 #10
	<var> state 13
	<var>::int state 14
	<var>::matrix state 15
  state 13: #10
  state 14: #4 #10
  state 15: #2 #10
  state 16: #2 #3 #4 #10
	<var> state 17
	<var>::int state 18
	<var>::matrix state 19
  state 17: #3 #10
  state 18: #3 #4 #10
  state 19: #2 #3 #10
  state 20: #1 #2 #4 #10
	<var> state 21
	<var>::int state 22
	<var>::matrix state 23
  state 21: #1 #10
  state 22: #1 #4 #10
  state 23: #1 #2 #10
  state 24: #0 #1 #2 #3 #4 #7 #10
	<var> state 25
	<var>::matrix state 26
	<app> state 27
  state 25: #7 #10
  state 26: #0 #7 #10
  state 27: #1 #2 #3 #4 #7 #10
	<var> state 28
	<app> state 30
  state 28: #7 #10
	<var> state 29
  state 29: #7 #10
  state 30: #1 #2 #3 #4 #7 #10
	<var> state 31
	, state 34
  state 31: #7 #10
	<var> state 32
  state 32: #7 #10
	<var> state 33
  state 33: #7 #10
  state 34: #1 #2 #3 #4 #7 #10
	<var> state 35
	<var>::int state 39
	<var>::matrix state 43
  state 35: #2 #4 #7 #10
	<var> state 36
	<var>::int state 37
	<var>::matrix state 38
  state 36: #7 #10
  state 37: #4 #7 #10
  state 38: #2 #7 #10
  state 39: #2 #3 #4 #7 #10
	<var> state 40
	<var>::int state 41
	<var>::matrix state 42
  state 40: #3 #7 #10
  state 41: #3 #4 #7 #10
  state 42: #2 #3 #7 #10
  state 43: #1 #2 #4 #7 #10
	<var> state 44
	<var>::int state 45
	<var>::matrix state 46
  state 44: #1 #7 #10
  state 45: #1 #4 #7 #10
  state 46: #1 #2 #7 #10
  state 47: #0 #1 #2 #3 #4 #5 #6 #10
	<var> state 48
	<var>::matrix state 49
	<app> state 50
  state 48: #6 #10
  state 49: #0 #6 #10
  state 50: #1 #2 #3 #4 #5 #6 #10
	<var> state 51
	<app> state 53
  state 51: #6 #10
	<var> state 52
  state 52: #6 #10
  state 53: #1 #2 #3 #4 #5 #6 #10
	<var> state 54
	, state 57
  state 54: #6 #10
	<var> state 55
  state 55: #6 #10
	<var> state 56
  state 56: #6 #10
  state 57: #1 #2 #3 #4 #5 #6 #10
	<var> state 58
	<var>::int state 62
	<var>::matrix state 66
  state 58: #2 #4 #5 #6 #10
	<var> state 59
	<var>::int state 60
	<var>::matrix state 61
  state 59: #5 #6 #10
  state 60: #4 #5 #6 #10
  state 61: #2 #5 #6 #10
  state 62: #2 #3 #4 #5 #6 #10
	<var> state 63
	<var>::int state 64
	<var>::matrix state 65
  state 63: #3 #5 #6 #10
  state 64: #3 #4 #5 #6 #10
  state 65: #2 #3 #5 #6 #10
  state 66: #1 #2 #4 #5 #6 #10
	<var> state 67
	<var>::int state 68
	<var>::matrix state 69
  state 67: #1 #5 #6 #10
  state 68: #1 #4 #5 #6 #10
  state 69: #1 #2 #5 #6 #10
  state 70: #0 #1 #2 #3 #4 #9 #10
	<var> state 71
	<app> state 95
  state 71: #0 #1 #2 #3 #4 #10
	<var> state 72
  state 72: #0 #1 #2 #3 #4 #10
	<var> state 73
	<var>::matrix state 74
	<app> state 75
  state 73: #10
  state 74: #0 #10
  state 75: #1 #2 #3 #4 #10
	<var> state 76
	<app> state 78
  state 76: #10
	<var> state 77
  state 77: #10
  state 78: #1 #2 #3 #4 #10
	<var> state 79
	, state 82
  state 79: #10
	<var> state 80
  state 80: #10
	<var> state 81
  state 81: #10
  state 82: #1 #2 #3 #4 #10
	<var> state 83
	<var>::int state 87
	<var>::matrix state 91
  state 83: #2 #4 #10
	<var> state 84
	<var>::int state 85
	<var>::matrix state 86
  state 84: #10
  state 85: #4 #10
  state 86: #2 #10
  state 87: #2 #3 #4 #10
	<var> state 88
	<var>::int state 89
	<var>::matrix state 90
  state 88: #3 #10
  state 89: #3 #4 #10
  state 90: #2 #3 #10
  state 91: #1 #2 #4 #10
	<var> state 92
	<var>::int state 93
	<var>::matrix state 94
  state 92: #1 #10
  state 93: #1 #4 #10
  state 94: #1 #2 #10
  state 95: #0 #1 #2 #3 #4 #9 #10
	<var> state 96
	, state 121
  state 96: #0 #1 #2 #3 #4 #10
	<var> state 97
  state 97: #0 #1 #2 #3 #4 #10
	<var> state 98
  state 98: #0 #1 #2 #3 #4 #10
	<var> state 99
	<var>::matrix state 100
	<app> state 101
  state 99: #10
  state 100: #0 #10
  state 101: #1 #2 #3 #4 #10
	<var> state 102
	<app> state 104
  state 102: #10
	<var> state 103
  state 103: #10
  state 104: #1 #2 #3 #4 #10
	<var> state 105
	, state 108
  state 105: #10
	<var> state 106
  state 106: #10
	<var> state 107
  state 107: #10
  state 108: #1 #2 #3 #4 #10
	<var> state 109
	<var>::int state 113
	<var>::matrix state 117
  state 109: #2 #4 #10
	<var> state 110
	<var>::int state 111
	<var>::matrix state 112
  state 110: #10
  state 111: #4 #10
  state 112: #2 #10
  state 113: #2 #3 #4 #10
	<var> state 114
	<var>::int state 115
	<var>::matrix state 116
  state 114: #3 #10
  state 115: #3 #4 #10
  state 116: #2 #3 #10
  state 117: #1 #2 #4 #10
	<var> state 118
	<var>::int state 119
	<var>::matrix state 120
  state 118: #1 #10
  state 119: #1 #4 #10
  state 120: #1 #2 #10
  state 121: #0 #1 #2 #3 #4 #9 #10
	<var> state 122
  state 122: #0 #1 #2 #3 #4 #9 #10
	<var> state 123
  state 123: #0 #1 #2 #3 #4 #9 #10
	<var> state 124
	<var>::matrix state 125
	<app> state 126
  state 124: #9 #10
  state 125: #0 #9 #10
  state 126: #1 #2 #3 #4 #9 #10
	<var> state 127
	<app> state 129
  state 127: #9 #10
	<var> state 128
  state 128: #9 #10
  state 129: #1 #2 #3 #4 #9 #10
	<var> state 130
	, state 133
  state 130: #9 #10
	<var> state 131
  state 131: #9 #10
	<var> state 132
  state 132: #9 #10
  state 133: #1 #2 #3 #4 #9 #10
	<var> state 134
	<var>::int state 138
	<var>::matrix state 142
  state 134: #2 #4 #9 #10
	<var> state 135
	<var>::int state 136
	<var>::matrix state 137
  state 135: #9 #10
  state 136: #4 #9 #10
  state 137: #2 #9 #10
  state 138: #2 #3 #4 #9 #10
	<var> state 139
	<var>::int state 140
	<var>::matrix state 141
  state 139: #3 #9 #10
  state 140: #3 #4 #9 #10
  state 141: #2 #3 #9 #10
  state 142: #1 #2 #4 #9 #10
	<var> state 143
	<var>::int state 144
	<var>::matrix state 145
  state 143: #1 #9 #10
  state 144: #1 #4 #9 #10
  state 145: #1 #2 #9 #10
  state 146: #0 #1 #2 #3 #4 #8 #10
	<var> state 147
	<var>::matrix state 148
	<app> state 149
  state 147: #8 #10
  state 148: #0 #8 #10
  state 149: #1 #2 #3 #4 #8 #10
	<var> state 150
	<app> state 152
  state 150: #8 #10
	<var> state 151
  state 151: #8 #10
  state 152: #1 #2 #3 #4 #8 #10
	<var> state 153
	, state 156
  state 153: #8 #10
	<var> state 154
  state 154: #8 #10
	<var> state 155
  state 155: #8 #10
  state 156: #1 #2 #3 #4 #8 #10
	<var> state 157
	<var>::int state 161
	<var>::matrix state 165
  state 157: #2 #4 #8 #10
	<var> state 158
	<var>::int state 159
	<var>::matrix state 160
  state 158: #8 #10
  state 159: #4 #8 #10
  state 160: #2 #8 #10
  state 161: #2 #3 #4 #8 #10
	<var> state 162
	<var>::int state 163
	<var>::matrix state 164
  state 162: #3 #8 #10
  state 163: #3 #4 #8 #10
  state 164: #2 #3 #8 #10
  state 165: #1 #2 #4 #8 #10
	<var> state 166
	<var>::int state 167
	<var>::matrix state 168
  state 166: #1 #8 #10
  state 167: #1 #4 #8 #10
  state 168: #1 #2 #8 #10
}
{
  rule #0: list x::matrix = listmap (\i -> x!i) (0..#x-1)
  rule #1: list s::string = chars s
  rule #2: list () = []
  rule #3: list (x,xs) = accum [x] xs with accum ys (x,xs) = accum (x:ys) xs; accum ys x = __std__::reverse_onto [] (x:ys) end
  rule #4: list [] = []
  rule #5: list (x:xs) = accum [x] xs with accum ys (x:xs) = accum (x:ys) xs; accum ys [] = __std__::reverse_onto [] ys; accum ys xs = throw (bad_list_value xs) end
  state 0: #0 #1 #2 #3 #4 #5
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
	[] state 11
	() state 12
  state 1: #1
  state 2: #0
  state 3: #3 #5
	<app> state 4
  state 4: #3 #5
	: state 5
	, state 8
  state 5: #5
	<var> state 6
  state 6: #5
	<var> state 7
  state 7: #5
  state 8: #3
	<var> state 9
  state 9: #3
	<var> state 10
  state 10: #3
  state 11: #4
  state 12: #2
}
{
  rule #0: tuple x::matrix = tuple (list x)
  rule #1: tuple s::string = tuple (chars s)
  rule #2: tuple [] = ()
  rule #3: tuple (x:xs) = accum (t x) xs with t x@(_,_) = reverse x; t x = x; accum ys (x:xs) = accum (t x,ys) xs; accum ys [] = t ys; accum ys xs = throw (bad_list_value xs) end
  rule #4: tuple x@() = x
  rule #5: tuple x@(_,_) = x
  state 0: #0 #1 #2 #3 #4 #5
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
	[] state 11
	() state 12
  state 1: #1
  state 2: #0
  state 3: #3 #5
	<app> state 4
  state 4: #3 #5
	: state 5
	, state 8
  state 5: #3
	<var> state 6
  state 6: #3
	<var> state 7
  state 7: #3
  state 8: #5
	<var> state 9
  state 9: #5
	<var> state 10
  state 10: #5
  state 11: #2
  state 12: #4
}
{
  rule #0: all p x::matrix = __C::matrix_all p x
  rule #1: all p s::string = all p (chars s)
  rule #2: all p [] = 1
  rule #3: all p xs@(_:_) = tick xs 1 with tick _ 0 = 0; tick [] a = a; tick (x:xs) a = tick xs (a&&p x); tick xs a = a&&all p xs end
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: any p x::matrix = __C::matrix_any p x
  rule #1: any p s::string = any p (chars s)
  rule #2: any p [] = 0
  rule #3: any p (x:xs) = p x||any p xs
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: cat [] = []
  rule #1: cat (xs::list:yss) = aux xs with aux xs = cat_pre len_pre xs with cat_pre 0 _ = catted_tail; cat_pre n::int (x:xs) = x:cat_pre (n-1) xs end when len_pre@_ catted_tail = skip_ahead 0 xs end; skip_ahead n::int [] = n (cat yss); skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096; skip_ahead n::int (x:xs) = n (x:aux xs&) if thunkp xs; skip_ahead n::int (x:xs) = skip_ahead (n+1) xs; skip_ahead n::int xs = n (xs+cat yss) end
  state 0: #0 #1
	<app> state 1
	[] state 6
  state 1: #1
	<app> state 2
  state 2: #1
	: state 3
  state 3: #1
	<var> state 4
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0
}
{
  rule #0: do f x::matrix = __C::matrix_do f x
  rule #1: do f s::string = do f (chars s)
  rule #2: do f [] = ()
  rule #3: do f (x:xs) = f x$$do f xs
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: map f x::matrix = __C::matrix_map f x
  rule #1: map f s::string = map f (chars s)
  rule #2: map f [] = []
  rule #3: map f xs@(_:_) = aux xs with aux xs = map_pre len_pre xs with map_pre 0 _ = mapped_tail; map_pre n::int (x:xs) = f x:map_pre (n-1) xs end when len_pre@_ mapped_tail = skip_ahead 0 xs end; skip_ahead n::int [] = n []; skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096; skip_ahead n::int (x:xs) = n (f x:aux xs&) if thunkp xs; skip_ahead n::int (x:xs) = skip_ahead (n+1) xs; skip_ahead n::int xs = n (map f xs) end
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: reverse x::matrix = rowrev (colrev x)
  rule #1: reverse s::string = strcat (reverse (chars s))
  rule #2: reverse () = ()
  rule #3: reverse (x,xs) = accum x xs with accum ys (x,xs) = accum (x,ys) xs; accum ys x = x,ys end
  rule #4: reverse [] = []
  rule #5: reverse xs@(_:_) = reverse_onto [] xs
  state 0: #0 #1 #2 #3 #4 #5
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
	[] state 11
	() state 12
  state 1: #1
  state 2: #0
  state 3: #3 #5
	<app> state 4
  state 4: #3 #5
	: state 5
	, state 8
  state 5: #5
	<var> state 6
  state 6: #5
	<var> state 7
  state 7: #5
  state 8: #3
	<var> state 9
  state 9: #3
	<var> state 10
  state 10: #3
  state 11: #4
  state 12: #2
}
{
  rule #0: subseq x::matrix a::int b::int = __C::matrix_slice (rowvector x) 0 a 0 b
  rule #1: subseq s::string a::int b::int = substr s a (b-a+1)
  rule #2: subseq [] a::int b::int = []
  rule #3: subseq xs@(_:_) a::int b::int = take (b-a+1) (drop a xs) with take 0 xs = []; take m::int xs = take_pre len_pre xs with take_pre 0 _ = front_tail; take_pre n::int (x:xs) = x:take_pre (n-1) xs end when len_pre@_ front_tail = skip_ahead m 0 xs end; skip_ahead m::int n::int xs = n [] if m<=0||xs===[]; skip_ahead m::int n::int (x:xs) = skip_ahead (m-1) (n+1) xs if n<4096; skip_ahead m::int n::int xs = n (take m xs) end
  rule #4: subseq x a b = slice x (a..b)
  state 0: #0 #1 #2 #3 #4
	<var> state 1
	<var>::string state 4
	<var>::matrix state 10
	<app> state 16
	[] state 35
  state 1: #4
	<var> state 2
  state 2: #4
	<var> state 3
  state 3: #4
  state 4: #1 #4
	<var> state 5
	<var>::int state 7
  state 5: #4
	<var> state 6
  state 6: #4
  state 7: #1 #4
	<var> state 8
	<var>::int state 9
  state 8: #4
  state 9: #1 #4
  state 10: #0 #4
	<var> state 11
	<var>::int state 13
  state 11: #4
	<var> state 12
  state 12: #4
  state 13: #0 #4
	<var> state 14
	<var>::int state 15
  state 14: #4
  state 15: #0 #4
  state 16: #3 #4
	<var> state 17
	<app> state 21
  state 17: #4
	<var> state 18
  state 18: #4
	<var> state 19
  state 19: #4
	<var> state 20
  state 20: #4
  state 21: #3 #4
	<var> state 22
	: state 27
  state 22: #4
	<var> state 23
  state 23: #4
	<var> state 24
  state 24: #4
	<var> state 25
  state 25: #4
	<var> state 26
  state 26: #4
  state 27: #3 #4
	<var> state 28
  state 28: #3 #4
	<var> state 29
  state 29: #3 #4
	<var> state 30
	<var>::int state 32
  state 30: #4
	<var> state 31
  state 31: #4
  state 32: #3 #4
	<var> state 33
	<var>::int state 34
  state 33: #4
  state 34: #3 #4
  state 35: #2 #4
	<var> state 36
	<var>::int state 38
  state 36: #4
	<var> state 37
  state 37: #4
  state 38: #2 #4
	<var> state 39
	<var>::int state 40
  state 39: #4
  state 40: #2 #4
}
{
  rule #0: __std__::reverse_onto base [] = base
  rule #1: __std__::reverse_onto base (x:xs) = __std__::reverse_onto (x:base) xs
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<app> state 2
	[] state 7
  state 2: #1
	<app> state 3
  state 3: #1
	: state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0
}
{
  rule #0: cycle x::matrix = cycle (list x)
  rule #1: cycle s::string = cycle (chars s)
  rule #2: cycle ys@(x:xs) = x:(xs+cycle ys)&
  state 0: #0 #1 #2
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
  state 1: #1
  state 2: #0
  state 3: #2
	<app> state 4
  state 4: #2
	: state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
}
{
  rule #0: cyclen n::int x::matrix = cyclen n (list x) if ~null x
  rule #1: cyclen n::int s::string = cyclen n (chars s) if ~null s
  rule #2: cyclen n::int (x:xs) = [] if n<=0
  rule #3: cyclen n::int (x:xs) = accum [] n with accum ys n::int = cat ys+take n xs if n<=m; accum ys n::int = accum (xs:ys) (n-m) end when xs = x:xs; m::int = #xs end if rlistp xs
  state 0: #0 #1 #2 #3
	<var>::int state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
  state 2: #1
  state 3: #0
  state 4: #2 #3
	<app> state 5
  state 5: #2 #3
	: state 6
  state 6: #2 #3
	<var> state 7
  state 7: #2 #3
	<var> state 8
  state 8: #2 #3
}
{
  rule #0: drop k::int x::matrix = x!!(k..#x-1)
  rule #1: drop n::int s::string = substr s n 2147483647
  rule #2: drop n::int [] = []
  rule #3: drop n::int ys@(x:xs) = drop (n-1) xs if n>1
  rule #4: drop n::int ys@(x:xs) = xs if n==1
  rule #5: drop n::int ys@(x:xs) = ys
  state 0: #0 #1 #2 #3 #4 #5
	<var>::int state 1
  state 1: #0 #1 #2 #3 #4 #5
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3 #4 #5
	<app> state 5
  state 5: #3 #4 #5
	: state 6
  state 6: #3 #4 #5
	<var> state 7
  state 7: #3 #4 #5
	<var> state 8
  state 8: #3 #4 #5
  state 9: #2
}
{
  rule #0: dropwhile p x::matrix = __C::matrix_dropwhile p x
  rule #1: dropwhile p s::string = strcat (dropwhile p (chars s))
  rule #2: dropwhile p [] = []
  rule #3: dropwhile p ys@(x:xs) = dropwhile p xs if p x
  rule #4: dropwhile p ys@(x:xs) = ys
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3 #4
	<app> state 5
  state 5: #3 #4
	: state 6
  state 6: #3 #4
	<var> state 7
  state 7: #3 #4
	<var> state 8
  state 8: #3 #4
  state 9: #2
}
{
  rule #0: filter p x::matrix = __C::matrix_filter p x
  rule #1: filter p s::string = strcat (filter p (chars s))
  rule #2: filter p [] = []
  rule #3: filter p xs@(_:_) = aux xs with aux xs = filter_pre len_pre xs with filter_pre 0 _ = filtered_tail; filter_pre n::int (x:xs) = add p x (filter_pre (n-1) xs) end when len_pre@_ filtered_tail = skip_ahead 0 xs end; skip_ahead n::int [] = n []; skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096; skip_ahead n::int (x:xs) = n (add p x (aux xs&)) if thunkp xs; skip_ahead n::int (x:xs) = skip_ahead (n+1) xs; skip_ahead n::int xs = n (filter p xs); add p x hs = if p x then x:hs else hs end
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: foldl f a x::matrix = __C::matrix_foldl f a x
  rule #1: foldl f a s::string = foldl f a (chars s)
  rule #2: foldl f a [] = a
  rule #3: foldl f a (x:xs) = foldl f (f a x) xs
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
  state 2: #0 #1 #2 #3
	<var>::string state 3
	<var>::matrix state 4
	<app> state 5
	[] state 10
  state 3: #1
  state 4: #0
  state 5: #3
	<app> state 6
  state 6: #3
	: state 7
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #2
}
{
  rule #0: foldl1 f x::matrix = __C::matrix_foldl1 f x if ~null x
  rule #1: foldl1 f s::string = foldl1 f (chars s)
  rule #2: foldl1 f (x:xs) = foldl f x xs
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
  state 2: #1
  state 3: #0
  state 4: #2
	<app> state 5
  state 5: #2
	: state 6
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
}
{
  rule #0: foldr f a x::matrix = __C::matrix_foldr f a x
  rule #1: foldr f a s::string = foldr f a (chars s)
  rule #2: foldr f a [] = a
  rule #3: foldr f a xs@(_:_) = aux xs with aux xs = fold_pre len_pre xs with fold_pre 0 _ = folded_tail; fold_pre n::int (x:xs) = f x (fold_pre (n-1) xs) end when len_pre@_ folded_tail = skip_ahead 0 xs end; skip_ahead n::int [] = n a; skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096; skip_ahead n::int (x:xs) = n (f x (aux xs&)) if thunkp xs; skip_ahead n::int (x:xs) = skip_ahead (n+1) xs; skip_ahead n::int xs = n (foldr f a xs) end
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
  state 2: #0 #1 #2 #3
	<var>::string state 3
	<var>::matrix state 4
	<app> state 5
	[] state 10
  state 3: #1
  state 4: #0
  state 5: #3
	<app> state 6
  state 6: #3
	: state 7
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #2
}
{
  rule #0: foldr1 f x::matrix = __C::matrix_foldr1 f x if ~null x
  rule #1: foldr1 f s::string = foldr1 f (chars s)
  rule #2: foldr1 f [x] = x
  rule #3: foldr1 f xs@(_:_) = aux xs with aux xs = fold_pre len_pre xs with fold_pre 0 _ = folded_tail; fold_pre n::int (x:xs) = f x (fold_pre (n-1) xs) end when len_pre@_ folded_tail = skip_ahead 0 xs end; skip_ahead n::int ys@(_:xs) = n (aux ys) if n==4096; skip_ahead n::int ys@(_:xs) = n (foldr1 f ys&) if thunkp xs; skip_ahead n::int xs = case xs of [x] = n x; x:xs = skip_ahead (n+1) xs; _ = n (foldr1 f xs) end end
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
  state 2: #1
  state 3: #0
  state 4: #2 #3
	<app> state 5
  state 5: #2 #3
	: state 6
  state 6: #2 #3
	<var> state 7
  state 7: #2 #3
	<var> state 8
	[] state 9
  state 8: #3
  state 9: #2 #3
}
{
  rule #0: head x::matrix = x!0 if ~null x
  rule #1: head s::string = s!0 if ~null s
  rule #2: head (x:xs) = x
  state 0: #0 #1 #2
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
  state 1: #1
  state 2: #0
  state 3: #2
	<app> state 4
  state 4: #2
	: state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
}
{
  rule #0: init x::matrix = x!!(0..#x-2) if ~null x
  rule #1: init s::string = substr s 0 (#s-1) if ~null s
  rule #2: init [_] = []
  rule #3: init xs@(_:_) = aux xs with aux xs = init_pre len_pre xs with init_pre 0 _ = chopped_tail; init_pre n::int (x:xs) = x:init_pre (n-1) xs end when len_pre@_ chopped_tail = skip_ahead 0 xs end; skip_ahead n::int ys@(x:xs) = n (aux ys) if n==4096; skip_ahead n::int ys@(x:xs) = n (init ys&) if thunkp xs; skip_ahead n::int xs = case xs of [_] = n []; _:xs = skip_ahead (n+1) xs; _ = n (init xs) end end
  state 0: #0 #1 #2 #3
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
  state 1: #1
  state 2: #0
  state 3: #2 #3
	<app> state 4
  state 4: #2 #3
	: state 5
  state 5: #2 #3
	<var> state 6
  state 6: #2 #3
	<var> state 7
	[] state 8
  state 7: #3
  state 8: #2 #3
}
{
  rule #0: last x::matrix = x!(#x-1) if ~null x
  rule #1: last s::string = s!(#s-1) if ~null s
  rule #2: last [x] = x
  rule #3: last (x:xs) = last xs
  state 0: #0 #1 #2 #3
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
  state 1: #1
  state 2: #0
  state 3: #2 #3
	<app> state 4
  state 4: #2 #3
	: state 5
  state 5: #2 #3
	<var> state 6
  state 6: #2 #3
	<var> state 7
	[] state 8
  state 7: #3
  state 8: #2 #3
}
{
  rule #0: scanl f a x::matrix = __C::matrix_scanl f a x
  rule #1: scanl f a s::string = scanl f a (chars s)
  rule #2: scanl f a [] = [a]
  rule #3: scanl f a xs@(_:_) = tick a [] xs with tick a zs (x:xs) = __std__::reverse_onto (tick (f a x) xs&) (a:zs) if thunkp xs; tick a zs (x:xs) = tick (f a x) (a:zs) xs; tick a zs [] = __std__::reverse_onto [a] zs; tick a zs xs = __std__::reverse_onto (scanl f a xs) zs end
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
  state 2: #0 #1 #2 #3
	<var>::string state 3
	<var>::matrix state 4
	<app> state 5
	[] state 10
  state 3: #1
  state 4: #0
  state 5: #3
	<app> state 6
  state 6: #3
	: state 7
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #2
}
{
  rule #0: scanl1 f x::matrix = __C::matrix_scanl1 f x
  rule #1: scanl1 f s::string = scanl1 f (chars s)
  rule #2: scanl1 f [] = []
  rule #3: scanl1 f (x:xs) = scanl f x xs
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: scanr f a x::matrix = __C::matrix_scanr f a x
  rule #1: scanr f a s::string = scanr f a (chars s)
  rule #2: scanr f a [] = [a]
  rule #3: scanr f a xs@(_:_) = tick [] xs with tick zs (x:xs) = tack zs us when ys = scanr f a xs&; y = (case ys of y:_ = y; scanr _ _ ys = throw (bad_list_value ys); _ = throw (bad_list_value ys) end)&; us = f x y:ys end if thunkp xs; tick zs (x:xs) = tack zs (f x (y when y:_ = ys end)&:ys when ys = scanr f a xs& end) if thunkp xs; tick zs (x:xs) = tick (x:zs) xs; tick zs [] = tack zs [a]; tick zs xs = throw (bad_list_value xs); tack (x:xs) ys = tack xs (f x y:ys) when y:_ = ys end; tack [] ys = ys end
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
  state 2: #0 #1 #2 #3
	<var>::string state 3
	<var>::matrix state 4
	<app> state 5
	[] state 10
  state 3: #1
  state 4: #0
  state 5: #3
	<app> state 6
  state 6: #3
	: state 7
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #2
}
{
  rule #0: scanr1 f x::matrix = __C::matrix_scanr1 f x
  rule #1: scanr1 f s::string = scanr1 f (chars s)
  rule #2: scanr1 f [] = []
  rule #3: scanr1 f [x] = [x]
  rule #4: scanr1 f xs@(_:_) = tick [] xs with tick zs (x:xs) = tack zs us when ys = scanr1 f xs&; y = (case ys of y:_ = y; scanr1 _ ys = throw (bad_list_value ys); _ = throw (bad_list_value ys) end)&; us = f x y:ys end if thunkp xs; tick zs xs = case xs of [x] = tack zs [x]; x:xs = tick (x:zs) xs; _ = throw (bad_list_value xs) end; tack (x:xs) ys = tack xs (f x y:ys) when y:_ = ys end; tack [] ys = ys end
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 10
  state 2: #1
  state 3: #0
  state 4: #3 #4
	<app> state 5
  state 5: #3 #4
	: state 6
  state 6: #3 #4
	<var> state 7
  state 7: #3 #4
	<var> state 8
	[] state 9
  state 8: #4
  state 9: #3 #4
  state 10: #2
}
{
  rule #0: take k::int x::matrix = x!!(0..k-1)
  rule #1: take n::int s::string = substr s 0 n
  rule #2: take m::int [] = []
  rule #3: take m::int xs@(_:_) = aux m xs with aux 0 xs = []; aux m::int xs = take_pre len_pre xs with take_pre 0 _ = front_tail; take_pre n::int (x:xs) = x:take_pre (n-1) xs end when len_pre@_ front_tail = skip_ahead m 0 xs end; skip_ahead m::int n::int [] = n []; skip_ahead m::int n::int xs@(_:_) = n (aux m xs) if n==4096; skip_ahead m::int n::int (x:xs) = n [] if m<=0; skip_ahead m::int n::int (x:xs) = n (x:aux (m-1) xs&) if thunkp xs; skip_ahead m::int n::int (x:xs) = skip_ahead (m-1) (n+1) xs; skip_ahead m::int n::int xs = n (take m xs) end
  state 0: #0 #1 #2 #3
	<var>::int state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: takewhile p x::matrix = __C::matrix_takewhile p x
  rule #1: takewhile p s::string = strcat (takewhile p (chars s))
  rule #2: takewhile p [] = []
  rule #3: takewhile p xs@(_:_) = aux xs with aux xs = take_pre len_pre xs with take_pre 0 _ = front_tail; take_pre n::int (x:xs) = x:take_pre (n-1) xs end when len_pre@_ front_tail = skip_ahead 0 xs end; skip_ahead n::int [] = n []; skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096; skip_ahead n::int (x:xs) = n [] if ~p x; skip_ahead n::int (x:xs) = n (x:aux xs&) if thunkp xs; skip_ahead n::int (x:xs) = skip_ahead (n+1) xs; skip_ahead n::int xs = n (takewhile p xs) end
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var>::string state 2
	<var>::matrix state 3
	<app> state 4
	[] state 9
  state 2: #1
  state 3: #0
  state 4: #3
	<app> state 5
  state 5: #3
	: state 6
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #2
}
{
  rule #0: tail x::matrix = x!!(1..#x-1) if ~null x
  rule #1: tail s::string = substr s 1 (#s-1) if ~null s
  rule #2: tail (x:xs) = xs
  state 0: #0 #1 #2
	<var>::string state 1
	<var>::matrix state 2
	<app> state 3
  state 1: #1
  state 2: #0
  state 3: #2
	<app> state 4
  state 4: #2
	: state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
}
{
  rule #0: zipwith f x::matrix y::matrix = __C::matrix_zipwith f x y
  rule #1: zipwith f s::string t::string = zipwith f (chars s) (chars t)
  rule #2: zipwith f s t::string = zipwith f s (chars t)
  rule #3: zipwith f s::string t = zipwith f (chars s) t
  rule #4: zipwith f [] _ = []
  rule #5: zipwith f _ [] = []
  rule #6: zipwith f xs@(_:_) ys@(_:_) = __std__::zip f [] (zipwith f) xs ys
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5 #6
	<var> state 2
	<var>::string state 5
	<var>::matrix state 9
	<app> state 13
	[] state 34
  state 2: #2 #5
	<var>::string state 3
	[] state 4
  state 3: #2
  state 4: #5
  state 5: #1 #2 #3 #5
	<var> state 6
	<var>::string state 7
	[] state 8
  state 6: #3
  state 7: #1 #2 #3
  state 8: #3 #5
  state 9: #0 #2 #5
	<var>::string state 10
	<var>::matrix state 11
	[] state 12
  state 10: #2
  state 11: #0
  state 12: #5
  state 13: #2 #5 #6
	<var> state 14
	<app> state 18
  state 14: #2 #5
	<var> state 15
  state 15: #2 #5
	<var>::string state 16
	[] state 17
  state 16: #2
  state 17: #5
  state 18: #2 #5 #6
	<var> state 19
	: state 24
  state 19: #2 #5
	<var> state 20
  state 20: #2 #5
	<var> state 21
  state 21: #2 #5
	<var>::string state 22
	[] state 23
  state 22: #2
  state 23: #5
  state 24: #2 #5 #6
	<var> state 25
  state 25: #2 #5 #6
	<var> state 26
  state 26: #2 #5 #6
	<var>::string state 27
	<app> state 28
	[] state 33
  state 27: #2
  state 28: #6
	<app> state 29
  state 29: #6
	: state 30
  state 30: #6
	<var> state 31
  state 31: #6
	<var> state 32
  state 32: #6
  state 33: #5
  state 34: #2 #4 #5
	<var> state 35
	<var>::string state 36
	[] state 37
  state 35: #4
  state 36: #2 #4
  state 37: #4 #5
}
{
  rule #0: zipwith3 f x::matrix y::matrix z::matrix = __C::matrix_zipwith3 f x y z
  rule #1: zipwith3 f s::string t::string u::string = zipwith3 f (chars s) (chars t) (chars u)
  rule #2: zipwith3 f s::string t::string u = zipwith3 f (chars s) (chars t) u
  rule #3: zipwith3 f s::string t u::string = zipwith3 f (chars s) t (chars u)
  rule #4: zipwith3 f s::string t u = zipwith3 f (chars s) t u
  rule #5: zipwith3 f s t::string u::string = zipwith3 f s (chars t) (chars u)
  rule #6: zipwith3 f s t::string u = zipwith3 f s (chars t) u
  rule #7: zipwith3 f s t u::string = zipwith3 f s t (chars u)
  rule #8: zipwith3 f [] _ _ = []
  rule #9: zipwith3 f _ [] _ = []
  rule #10: zipwith3 f _ _ [] = []
  rule #11: zipwith3 f xs@(_:_) ys@(_:_) zs@(_:_) = __std__::zip3 f [] (zipwith3 f) xs ys zs
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11
	<var> state 2
	<var>::string state 14
	<var>::matrix state 27
	<app> state 43
	[] state 107
  state 2: #5 #6 #7 #9 #10
	<var> state 3
	<var>::string state 6
	[] state 10
  state 3: #7 #10
	<var>::string state 4
	[] state 5
  state 4: #7
  state 5: #10
  state 6: #5 #6 #7 #10
	<var> state 7
	<var>::string state 8
	[] state 9
  state 7: #6
  state 8: #5 #6 #7
  state 9: #6 #10
  state 10: #7 #9 #10
	<var> state 11
	<var>::string state 12
	[] state 13
  state 11: #9
  state 12: #7 #9
  state 13: #9 #10
  state 14: #1 #2 #3 #4 #5 #6 #7 #9 #10
	<var> state 15
	<var>::string state 19
	[] state 23
  state 15: #3 #4 #7 #10
	<var> state 16
	<var>::string state 17
	[] state 18
  state 16: #4
  state 17: #3 #4 #7
  state 18: #4 #10
  state 19: #1 #2 #3 #4 #5 #6 #7 #10
	<var> state 20
	<var>::string state 21
	[] state 22
  state 20: #2 #4 #6
  state 21: #1 #2 #3 #4 #5 #6 #7
  state 22: #2 #4 #6 #10
  state 23: #3 #4 #7 #9 #10
	<var> state 24
	<var>::string state 25
	[] state 26
  state 24: #4 #9
  state 25: #3 #4 #7 #9
  state 26: #4 #9 #10
  state 27: #0 #5 #6 #7 #9 #10
	<var> state 28
	<var>::string state 31
	<var>::matrix state 35
	[] state 39
  state 28: #7 #10
	<var>::string state 29
	[] state 30
  state 29: #7
  state 30: #10
  state 31: #5 #6 #7 #10
	<var> state 32
	<var>::string state 33
	[] state 34
  state 32: #6
  state 33: #5 #6 #7
  state 34: #6 #10
  state 35: #0 #7 #10
	<var>::string state 36
	<var>::matrix state 37
	[] state 38
  state 36: #7
  state 37: #0
  state 38: #10
  state 39: #7 #9 #10
	<var> state 40
	<var>::string state 41
	[] state 42
  state 40: #9
  state 41: #7 #9
  state 42: #9 #10
  state 43: #5 #6 #7 #9 #10 #11
	<var> state 44
	<app> state 57
  state 44: #5 #6 #7 #9 #10
	<var> state 45
  state 45: #5 #6 #7 #9 #10
	<var> state 46
	<var>::string state 49
	[] state 53
  state 46: #7 #10
	<var>::string state 47
	[] state 48
  state 47: #7
  state 48: #10
  state 49: #5 #6 #7 #10
	<var> state 50
	<var>::string state 51
	[] state 52
  state 50: #6
  state 51: #5 #6 #7
  state 52: #6 #10
  state 53: #7 #9 #10
	<var> state 54
	<var>::string state 55
	[] state 56
  state 54: #9
  state 55: #7 #9
  state 56: #9 #10
  state 57: #5 #6 #7 #9 #10 #11
	<var> state 58
	: state 72
  state 58: #5 #6 #7 #9 #10
	<var> state 59
  state 59: #5 #6 #7 #9 #10
	<var> state 60
  state 60: #5 #6 #7 #9 #10
	<var> state 61
	<var>::string state 64
	[] state 68
  state 61: #7 #10
	<var>::string state 62
	[] state 63
  state 62: #7
  state 63: #10
  state 64: #5 #6 #7 #10
	<var> state 65
	<var>::string state 66
	[] state 67
  state 65: #6
  state 66: #5 #6 #7
  state 67: #6 #10
  state 68: #7 #9 #10
	<var> state 69
	<var>::string state 70
	[] state 71
  state 69: #9
  state 70: #7 #9
  state 71: #9 #10
  state 72: #5 #6 #7 #9 #10 #11
	<var> state 73
  state 73: #5 #6 #7 #9 #10 #11
	<var> state 74
  state 74: #5 #6 #7 #9 #10 #11
	<var> state 75
	<var>::string state 78
	<app> state 82
	[] state 103
  state 75: #7 #10
	<var>::string state 76
	[] state 77
  state 76: #7
  state 77: #10
  state 78: #5 #6 #7 #10
	<var> state 79
	<var>::string state 80
	[] state 81
  state 79: #6
  state 80: #5 #6 #7
  state 81: #6 #10
  state 82: #7 #10 #11
	<var> state 83
	<app> state 87
  state 83: #7 #10
	<var> state 84
  state 84: #7 #10
	<var>::string state 85
	[] state 86
  state 85: #7
  state 86: #10
  state 87: #7 #10 #11
	<var> state 88
	: state 93
  state 88: #7 #10
	<var> state 89
  state 89: #7 #10
	<var> state 90
  state 90: #7 #10
	<var>::string state 91
	[] state 92
  state 91: #7
  state 92: #10
  state 93: #7 #10 #11
	<var> state 94
  state 94: #7 #10 #11
	<var> state 95
  state 95: #7 #10 #11
	<var>::string state 96
	<app> state 97
	[] state 102
  state 96: #7
  state 97: #11
	<app> state 98
  state 98: #11
	: state 99
  state 99: #11
	<var> state 100
  state 100: #11
	<var> state 101
  state 101: #11
  state 102: #10
  state 103: #7 #9 #10
	<var> state 104
	<var>::string state 105
	[] state 106
  state 104: #9
  state 105: #7 #9
  state 106: #9 #10
  state 107: #5 #6 #7 #8 #9 #10
	<var> state 108
	<var>::string state 112
	[] state 116
  state 108: #7 #8 #10
	<var> state 109
	<var>::string state 110
	[] state 111
  state 109: #8
  state 110: #7 #8
  state 111: #8 #10
  state 112: #5 #6 #7 #8 #10
	<var> state 113
	<var>::string state 114
	[] state 115
  state 113: #6 #8
  state 114: #5 #6 #7 #8
  state 115: #6 #8 #10
  state 116: #7 #8 #9 #10
	<var> state 117
	<var>::string state 118
	[] state 119
  state 117: #8 #9
  state 118: #7 #8 #9
  state 119: #8 #9 #10
}
{
  rule #0: zip x::matrix y::matrix = zipwith (,) x y
  rule #1: zip s::string t::string = zip (chars s) (chars t)
  rule #2: zip s t::string = zip s (chars t)
  rule #3: zip s::string t = zip (chars s) t
  rule #4: zip [] _ = []
  rule #5: zip _ [] = []
  rule #6: zip xs@(_:_) ys@(_:_) = __std__::zip (,) [] zip xs ys
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var> state 1
	<var>::string state 4
	<var>::matrix state 8
	<app> state 12
	[] state 33
  state 1: #2 #5
	<var>::string state 2
	[] state 3
  state 2: #2
  state 3: #5
  state 4: #1 #2 #3 #5
	<var> state 5
	<var>::string state 6
	[] state 7
  state 5: #3
  state 6: #1 #2 #3
  state 7: #3 #5
  state 8: #0 #2 #5
	<var>::string state 9
	<var>::matrix state 10
	[] state 11
  state 9: #2
  state 10: #0
  state 11: #5
  state 12: #2 #5 #6
	<var> state 13
	<app> state 17
  state 13: #2 #5
	<var> state 14
  state 14: #2 #5
	<var>::string state 15
	[] state 16
  state 15: #2
  state 16: #5
  state 17: #2 #5 #6
	<var> state 18
	: state 23
  state 18: #2 #5
	<var> state 19
  state 19: #2 #5
	<var> state 20
  state 20: #2 #5
	<var>::string state 21
	[] state 22
  state 21: #2
  state 22: #5
  state 23: #2 #5 #6
	<var> state 24
  state 24: #2 #5 #6
	<var> state 25
  state 25: #2 #5 #6
	<var>::string state 26
	<app> state 27
	[] state 32
  state 26: #2
  state 27: #6
	<app> state 28
  state 28: #6
	: state 29
  state 29: #6
	<var> state 30
  state 30: #6
	<var> state 31
  state 31: #6
  state 32: #5
  state 33: #2 #4 #5
	<var> state 34
	<var>::string state 35
	[] state 36
  state 34: #4
  state 35: #2 #4
  state 36: #4 #5
}
{
  rule #0: zip3 x::matrix y::matrix z::matrix = zipwith3 (\x y z -> x,y,z) x y z
  rule #1: zip3 s::string t::string u::string = zip3 (chars s) (chars t) (chars u)
  rule #2: zip3 s::string t::string u = zip3 (chars s) (chars t) u
  rule #3: zip3 s::string t u::string = zip3 (chars s) t (chars u)
  rule #4: zip3 s::string t u = zip3 (chars s) t u
  rule #5: zip3 s t::string u::string = zip3 s (chars t) (chars u)
  rule #6: zip3 s t::string u = zip3 s (chars t) u
  rule #7: zip3 s t u::string = zip3 s t (chars u)
  rule #8: zip3 [] _ _ = []
  rule #9: zip3 _ [] _ = []
  rule #10: zip3 _ _ [] = []
  rule #11: zip3 xs@(_:_) ys@(_:_) zs@(_:_) = __std__::zip3 comma [] zip3 xs ys zs with comma x y z = x,y,z end
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11
	<var> state 1
	<var>::string state 13
	<var>::matrix state 26
	<app> state 42
	[] state 106
  state 1: #5 #6 #7 #9 #10
	<var> state 2
	<var>::string state 5
	[] state 9
  state 2: #7 #10
	<var>::string state 3
	[] state 4
  state 3: #7
  state 4: #10
  state 5: #5 #6 #7 #10
	<var> state 6
	<var>::string state 7
	[] state 8
  state 6: #6
  state 7: #5 #6 #7
  state 8: #6 #10
  state 9: #7 #9 #10
	<var> state 10
	<var>::string state 11
	[] state 12
  state 10: #9
  state 11: #7 #9
  state 12: #9 #10
  state 13: #1 #2 #3 #4 #5 #6 #7 #9 #10
	<var> state 14
	<var>::string state 18
	[] state 22
  state 14: #3 #4 #7 #10
	<var> state 15
	<var>::string state 16
	[] state 17
  state 15: #4
  state 16: #3 #4 #7
  state 17: #4 #10
  state 18: #1 #2 #3 #4 #5 #6 #7 #10
	<var> state 19
	<var>::string state 20
	[] state 21
  state 19: #2 #4 #6
  state 20: #1 #2 #3 #4 #5 #6 #7
  state 21: #2 #4 #6 #10
  state 22: #3 #4 #7 #9 #10
	<var> state 23
	<var>::string state 24
	[] state 25
  state 23: #4 #9
  state 24: #3 #4 #7 #9
  state 25: #4 #9 #10
  state 26: #0 #5 #6 #7 #9 #10
	<var> state 27
	<var>::string state 30
	<var>::matrix state 34
	[] state 38
  state 27: #7 #10
	<var>::string state 28
	[] state 29
  state 28: #7
  state 29: #10
  state 30: #5 #6 #7 #10
	<var> state 31
	<var>::string state 32
	[] state 33
  state 31: #6
  state 32: #5 #6 #7
  state 33: #6 #10
  state 34: #0 #7 #10
	<var>::string state 35
	<var>::matrix state 36
	[] state 37
  state 35: #7
  state 36: #0
  state 37: #10
  state 38: #7 #9 #10
	<var> state 39
	<var>::string state 40
	[] state 41
  state 39: #9
  state 40: #7 #9
  state 41: #9 #10
  state 42: #5 #6 #7 #9 #10 #11
	<var> state 43
	<app> state 56
  state 43: #5 #6 #7 #9 #10
	<var> state 44
  state 44: #5 #6 #7 #9 #10
	<var> state 45
	<var>::string state 48
	[] state 52
  state 45: #7 #10
	<var>::string state 46
	[] state 47
  state 46: #7
  state 47: #10
  state 48: #5 #6 #7 #10
	<var> state 49
	<var>::string state 50
	[] state 51
  state 49: #6
  state 50: #5 #6 #7
  state 51: #6 #10
  state 52: #7 #9 #10
	<var> state 53
	<var>::string state 54
	[] state 55
  state 53: #9
  state 54: #7 #9
  state 55: #9 #10
  state 56: #5 #6 #7 #9 #10 #11
	<var> state 57
	: state 71
  state 57: #5 #6 #7 #9 #10
	<var> state 58
  state 58: #5 #6 #7 #9 #10
	<var> state 59
  state 59: #5 #6 #7 #9 #10
	<var> state 60
	<var>::string state 63
	[] state 67
  state 60: #7 #10
	<var>::string state 61
	[] state 62
  state 61: #7
  state 62: #10
  state 63: #5 #6 #7 #10
	<var> state 64
	<var>::string state 65
	[] state 66
  state 64: #6
  state 65: #5 #6 #7
  state 66: #6 #10
  state 67: #7 #9 #10
	<var> state 68
	<var>::string state 69
	[] state 70
  state 68: #9
  state 69: #7 #9
  state 70: #9 #10
  state 71: #5 #6 #7 #9 #10 #11
	<var> state 72
  state 72: #5 #6 #7 #9 #10 #11
	<var> state 73
  state 73: #5 #6 #7 #9 #10 #11
	<var> state 74
	<var>::string state 77
	<app> state 81
	[] state 102
  state 74: #7 #10
	<var>::string state 75
	[] state 76
  state 75: #7
  state 76: #10
  state 77: #5 #6 #7 #10
	<var> state 78
	<var>::string state 79
	[] state 80
  state 78: #6
  state 79: #5 #6 #7
  state 80: #6 #10
  state 81: #7 #10 #11
	<var> state 82
	<app> state 86
  state 82: #7 #10
	<var> state 83
  state 83: #7 #10
	<var>::string state 84
	[] state 85
  state 84: #7
  state 85: #10
  state 86: #7 #10 #11
	<var> state 87
	: state 92
  state 87: #7 #10
	<var> state 88
  state 88: #7 #10
	<var> state 89
  state 89: #7 #10
	<var>::string state 90
	[] state 91
  state 90: #7
  state 91: #10
  state 92: #7 #10 #11
	<var> state 93
  state 93: #7 #10 #11
	<var> state 94
  state 94: #7 #10 #11
	<var>::string state 95
	<app> state 96
	[] state 101
  state 95: #7
  state 96: #11
	<app> state 97
  state 97: #11
	: state 98
  state 98: #11
	<var> state 99
  state 99: #11
	<var> state 100
  state 100: #11
  state 101: #10
  state 102: #7 #9 #10
	<var> state 103
	<var>::string state 104
	[] state 105
  state 103: #9
  state 104: #7 #9
  state 105: #9 #10
  state 106: #5 #6 #7 #8 #9 #10
	<var> state 107
	<var>::string state 111
	[] state 115
  state 107: #7 #8 #10
	<var> state 108
	<var>::string state 109
	[] state 110
  state 108: #8
  state 109: #7 #8
  state 110: #8 #10
  state 111: #5 #6 #7 #8 #10
	<var> state 112
	<var>::string state 113
	[] state 114
  state 112: #6 #8
  state 113: #5 #6 #7 #8
  state 114: #6 #8 #10
  state 115: #7 #8 #9 #10
	<var> state 116
	<var>::string state 117
	[] state 118
  state 116: #8 #9
  state 117: #7 #8 #9
  state 118: #8 #9 #10
}
{
  rule #0: dowith f x::matrix y::matrix = do (uncurry f) (zip x y)
  rule #1: dowith f s::string t::string = dowith f (chars s) (chars t)
  rule #2: dowith f s::string t = dowith f (chars s) t
  rule #3: dowith f s t::string = dowith f s (chars t)
  rule #4: dowith f (x:xs) (y:ys) = f x y$$dowith f xs ys
  rule #5: dowith f _ _ = ()
  state 0: #0 #1 #2 #3 #4 #5
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5
	<var> state 2
	<var>::string state 5
	<var>::matrix state 8
	<app> state 12
  state 2: #3 #5
	<var> state 3
	<var>::string state 4
  state 3: #5
  state 4: #3 #5
  state 5: #1 #2 #3 #5
	<var> state 6
	<var>::string state 7
  state 6: #2 #5
  state 7: #1 #2 #3 #5
  state 8: #0 #3 #5
	<var> state 9
	<var>::string state 10
	<var>::matrix state 11
  state 9: #5
  state 10: #3 #5
  state 11: #0 #5
  state 12: #3 #4 #5
	<var> state 13
	<app> state 17
  state 13: #3 #5
	<var> state 14
  state 14: #3 #5
	<var> state 15
	<var>::string state 16
  state 15: #5
  state 16: #3 #5
  state 17: #3 #4 #5
	<var> state 18
	: state 23
  state 18: #3 #5
	<var> state 19
  state 19: #3 #5
	<var> state 20
  state 20: #3 #5
	<var> state 21
	<var>::string state 22
  state 21: #5
  state 22: #3 #5
  state 23: #3 #4 #5
	<var> state 24
  state 24: #3 #4 #5
	<var> state 25
  state 25: #3 #4 #5
	<var> state 26
	<var>::string state 27
	<app> state 28
  state 26: #5
  state 27: #3 #5
  state 28: #4 #5
	<var> state 29
	<app> state 31
  state 29: #5
	<var> state 30
  state 30: #5
  state 31: #4 #5
	<var> state 32
	: state 35
  state 32: #5
	<var> state 33
  state 33: #5
	<var> state 34
  state 34: #5
  state 35: #4 #5
	<var> state 36
  state 36: #4 #5
	<var> state 37
  state 37: #4 #5
}
{
  rule #0: dowith3 f x::matrix y::matrix z::matrix = do (uncurry3 f) (zip3 x y z)
  rule #1: dowith3 f s::string t::string u::string = dowith3 f (chars s) (chars t) (chars u)
  rule #2: dowith3 f s::string t::string u = dowith3 f (chars s) (chars t) u
  rule #3: dowith3 f s::string t u::string = dowith3 f (chars s) t (chars u)
  rule #4: dowith3 f s::string t u = dowith3 f (chars s) t u
  rule #5: dowith3 f s t::string u::string = dowith3 f s (chars t) (chars u)
  rule #6: dowith3 f s t::string u = dowith3 f s (chars t) u
  rule #7: dowith3 f s t u::string = dowith3 f s t (chars u)
  rule #8: dowith3 f (x:xs) (y:ys) (z:zs) = f x y z$$dowith3 f xs ys zs
  rule #9: dowith3 f _ _ _ = ()
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9
	<var> state 2
	<var>::string state 9
	<var>::matrix state 16
	<app> state 27
  state 2: #5 #6 #7 #9
	<var> state 3
	<var>::string state 6
  state 3: #7 #9
	<var> state 4
	<var>::string state 5
  state 4: #9
  state 5: #7 #9
  state 6: #5 #6 #7 #9
	<var> state 7
	<var>::string state 8
  state 7: #6 #9
  state 8: #5 #6 #7 #9
  state 9: #1 #2 #3 #4 #5 #6 #7 #9
	<var> state 10
	<var>::string state 13
  state 10: #3 #4 #7 #9
	<var> state 11
	<var>::string state 12
  state 11: #4 #9
  state 12: #3 #4 #7 #9
  state 13: #1 #2 #3 #4 #5 #6 #7 #9
	<var> state 14
	<var>::string state 15
  state 14: #2 #4 #6 #9
  state 15: #1 #2 #3 #4 #5 #6 #7 #9
  state 16: #0 #5 #6 #7 #9
	<var> state 17
	<var>::string state 20
	<var>::matrix state 23
  state 17: #7 #9
	<var> state 18
	<var>::string state 19
  state 18: #9
  state 19: #7 #9
  state 20: #5 #6 #7 #9
	<var> state 21
	<var>::string state 22
  state 21: #6 #9
  state 22: #5 #6 #7 #9
  state 23: #0 #7 #9
	<var> state 24
	<var>::string state 25
	<var>::matrix state 26
  state 24: #9
  state 25: #7 #9
  state 26: #0 #9
  state 27: #5 #6 #7 #8 #9
	<var> state 28
	<app> state 36
  state 28: #5 #6 #7 #9
	<var> state 29
  state 29: #5 #6 #7 #9
	<var> state 30
	<var>::string state 33
  state 30: #7 #9
	<var> state 31
	<var>::string state 32
  state 31: #9
  state 32: #7 #9
  state 33: #5 #6 #7 #9
	<var> state 34
	<var>::string state 35
  state 34: #6 #9
  state 35: #5 #6 #7 #9
  state 36: #5 #6 #7 #8 #9
	<var> state 37
	: state 46
  state 37: #5 #6 #7 #9
	<var> state 38
  state 38: #5 #6 #7 #9
	<var> state 39
  state 39: #5 #6 #7 #9
	<var> state 40
	<var>::string state 43
  state 40: #7 #9
	<var> state 41
	<var>::string state 42
  state 41: #9
  state 42: #7 #9
  state 43: #5 #6 #7 #9
	<var> state 44
	<var>::string state 45
  state 44: #6 #9
  state 45: #5 #6 #7 #9
  state 46: #5 #6 #7 #8 #9
	<var> state 47
  state 47: #5 #6 #7 #8 #9
	<var> state 48
  state 48: #5 #6 #7 #8 #9
	<var> state 49
	<var>::string state 52
	<app> state 55
  state 49: #7 #9
	<var> state 50
	<var>::string state 51
  state 50: #9
  state 51: #7 #9
  state 52: #5 #6 #7 #9
	<var> state 53
	<var>::string state 54
  state 53: #6 #9
  state 54: #5 #6 #7 #9
  state 55: #7 #8 #9
	<var> state 56
	<app> state 60
  state 56: #7 #9
	<var> state 57
  state 57: #7 #9
	<var> state 58
	<var>::string state 59
  state 58: #9
  state 59: #7 #9
  state 60: #7 #8 #9
	<var> state 61
	: state 66
  state 61: #7 #9
	<var> state 62
  state 62: #7 #9
	<var> state 63
  state 63: #7 #9
	<var> state 64
	<var>::string state 65
  state 64: #9
  state 65: #7 #9
  state 66: #7 #8 #9
	<var> state 67
  state 67: #7 #8 #9
	<var> state 68
  state 68: #7 #8 #9
	<var> state 69
	<var>::string state 70
	<app> state 71
  state 69: #9
  state 70: #7 #9
  state 71: #8 #9
	<var> state 72
	<app> state 74
  state 72: #9
	<var> state 73
  state 73: #9
  state 74: #8 #9
	<var> state 75
	: state 78
  state 75: #9
	<var> state 76
  state 76: #9
	<var> state 77
  state 77: #9
  state 78: #8 #9
	<var> state 79
  state 79: #8 #9
	<var> state 80
  state 80: #8 #9
}
{
  rule #0: unzip x::matrix = colmap (\(u,_) -> u) x,colmap (\(_,v) -> v) x if all check x with check (_,_) = 1; check x = throw (bad_tuple_value x) end
  rule #1: unzip [] = [],[]
  rule #2: unzip us@(_:_) = foldr accum ([],[]) us with check us@(_,_) = us; check (foldr _ _ us) = throw (bad_list_value us); check us = throw (bad_tuple_value us); accum u@(x,y) us = x:(xs when xs,_ = check us end)&,y:(ys when _,ys = check us end)& if thunkp us; accum u@(x,y) us = x:xs,y:ys when xs,ys = check us end; accum u _ = throw (bad_tuple_value u) end
  state 0: #0 #1 #2
	<var>::matrix state 1
	<app> state 2
	[] state 7
  state 1: #0
  state 2: #2
	<app> state 3
  state 3: #2
	: state 4
  state 4: #2
	<var> state 5
  state 5: #2
	<var> state 6
  state 6: #2
  state 7: #1
}
{
  rule #0: unzip3 x::matrix = colmap (\(u,_) -> u) x,colmap (\(_,v,_) -> v) x,colmap (\(_,_,w) -> w) x if all check x with check (_,_,_) = 1; check x = throw (bad_tuple_value x) end
  rule #1: unzip3 [] = [],[],[]
  rule #2: unzip3 us@(_:_) = foldr accum ([],[],[]) us with check us@(_,_,_) = us; check (foldr _ _ us) = throw (bad_list_value us); check us = throw (bad_tuple_value us); accum u@(x,y,z) us = x:(xs when xs,_,_ = check us end)&,y:(ys when _,ys,_ = check us end)&,z:(zs when _,_,zs = check us end)& if thunkp us; accum u@(x,y,z) us = x:xs,y:ys,z:zs when xs,ys,zs = check us end; accum u _ = throw (bad_tuple_value u) end
  state 0: #0 #1 #2
	<var>::matrix state 1
	<app> state 2
	[] state 7
  state 1: #0
  state 2: #2
	<app> state 3
  state 3: #2
	: state 4
  state 4: #2
	<var> state 5
  state 5: #2
	<var> state 6
  state 6: #2
  state 7: #1
}
{
  rule #0: member x::matrix y = __C::record_member x y if recordp x
  rule #1: member [] y = 0
  rule #2: member (x:xs) y = 1 if y==?x
  rule #3: member (x:xs) y = member xs y
  state 0: #0 #1 #2 #3
	<var>::matrix state 1
	<app> state 3
	[] state 9
  state 1: #0
	<var> state 2
  state 2: #0
  state 3: #2 #3
	<app> state 4
  state 4: #2 #3
	: state 5
  state 5: #2 #3
	<var> state 6
  state 6: #2 #3
	<var> state 7
  state 7: #2 #3
	<var> state 8
  state 8: #2 #3
  state 9: #1
	<var> state 10
  state 10: #1
}
{
  rule #0: delete x::matrix y = __C::record_delete x y if recordp x
  rule #1: delete [] y = []
  rule #2: delete xs@(_:_) y = tick xs [] with tick [] _ = xs; tick (x:xs) ws = if y==?x then __std__::reverse_onto xs ws else tick xs (x:ws); tick xs ws = __std__::reverse_onto (delete xs y) ws end
  state 0: #0 #1 #2
	<var>::matrix state 1
	<app> state 3
	[] state 9
  state 1: #0
	<var> state 2
  state 2: #0
  state 3: #2
	<app> state 4
  state 4: #2
	: state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1
	<var> state 10
  state 10: #1
}
{
  rule #0: index s::string u::string = __C::string_index s u
  rule #1: index [] _ = -1
  rule #2: index (x:xs) y = search 0 (x:xs) with search _ [] = -1; search n::int (x:xs) = n if x==?y; search n::int (x:xs) = search (n+1) xs; search _ xs = index xs y end
  state 0: #0 #1 #2
	<var>::string state 1
	<app> state 3
	[] state 9
  state 1: #0
	<var>::string state 2
  state 2: #0
  state 3: #2
	<app> state 4
  state 4: #2
	: state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1
	<var> state 10
  state 10: #1
}
{
  rule #0: split delim::string s::string = __C::string_split delim s if ~funp (:)
  rule #1: split delim::string s::string = list (__C::string_split delim s)
  rule #2: split n::int s::string = substr s 0 n,substr s n 2147483647
  rule #3: split m::int [] = [],[]
  rule #4: split m::int xs@(_:_) = aux m xs with aux m::int xs = split_pre len_pre xs with split_pre 0 _ = split_tails; split_pre n::int (x:xs) = add x (split_pre (n-1) xs) end when len_pre@_ split_tails = skip_ahead m 0 xs end; skip_ahead m::int n::int [] = n ([],[]); skip_ahead m::int n::int xs@(_:_) = n (aux m xs) if n==4096; skip_ahead m::int n::int xs = n ([],xs) if m<=0; skip_ahead m::int n::int (x:xs) = n (x:take (m-1) xs&,drop (m-1) xs&) if thunkp xs; skip_ahead m::int n::int (x:xs) = skip_ahead (m-1) (n+1) xs; skip_ahead m::int n::int xs = n (take m xs,drop m xs); add x (front,back) = x:front,back end
  state 0: #0 #1 #2 #3 #4
	<var>::int state 1
	<var>::string state 9
  state 1: #2 #3 #4
	<var>::string state 2
	<app> state 3
	[] state 8
  state 2: #2
  state 3: #4
	<app> state 4
  state 4: #4
	: state 5
  state 5: #4
	<var> state 6
  state 6: #4
	<var> state 7
  state 7: #4
  state 8: #3
  state 9: #0 #1
	<var>::string state 10
  state 10: #0 #1
}
{
  rule #0: stream s::string = stream (chars s)
  rule #1: stream [] = []
  rule #2: stream (x:xs) = x:xs if thunkp xs
  rule #3: stream (x:xs) = x:stream xs&
  rule #4: stream () = []
  rule #5: stream xs@(_,_) = stream (list xs)
  state 0: #0 #1 #2 #3 #4 #5
	<var>::string state 1
	<app> state 2
	[] state 10
	() state 11
  state 1: #0
  state 2: #2 #3 #5
	<app> state 3
  state 3: #2 #3 #5
	: state 4
	, state 7
  state 4: #2 #3
	<var> state 5
  state 5: #2 #3
	<var> state 6
  state 6: #2 #3
  state 7: #5
	<var> state 8
  state 8: #5
	<var> state 9
  state 9: #5
  state 10: #1
  state 11: #4
}
{
  rule #0: reverse_onto b::string s::string = strcat (reverse_onto [b] (chars s))
  rule #1: reverse_onto b::string s = reverse_onto (chars b) s
  rule #2: reverse_onto b s::string = strcat (reverse_onto [b] (chars s)) if stringp b when b = __C::string_concat_list b end
  rule #3: reverse_onto b s::string = reverse_onto b (chars s)
  rule #4: reverse_onto base [] = base
  rule #5: reverse_onto base (x:xs) = accum (x:base) xs with accum ys (x:xs) = accum (x:ys) xs; accum ys [] = ys; accum ys xs = throw (bad_list_value xs) end
  state 0: #0 #1 #2 #3 #4 #5
	<var> state 1
	<var>::string state 9
  state 1: #2 #3 #4 #5
	<var>::string state 2
	<app> state 3
	[] state 8
  state 2: #2 #3
  state 3: #5
	<app> state 4
  state 4: #5
	: state 5
  state 5: #5
	<var> state 6
  state 6: #5
	<var> state 7
  state 7: #5
  state 8: #4
  state 9: #0 #1 #2 #3 #4 #5
	<var> state 10
	<var>::string state 11
	<app> state 12
	[] state 22
  state 10: #1
  state 11: #0 #1 #2 #3
  state 12: #1 #5
	<var> state 13
	<app> state 15
  state 13: #1
	<var> state 14
  state 14: #1
  state 15: #1 #5
	<var> state 16
	: state 19
  state 16: #1
	<var> state 17
  state 17: #1
	<var> state 18
  state 18: #1
  state 19: #1 #5
	<var> state 20
  state 20: #1 #5
	<var> state 21
  state 21: #1 #5
  state 22: #1 #4
}
{
  rule #0: catmap_onto f b::string s::string = catmap_onto f (chars b) (chars s)
  rule #1: catmap_onto f b s::string = catmap_onto f b (chars s)
  rule #2: catmap_onto f b::string s = catmap_onto f (chars b) s
  rule #3: catmap_onto f base [] = base
  rule #4: catmap_onto f base xs@(_:_) = aux xs with aux xs = map_pre len_pre xs with map_pre 0 _ = mapped_tail; map_pre n::int (x:xs) = lazy_cat (f x) (map_pre (n-1) xs) end when len_pre@_ mapped_tail = skip_map 0 xs end; lazy_cat xs yss = cat_pre len_pre xs with cat_pre 0 _ = catted_tail; cat_pre n::int (x:xs) = x:cat_pre (n-1) xs end when len_pre@_ catted_tail = skip_cat yss 0 xs end; skip_map n::int [] = n base; skip_map n::int xs@(_:_) = n (aux xs) if n==4096; skip_map n::int (x:xs) = n (lazy_cat (f x) (aux xs&)) if thunkp xs; skip_map n::int (x:xs) = skip_map (n+1) xs; skip_map n::int xs = n (catmap_onto f base xs); skip_cat yss n::int [] = n yss; skip_cat yss n::int xs@(_:_) = n (aux xs) if n==4096; skip_cat yss n::int (x:xs) = n (x:lazy_cat xs yss&) if thunkp xs; skip_cat yss n::int (x:xs) = skip_cat yss (n+1) xs; skip_cat yss n::int xs = n (xs+yss) end
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<var>::string state 10
  state 2: #1 #3 #4
	<var>::string state 3
	<app> state 4
	[] state 9
  state 3: #1
  state 4: #4
	<app> state 5
  state 5: #4
	: state 6
  state 6: #4
	<var> state 7
  state 7: #4
	<var> state 8
  state 8: #4
  state 9: #3
  state 10: #0 #1 #2 #3 #4
	<var> state 11
	<var>::string state 12
	<app> state 13
	[] state 23
  state 11: #2
  state 12: #0 #1 #2
  state 13: #2 #4
	<var> state 14
	<app> state 16
  state 14: #2
	<var> state 15
  state 15: #2
  state 16: #2 #4
	<var> state 17
	: state 20
  state 17: #2
	<var> state 18
  state 18: #2
	<var> state 19
  state 19: #2
  state 20: #2 #4
	<var> state 21
  state 21: #2 #4
	<var> state 22
  state 22: #2 #4
  state 23: #2 #3
}
{
  rule #0: firstby p none s::string = firstby p none (chars s)
  rule #1: firstby p none [] = none
  rule #2: firstby p none (x:xs) = if p x then x else firstby p none xs
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
  state 2: #0 #1 #2
	<var>::string state 3
	<app> state 4
	[] state 9
  state 3: #0
  state 4: #2
	<app> state 5
  state 5: #2
	: state 6
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1
}
{
  rule #0: foldl2 f a s::string t::string = foldl2 f a (chars s) (chars t)
  rule #1: foldl2 f a s t::string = foldl2 f a s (chars t)
  rule #2: foldl2 f a s::string t = foldl2 f a (chars s) t
  rule #3: foldl2 f a _ [] = a
  rule #4: foldl2 f a [] _ = a
  rule #5: foldl2 f a (x:xs) (y:ys) = foldl2 f (f a x y) xs ys
  state 0: #0 #1 #2 #3 #4 #5
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5
	<var> state 2
  state 2: #0 #1 #2 #3 #4 #5
	<var> state 3
	<var>::string state 6
	<app> state 10
	[] state 31
  state 3: #1 #3
	<var>::string state 4
	[] state 5
  state 4: #1
  state 5: #3
  state 6: #0 #1 #2 #3
	<var> state 7
	<var>::string state 8
	[] state 9
  state 7: #2
  state 8: #0 #1 #2
  state 9: #2 #3
  state 10: #1 #3 #5
	<var> state 11
	<app> state 15
  state 11: #1 #3
	<var> state 12
  state 12: #1 #3
	<var>::string state 13
	[] state 14
  state 13: #1
  state 14: #3
  state 15: #1 #3 #5
	<var> state 16
	: state 21
  state 16: #1 #3
	<var> state 17
  state 17: #1 #3
	<var> state 18
  state 18: #1 #3
	<var>::string state 19
	[] state 20
  state 19: #1
  state 20: #3
  state 21: #1 #3 #5
	<var> state 22
  state 22: #1 #3 #5
	<var> state 23
  state 23: #1 #3 #5
	<var>::string state 24
	<app> state 25
	[] state 30
  state 24: #1
  state 25: #5
	<app> state 26
  state 26: #5
	: state 27
  state 27: #5
	<var> state 28
  state 28: #5
	<var> state 29
  state 29: #5
  state 30: #3
  state 31: #1 #3 #4
	<var> state 32
	<var>::string state 33
	[] state 34
  state 32: #4
  state 33: #1 #4
  state 34: #3 #4
}
{
  rule #0: foldl3 f a s::string t::string u::string = foldl3 f a (chars s) (chars t) (chars u)
  rule #1: foldl3 f a s::string t::string u = foldl3 f a (chars s) (chars t) u
  rule #2: foldl3 f a s::string t u::string = foldl3 f a (chars s) t (chars u)
  rule #3: foldl3 f a s::string t u = foldl3 f a (chars s) t u
  rule #4: foldl3 f a s t::string u::string = foldl3 f a s (chars t) (chars u)
  rule #5: foldl3 f a s t::string u = foldl3 f a s (chars t) u
  rule #6: foldl3 f a s t u::string = foldl3 f a s t (chars u)
  rule #7: foldl3 f a _ _ [] = a
  rule #8: foldl3 f a _ [] _ = a
  rule #9: foldl3 f a [] _ _ = a
  rule #10: foldl3 f a (x:xs) (y:ys) (z:zs) = foldl3 f (f a x y z) xs ys zs
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10
	<var> state 2
  state 2: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10
	<var> state 3
	<var>::string state 15
	<app> state 28
	[] state 92
  state 3: #4 #5 #6 #7 #8
	<var> state 4
	<var>::string state 7
	[] state 11
  state 4: #6 #7
	<var>::string state 5
	[] state 6
  state 5: #6
  state 6: #7
  state 7: #4 #5 #6 #7
	<var> state 8
	<var>::string state 9
	[] state 10
  state 8: #5
  state 9: #4 #5 #6
  state 10: #5 #7
  state 11: #6 #7 #8
	<var> state 12
	<var>::string state 13
	[] state 14
  state 12: #8
  state 13: #6 #8
  state 14: #7 #8
  state 15: #0 #1 #2 #3 #4 #5 #6 #7 #8
	<var> state 16
	<var>::string state 20
	[] state 24
  state 16: #2 #3 #6 #7
	<var> state 17
	<var>::string state 18
	[] state 19
  state 17: #3
  state 18: #2 #3 #6
  state 19: #3 #7
  state 20: #0 #1 #2 #3 #4 #5 #6 #7
	<var> state 21
	<var>::string state 22
	[] state 23
  state 21: #1 #3 #5
  state 22: #0 #1 #2 #3 #4 #5 #6
  state 23: #1 #3 #5 #7
  state 24: #2 #3 #6 #7 #8
	<var> state 25
	<var>::string state 26
	[] state 27
  state 25: #3 #8
  state 26: #2 #3 #6 #8
  state 27: #3 #7 #8
  state 28: #4 #5 #6 #7 #8 #10
	<var> state 29
	<app> state 42
  state 29: #4 #5 #6 #7 #8
	<var> state 30
  state 30: #4 #5 #6 #7 #8
	<var> state 31
	<var>::string state 34
	[] state 38
  state 31: #6 #7
	<var>::string state 32
	[] state 33
  state 32: #6
  state 33: #7
  state 34: #4 #5 #6 #7
	<var> state 35
	<var>::string state 36
	[] state 37
  state 35: #5
  state 36: #4 #5 #6
  state 37: #5 #7
  state 38: #6 #7 #8
	<var> state 39
	<var>::string state 40
	[] state 41
  state 39: #8
  state 40: #6 #8
  state 41: #7 #8
  state 42: #4 #5 #6 #7 #8 #10
	<var> state 43
	: state 57
  state 43: #4 #5 #6 #7 #8
	<var> state 44
  state 44: #4 #5 #6 #7 #8
	<var> state 45
  state 45: #4 #5 #6 #7 #8
	<var> state 46
	<var>::string state 49
	[] state 53
  state 46: #6 #7
	<var>::string state 47
	[] state 48
  state 47: #6
  state 48: #7
  state 49: #4 #5 #6 #7
	<var> state 50
	<var>::string state 51
	[] state 52
  state 50: #5
  state 51: #4 #5 #6
  state 52: #5 #7
  state 53: #6 #7 #8
	<var> state 54
	<var>::string state 55
	[] state 56
  state 54: #8
  state 55: #6 #8
  state 56: #7 #8
  state 57: #4 #5 #6 #7 #8 #10
	<var> state 58
  state 58: #4 #5 #6 #7 #8 #10
	<var> state 59
  state 59: #4 #5 #6 #7 #8 #10
	<var> state 60
	<var>::string state 63
	<app> state 67
	[] state 88
  state 60: #6 #7
	<var>::string state 61
	[] state 62
  state 61: #6
  state 62: #7
  state 63: #4 #5 #6 #7
	<var> state 64
	<var>::string state 65
	[] state 66
  state 64: #5
  state 65: #4 #5 #6
  state 66: #5 #7
  state 67: #6 #7 #10
	<var> state 68
	<app> state 72
  state 68: #6 #7
	<var> state 69
  state 69: #6 #7
	<var>::string state 70
	[] state 71
  state 70: #6
  state 71: #7
  state 72: #6 #7 #10
	<var> state 73
	: state 78
  state 73: #6 #7
	<var> state 74
  state 74: #6 #7
	<var> state 75
  state 75: #6 #7
	<var>::string state 76
	[] state 77
  state 76: #6
  state 77: #7
  state 78: #6 #7 #10
	<var> state 79
  state 79: #6 #7 #10
	<var> state 80
  state 80: #6 #7 #10
	<var>::string state 81
	<app> state 82
	[] state 87
  state 81: #6
  state 82: #10
	<app> state 83
  state 83: #10
	: state 84
  state 84: #10
	<var> state 85
  state 85: #10
	<var> state 86
  state 86: #10
  state 87: #7
  state 88: #6 #7 #8
	<var> state 89
	<var>::string state 90
	[] state 91
  state 89: #8
  state 90: #6 #8
  state 91: #7 #8
  state 92: #4 #5 #6 #7 #8 #9
	<var> state 93
	<var>::string state 97
	[] state 101
  state 93: #6 #7 #9
	<var> state 94
	<var>::string state 95
	[] state 96
  state 94: #9
  state 95: #6 #9
  state 96: #7 #9
  state 97: #4 #5 #6 #7 #9
	<var> state 98
	<var>::string state 99
	[] state 100
  state 98: #5 #9
  state 99: #4 #5 #6 #9
  state 100: #5 #7 #9
  state 101: #6 #7 #8 #9
	<var> state 102
	<var>::string state 103
	[] state 104
  state 102: #8 #9
  state 103: #6 #8 #9
  state 104: #7 #8 #9
}
{
  rule #0: foldr2 f a s::string t::string = foldr2 f a (chars s) (chars t)
  rule #1: foldr2 f a s t::string = foldr2 f a s (chars t)
  rule #2: foldr2 f a s::string t = foldr2 f a (chars s) t
  rule #3: foldr2 f a _ [] = a
  rule #4: foldr2 f a [] _ = a
  rule #5: foldr2 f a xs@(_:_) ys@(_:_) = aux xs ys with aux xs ys = fold_pre len_pre xs ys with fold_pre 0 _ _ = folded_tail; fold_pre n::int (x:xs) (y:ys) = f x y (fold_pre (n-1) xs ys) end when len_pre@_ folded_tail = skip_ahead 0 xs ys end; skip_ahead n::int [] _ = n a; skip_ahead n::int _ [] = n a; skip_ahead n::int xs@(_:_) ys@(_:_) = n (aux xs ys) if n==4096; skip_ahead n::int (x:xs) (y:ys) = n (f x y (aux xs ys&)) if thunkp xs||thunkp ys; skip_ahead n::int (x:xs) (y:ys) = skip_ahead (n+1) xs ys; skip_ahead n::int xs ys = n (foldr2 f a xs ys) end
  state 0: #0 #1 #2 #3 #4 #5
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5
	<var> state 2
  state 2: #0 #1 #2 #3 #4 #5
	<var> state 3
	<var>::string state 6
	<app> state 10
	[] state 31
  state 3: #1 #3
	<var>::string state 4
	[] state 5
  state 4: #1
  state 5: #3
  state 6: #0 #1 #2 #3
	<var> state 7
	<var>::string state 8
	[] state 9
  state 7: #2
  state 8: #0 #1 #2
  state 9: #2 #3
  state 10: #1 #3 #5
	<var> state 11
	<app> state 15
  state 11: #1 #3
	<var> state 12
  state 12: #1 #3
	<var>::string state 13
	[] state 14
  state 13: #1
  state 14: #3
  state 15: #1 #3 #5
	<var> state 16
	: state 21
  state 16: #1 #3
	<var> state 17
  state 17: #1 #3
	<var> state 18
  state 18: #1 #3
	<var>::string state 19
	[] state 20
  state 19: #1
  state 20: #3
  state 21: #1 #3 #5
	<var> state 22
  state 22: #1 #3 #5
	<var> state 23
  state 23: #1 #3 #5
	<var>::string state 24
	<app> state 25
	[] state 30
  state 24: #1
  state 25: #5
	<app> state 26
  state 26: #5
	: state 27
  state 27: #5
	<var> state 28
  state 28: #5
	<var> state 29
  state 29: #5
  state 30: #3
  state 31: #1 #3 #4
	<var> state 32
	<var>::string state 33
	[] state 34
  state 32: #4
  state 33: #1 #4
  state 34: #3 #4
}
{
  rule #0: foldr3 f a s::string t::string u::string = foldr3 f a (chars s) (chars t) (chars u)
  rule #1: foldr3 f a s::string t::string u = foldr3 f a (chars s) (chars t) u
  rule #2: foldr3 f a s::string t u::string = foldr3 f a (chars s) t (chars u)
  rule #3: foldr3 f a s::string t u = foldr3 f a (chars s) t u
  rule #4: foldr3 f a s t::string u::string = foldr3 f a s (chars t) (chars u)
  rule #5: foldr3 f a s t::string u = foldr3 f a s (chars t) u
  rule #6: foldr3 f a s t u::string = foldr3 f a s t (chars u)
  rule #7: foldr3 f a _ _ [] = a
  rule #8: foldr3 f a _ [] _ = a
  rule #9: foldr3 f a [] _ _ = a
  rule #10: foldr3 f a xs@(_:_) ys@(_:_) zs@(_:_) = aux xs ys zs with aux xs ys zs = fold_pre len_pre xs ys zs with fold_pre 0 _ _ _ = folded_tail; fold_pre n::int (x:xs) (y:ys) (z:zs) = f x y z (fold_pre (n-1) xs ys zs) end when len_pre@_ folded_tail = skip_ahead 0 xs ys zs end; skip_ahead n::int [] _ _ = n a; skip_ahead n::int _ [] _ = n a; skip_ahead n::int _ _ [] = n a; skip_ahead n::int xs@(_:_) ys@(_:_) zs@(_:_) = n (aux xs ys zs) if n==4096; skip_ahead n::int (x:xs) (y:ys) (z:zs) = n (f x y z (aux xs ys zs&)) if thunkp xs||thunkp ys||thunkp zs; skip_ahead n::int (x:xs) (y:ys) (z:zs) = skip_ahead (n+1) xs ys zs; skip_ahead n::int xs ys zs = n (foldr3 f a xs ys zs) end
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10
	<var> state 2
  state 2: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10
	<var> state 3
	<var>::string state 15
	<app> state 28
	[] state 92
  state 3: #4 #5 #6 #7 #8
	<var> state 4
	<var>::string state 7
	[] state 11
  state 4: #6 #7
	<var>::string state 5
	[] state 6
  state 5: #6
  state 6: #7
  state 7: #4 #5 #6 #7
	<var> state 8
	<var>::string state 9
	[] state 10
  state 8: #5
  state 9: #4 #5 #6
  state 10: #5 #7
  state 11: #6 #7 #8
	<var> state 12
	<var>::string state 13
	[] state 14
  state 12: #8
  state 13: #6 #8
  state 14: #7 #8
  state 15: #0 #1 #2 #3 #4 #5 #6 #7 #8
	<var> state 16
	<var>::string state 20
	[] state 24
  state 16: #2 #3 #6 #7
	<var> state 17
	<var>::string state 18
	[] state 19
  state 17: #3
  state 18: #2 #3 #6
  state 19: #3 #7
  state 20: #0 #1 #2 #3 #4 #5 #6 #7
	<var> state 21
	<var>::string state 22
	[] state 23
  state 21: #1 #3 #5
  state 22: #0 #1 #2 #3 #4 #5 #6
  state 23: #1 #3 #5 #7
  state 24: #2 #3 #6 #7 #8
	<var> state 25
	<var>::string state 26
	[] state 27
  state 25: #3 #8
  state 26: #2 #3 #6 #8
  state 27: #3 #7 #8
  state 28: #4 #5 #6 #7 #8 #10
	<var> state 29
	<app> state 42
  state 29: #4 #5 #6 #7 #8
	<var> state 30
  state 30: #4 #5 #6 #7 #8
	<var> state 31
	<var>::string state 34
	[] state 38
  state 31: #6 #7
	<var>::string state 32
	[] state 33
  state 32: #6
  state 33: #7
  state 34: #4 #5 #6 #7
	<var> state 35
	<var>::string state 36
	[] state 37
  state 35: #5
  state 36: #4 #5 #6
  state 37: #5 #7
  state 38: #6 #7 #8
	<var> state 39
	<var>::string state 40
	[] state 41
  state 39: #8
  state 40: #6 #8
  state 41: #7 #8
  state 42: #4 #5 #6 #7 #8 #10
	<var> state 43
	: state 57
  state 43: #4 #5 #6 #7 #8
	<var> state 44
  state 44: #4 #5 #6 #7 #8
	<var> state 45
  state 45: #4 #5 #6 #7 #8
	<var> state 46
	<var>::string state 49
	[] state 53
  state 46: #6 #7
	<var>::string state 47
	[] state 48
  state 47: #6
  state 48: #7
  state 49: #4 #5 #6 #7
	<var> state 50
	<var>::string state 51
	[] state 52
  state 50: #5
  state 51: #4 #5 #6
  state 52: #5 #7
  state 53: #6 #7 #8
	<var> state 54
	<var>::string state 55
	[] state 56
  state 54: #8
  state 55: #6 #8
  state 56: #7 #8
  state 57: #4 #5 #6 #7 #8 #10
	<var> state 58
  state 58: #4 #5 #6 #7 #8 #10
	<var> state 59
  state 59: #4 #5 #6 #7 #8 #10
	<var> state 60
	<var>::string state 63
	<app> state 67
	[] state 88
  state 60: #6 #7
	<var>::string state 61
	[] state 62
  state 61: #6
  state 62: #7
  state 63: #4 #5 #6 #7
	<var> state 64
	<var>::string state 65
	[] state 66
  state 64: #5
  state 65: #4 #5 #6
  state 66: #5 #7
  state 67: #6 #7 #10
	<var> state 68
	<app> state 72
  state 68: #6 #7
	<var> state 69
  state 69: #6 #7
	<var>::string state 70
	[] state 71
  state 70: #6
  state 71: #7
  state 72: #6 #7 #10
	<var> state 73
	: state 78
  state 73: #6 #7
	<var> state 74
  state 74: #6 #7
	<var> state 75
  state 75: #6 #7
	<var>::string state 76
	[] state 77
  state 76: #6
  state 77: #7
  state 78: #6 #7 #10
	<var> state 79
  state 79: #6 #7 #10
	<var> state 80
  state 80: #6 #7 #10
	<var>::string state 81
	<app> state 82
	[] state 87
  state 81: #6
  state 82: #10
	<app> state 83
  state 83: #10
	: state 84
  state 84: #10
	<var> state 85
  state 85: #10
	<var> state 86
  state 86: #10
  state 87: #7
  state 88: #6 #7 #8
	<var> state 89
	<var>::string state 90
	[] state 91
  state 89: #8
  state 90: #6 #8
  state 91: #7 #8
  state 92: #4 #5 #6 #7 #8 #9
	<var> state 93
	<var>::string state 97
	[] state 101
  state 93: #6 #7 #9
	<var> state 94
	<var>::string state 95
	[] state 96
  state 94: #9
  state 95: #6 #9
  state 96: #7 #9
  state 97: #4 #5 #6 #7 #9
	<var> state 98
	<var>::string state 99
	[] state 100
  state 98: #5 #9
  state 99: #4 #5 #6 #9
  state 100: #5 #7 #9
  state 101: #6 #7 #8 #9
	<var> state 102
	<var>::string state 103
	[] state 104
  state 102: #8 #9
  state 103: #6 #8 #9
  state 104: #7 #8 #9
}
{
  rule #0: lastby p none s::string = lastby p none (chars s)
  rule #1: lastby p none [] = none
  rule #2: lastby p none xs@(_:_) = tick xs __std__::notfound with tick [] w = if w===__std__::notfound then none else w; tick (x:xs) w = tick xs (if p x then x else w); tick xs w = throw (bad_list_value xs) end
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
  state 2: #0 #1 #2
	<var>::string state 3
	<app> state 4
	[] state 9
  state 3: #0
  state 4: #2
	<app> state 5
  state 5: #2
	: state 6
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1
}
{
  rule #0: map_onto f b::string s::string = map_onto f (chars b) (chars s)
  rule #1: map_onto f b s::string = map_onto f b (chars s)
  rule #2: map_onto f b::string s = map_onto f (chars b) s
  rule #3: map_onto f base [] = base
  rule #4: map_onto f base xs@(_:_) = aux xs with aux xs = map_pre len_pre xs with map_pre 0 _ = mapped_tail; map_pre n::int (x:xs) = f x:map_pre (n-1) xs end when len_pre@_ mapped_tail = skip_ahead 0 xs end; skip_ahead n::int [] = n base; skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096; skip_ahead n::int (x:xs) = n (f x:aux xs&) if thunkp xs; skip_ahead n::int (x:xs) = skip_ahead (n+1) xs; skip_ahead n::int xs = n (map_onto f base xs) end
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<var>::string state 10
  state 2: #1 #3 #4
	<var>::string state 3
	<app> state 4
	[] state 9
  state 3: #1
  state 4: #4
	<app> state 5
  state 5: #4
	: state 6
  state 6: #4
	<var> state 7
  state 7: #4
	<var> state 8
  state 8: #4
  state 9: #3
  state 10: #0 #1 #2 #3 #4
	<var> state 11
	<var>::string state 12
	<app> state 13
	[] state 23
  state 11: #2
  state 12: #0 #1 #2
  state 13: #2 #4
	<var> state 14
	<app> state 16
  state 14: #2
	<var> state 15
  state 15: #2
  state 16: #2 #4
	<var> state 17
	: state 20
  state 17: #2
	<var> state 18
  state 18: #2
	<var> state 19
  state 19: #2
  state 20: #2 #4
	<var> state 21
  state 21: #2 #4
	<var> state 22
  state 22: #2 #4
  state 23: #2 #3
}
{
  rule #0: partition p s::string = strcat yes,strcat no when yes,no = partition p (chars s) end
  rule #1: partition p [] = [],[]
  rule #2: partition p xs@(_:_) = aux xs with aux xs = split_pre len_pre xs with split_pre 0 _ = split_tails; split_pre n::int (x:xs) = add p x (split_pre (n-1) xs) end when len_pre@_ split_tails = skip_ahead 0 xs end; skip_ahead n::int [] = n ([],[]); skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096; skip_ahead n::int (x:xs) = n (add p x (filter p xs&,filter ((~).p) xs&)) if thunkp xs; skip_ahead n::int (x:xs) = skip_ahead (n+1) xs; skip_ahead n::int xs = n (filter p xs,filter ((~).p) xs); add p x (yes,no) = if p x then x:yes,no else yes,x:no end
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var>::string state 2
	<app> state 3
	[] state 8
  state 2: #0
  state 3: #2
	<app> state 4
  state 4: #2
	: state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
  state 8: #1
}
{
  rule #0: pickfirstby p s::string = case pickfirstby p (chars s) of () = (); c,cs = c,strcat cs end
  rule #1: pickfirstby p [] = ()
  rule #2: pickfirstby p xs@(_:_) = tick xs [] with tick [] _ = (); tick (x:xs) ws = if p x then tuple2 x (__std__::reverse_onto xs ws) else tick xs (x:ws); tick xs ws = throw (bad_list_value xs) end
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var>::string state 2
	<app> state 3
	[] state 8
  state 2: #0
  state 3: #2
	<app> state 4
  state 4: #2
	: state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
  state 8: #1
}
{
  rule #0: picklastby p s::string = case picklastby p (chars s) of () = (); c,cs = c,strcat cs end
  rule #1: picklastby p [] = ()
  rule #2: picklastby p xs@(_:_) = aux xs with aux xs = case skip_ahead 0 xs of len_pre@_ () = pop_pre len_pre xs with pop_pre 0 _ = (); pop_pre n::int xx@(x:xs) = case pop_pre (n-1) xs of () = if p x then xx else (); y,ys = tuple2 y (x:ys) end end; len_pre@_ (y:ys) = tuple2 y (append len_pre xs ys) end; skip_ahead n::int [] = n (); skip_ahead n::int xs = n (aux xs) if n==4096; skip_ahead n::int (_:xs) = skip_ahead (n+1) xs; skip_ahead n::int xs = throw (bad_list_value xs); append n::int [] ys = ys; append 0 _ ys = ys; append n::int (x:xs) ys = x:append (n-1) xs ys end
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var>::string state 2
	<app> state 3
	[] state 8
  state 2: #0
  state 3: #2
	<app> state 4
  state 4: #2
	: state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
  state 8: #1
}
{
  rule #0: revmap f s::string = revmap f (chars s)
  rule #1: revmap f [] = []
  rule #2: revmap f xs@(_:_) = revmap_onto f [] xs
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var>::string state 2
	<app> state 3
	[] state 8
  state 2: #0
  state 3: #2
	<app> state 4
  state 4: #2
	: state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
  state 8: #1
}
{
  rule #0: revmap_onto f b::string s::string = revmap_onto f (chars b) (chars s)
  rule #1: revmap_onto f b s::string = revmap_onto f b (chars s)
  rule #2: revmap_onto f b::string s = revmap_onto f (chars b) s
  rule #3: revmap_onto f base [] = base
  rule #4: revmap_onto f base xs@(_:_) = tick base xs with tick a [] = a; tick a (x:xs) = tick (f x:a) xs; tick _ xs = throw (bad_list_value xs) end
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<var>::string state 10
  state 2: #1 #3 #4
	<var>::string state 3
	<app> state 4
	[] state 9
  state 3: #1
  state 4: #4
	<app> state 5
  state 5: #4
	: state 6
  state 6: #4
	<var> state 7
  state 7: #4
	<var> state 8
  state 8: #4
  state 9: #3
  state 10: #0 #1 #2 #3 #4
	<var> state 11
	<var>::string state 12
	<app> state 13
	[] state 23
  state 11: #2
  state 12: #0 #1 #2
  state 13: #2 #4
	<var> state 14
	<app> state 16
  state 14: #2
	<var> state 15
  state 15: #2
  state 16: #2 #4
	<var> state 17
	: state 20
  state 17: #2
	<var> state 18
  state 18: #2
	<var> state 19
  state 19: #2
  state 20: #2 #4
	<var> state 21
  state 21: #2 #4
	<var> state 22
  state 22: #2 #4
  state 23: #2 #3
}
{
  rule #0: rmfirstby p s::string = strcat (rmfirstby p (chars s))
  rule #1: rmfirstby p [] = []
  rule #2: rmfirstby p ys@(_:_) = tick ys [] with tick [] _ = ys; tick (x:xs) ws = if p x then __std__::reverse_onto xs ws else tick xs (x:ws); tick xs ws = __std__::reverse_onto (rmfirstby p xs) ws end
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var>::string state 2
	<app> state 3
	[] state 8
  state 2: #0
  state 3: #2
	<app> state 4
  state 4: #2
	: state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
  state 8: #1
}
{
  rule #0: rmlastby p s::string = strcat (rmfirstby p (chars s))
  rule #1: rmlastby p [] = []
  rule #2: rmlastby p ys@(_:_) = case aux ys of __std__::notfound = ys; ys = ys end with aux xs = case skip_ahead 0 xs of len_pre@_ __std__::notfound = pop_pre len_pre xs with pop_pre 0 _ = __std__::notfound; pop_pre n::int (x:xs) = case pop_pre (n-1) xs of __std__::notfound = if p x then xs else __std__::notfound; ys = x:ys end end; len_pre@_ ys = append len_pre xs ys end; skip_ahead n::int [] = n __std__::notfound; skip_ahead n::int xs = n (aux xs) if n==4096; skip_ahead n::int (_:xs) = skip_ahead (n+1) xs; skip_ahead n::int xs = throw (bad_list_value xs); append n::int [] ys = ys; append 0 _ ys = ys; append n::int (x:xs) ys = x:append (n-1) xs ys end
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var>::string state 2
	<app> state 3
	[] state 8
  state 2: #0
  state 3: #2
	<app> state 4
  state 4: #2
	: state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
  state 8: #1
}
{
  rule #0: rotate n::int s::string = strcat (rotate n (chars s))
  rule #1: rotate 1 xs@(_:_) = aux xs with aux xs = lastx:rotate_pre len_pre xs with rotate_pre 0 _ = chopped_tail; rotate_pre n::int (x:xs) = x:rotate_pre (n-1) xs end when len_pre@_ (lastx:chopped_tail) = skip_ahead 0 xs end; skip_ahead n::int x@_:[] = n x; skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096; skip_ahead n::int (x:xs) = skip_ahead (n+1) xs; skip_ahead n::int xs = n (rotate xs) end
  rule #2: rotate _::int [] = []
  rule #3: rotate 0 xs@(_:_) = xs
  rule #4: rotate n::int xs@(_:_) = post+pre when xn = #xs; n = (xn-n) mod xn; pre,post = if n>0 then split n xs else if n<0 then split (xn+n) xs else xs,[] end
  state 0: #0 #1 #2 #3 #4
	<var>::int state 1
	1::int state 9
	0::int state 17
  state 1: #0 #2 #4
	<var>::string state 2
	<app> state 3
	[] state 8
  state 2: #0
  state 3: #4
	<app> state 4
  state 4: #4
	: state 5
  state 5: #4
	<var> state 6
  state 6: #4
	<var> state 7
  state 7: #4
  state 8: #2
  state 9: #0 #1 #2 #4
	<var>::string state 10
	<app> state 11
	[] state 16
  state 10: #0
  state 11: #1 #4
	<app> state 12
  state 12: #1 #4
	: state 13
  state 13: #1 #4
	<var> state 14
  state 14: #1 #4
	<var> state 15
  state 15: #1 #4
  state 16: #2
  state 17: #0 #2 #3 #4
	<var>::string state 18
	<app> state 19
	[] state 24
  state 18: #0
  state 19: #3 #4
	<app> state 20
  state 20: #3 #4
	: state 21
  state 21: #3 #4
	<var> state 22
  state 22: #3 #4
	<var> state 23
  state 23: #3 #4
  state 24: #2
}
{
  rule #0: span p s::string = strcat pre,strcat post when pre,post = span p (chars s) end
  rule #1: span p [] = [],[]
  rule #2: span p xs@(_:_) = aux xs with aux xs = split_pre len_pre xs with add x (pre,post) = x:pre,post; split_pre 0 _ = split_tails; split_pre n::int (x:xs) = add x (split_pre (n-1) xs) end when len_pre@_ split_tails = skip_ahead 0 xs end; skip_ahead n::int [] = n ([],[]); skip_ahead n::int xs@(_:_) = n (aux xs) if n==4096; skip_ahead n::int xx@(x:xs) = n ([],xx) if ~p x; skip_ahead n::int xx@(x:xs) = n (x:takewhile p xs&,dropwhile p xs&) if thunkp xs; skip_ahead n::int xx@(x:xs) = skip_ahead (n+1) xs; skip_ahead n::int xs = n (takewhile p xs,dropwhile p xs) end
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var>::string state 2
	<app> state 3
	[] state 8
  state 2: #0
  state 3: #2
	<app> state 4
  state 4: #2
	: state 5
  state 5: #2
	<var> state 6
  state 6: #2
	<var> state 7
  state 7: #2
  state 8: #1
}
{
  rule #0: zip_onto b::string s::string t::string = zip_onto (chars b) (chars s) (chars t)
  rule #1: zip_onto b::string s::string t = zip_onto (chars b) (chars s) t
  rule #2: zip_onto b::string s t::string = zip_onto (chars b) s (chars t)
  rule #3: zip_onto b::string s t = zip_onto (chars b) s t
  rule #4: zip_onto b s::string t::string = zip_onto b (chars s) (chars t)
  rule #5: zip_onto b s::string t = zip_onto b (chars s) t
  rule #6: zip_onto b s t::string = zip_onto b s (chars t)
  rule #7: zip_onto base [] _ = base
  rule #8: zip_onto base _ [] = base
  rule #9: zip_onto base xs@(_:_) ys@(_:_) = __std__::zip (,) base (zip_onto base) xs ys
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9
	<var> state 1
	<var>::string state 34
  state 1: #4 #5 #6 #7 #8 #9
	<var> state 2
	<var>::string state 5
	<app> state 9
	[] state 30
  state 2: #6 #8
	<var>::string state 3
	[] state 4
  state 3: #6
  state 4: #8
  state 5: #4 #5 #6 #8
	<var> state 6
	<var>::string state 7
	[] state 8
  state 6: #5
  state 7: #4 #5 #6
  state 8: #5 #8
  state 9: #6 #8 #9
	<var> state 10
	<app> state 14
  state 10: #6 #8
	<var> state 11
  state 11: #6 #8
	<var>::string state 12
	[] state 13
  state 12: #6
  state 13: #8
  state 14: #6 #8 #9
	<var> state 15
	: state 20
  state 15: #6 #8
	<var> state 16
  state 16: #6 #8
	<var> state 17
  state 17: #6 #8
	<var>::string state 18
	[] state 19
  state 18: #6
  state 19: #8
  state 20: #6 #8 #9
	<var> state 21
  state 21: #6 #8 #9
	<var> state 22
  state 22: #6 #8 #9
	<var>::string state 23
	<app> state 24
	[] state 29
  state 23: #6
  state 24: #9
	<app> state 25
  state 25: #9
	: state 26
  state 26: #9
	<var> state 27
  state 27: #9
	<var> state 28
  state 28: #9
  state 29: #8
  state 30: #6 #7 #8
	<var> state 31
	<var>::string state 32
	[] state 33
  state 31: #7
  state 32: #6 #7
  state 33: #7 #8
  state 34: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9
	<var> state 35
	<var>::string state 39
	<app> state 43
	[] state 72
  state 35: #2 #3 #6 #8
	<var> state 36
	<var>::string state 37
	[] state 38
  state 36: #3
  state 37: #2 #3 #6
  state 38: #3 #8
  state 39: #0 #1 #2 #3 #4 #5 #6 #8
	<var> state 40
	<var>::string state 41
	[] state 42
  state 40: #1 #3 #5
  state 41: #0 #1 #2 #3 #4 #5 #6
  state 42: #1 #3 #5 #8
  state 43: #2 #3 #6 #8 #9
	<var> state 44
	<app> state 49
  state 44: #2 #3 #6 #8
	<var> state 45
  state 45: #2 #3 #6 #8
	<var> state 46
	<var>::string state 47
	[] state 48
  state 46: #3
  state 47: #2 #3 #6
  state 48: #3 #8
  state 49: #2 #3 #6 #8 #9
	<var> state 50
	: state 56
  state 50: #2 #3 #6 #8
	<var> state 51
  state 51: #2 #3 #6 #8
	<var> state 52
  state 52: #2 #3 #6 #8
	<var> state 53
	<var>::string state 54
	[] state 55
  state 53: #3
  state 54: #2 #3 #6
  state 55: #3 #8
  state 56: #2 #3 #6 #8 #9
	<var> state 57
  state 57: #2 #3 #6 #8 #9
	<var> state 58
  state 58: #2 #3 #6 #8 #9
	<var> state 59
	<var>::string state 60
	<app> state 61
	[] state 71
  state 59: #3
  state 60: #2 #3 #6
  state 61: #3 #9
	<var> state 62
	<app> state 64
  state 62: #3
	<var> state 63
  state 63: #3
  state 64: #3 #9
	<var> state 65
	: state 68
  state 65: #3
	<var> state 66
  state 66: #3
	<var> state 67
  state 67: #3
  state 68: #3 #9
	<var> state 69
  state 69: #3 #9
	<var> state 70
  state 70: #3 #9
  state 71: #3 #8
  state 72: #2 #3 #6 #7 #8
	<var> state 73
	<var>::string state 74
	[] state 75
  state 73: #3 #7
  state 74: #2 #3 #6 #7
  state 75: #3 #7 #8
}
{
  rule #0: zip3_onto b::string s::string t::string u::string = zip3_onto (chars b) (chars s) (chars t) (chars u)
  rule #1: zip3_onto b::string s::string t::string u = zip3_onto (chars b) (chars s) (chars t) u
  rule #2: zip3_onto b::string s::string t u::string = zip3_onto (chars b) (chars s) t (chars u)
  rule #3: zip3_onto b::string s::string t u = zip3_onto (chars b) (chars s) t u
  rule #4: zip3_onto b::string s t::string u::string = zip3_onto (chars b) s (chars t) (chars u)
  rule #5: zip3_onto b::string s t::string u = zip3_onto (chars b) s (chars t) u
  rule #6: zip3_onto b::string s t u::string = zip3_onto (chars b) s t (chars u)
  rule #7: zip3_onto b::string s t u = zip3_onto (chars b) s t u
  rule #8: zip3_onto b s::string t::string u::string = zip3_onto b (chars s) (chars t) (chars u)
  rule #9: zip3_onto b s::string t::string u = zip3_onto b (chars s) (chars t) u
  rule #10: zip3_onto b s::string t u::string = zip3_onto b (chars s) t (chars u)
  rule #11: zip3_onto b s::string t u = zip3_onto b (chars s) t u
  rule #12: zip3_onto b s t::string u::string = zip3_onto b s (chars t) (chars u)
  rule #13: zip3_onto b s t::string u = zip3_onto b s (chars t) u
  rule #14: zip3_onto b s t u::string = zip3_onto b s t (chars u)
  rule #15: zip3_onto base [] _ _ = base
  rule #16: zip3_onto base _ [] _ = base
  rule #17: zip3_onto base _ _ [] = base
  rule #18: zip3_onto base xs@(_:_) ys@(_:_) zs@(_:_) = __std__::zip3 comma base (zip3_onto base) xs ys zs with comma x y z = x,y,z end
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16 #17 #18
	<var> state 1
	<var>::string state 104
  state 1: #8 #9 #10 #11 #12 #13 #14 #15 #16 #17 #18
	<var> state 2
	<var>::string state 14
	<app> state 27
	[] state 91
  state 2: #12 #13 #14 #16 #17
	<var> state 3
	<var>::string state 6
	[] state 10
  state 3: #14 #17
	<var>::string state 4
	[] state 5
  state 4: #14
  state 5: #17
  state 6: #12 #13 #14 #17
	<var> state 7
	<var>::string state 8
	[] state 9
  state 7: #13
  state 8: #12 #13 #14
  state 9: #13 #17
  state 10: #14 #16 #17
	<var> state 11
	<var>::string state 12
	[] state 13
  state 11: #16
  state 12: #14 #16
  state 13: #16 #17
  state 14: #8 #9 #10 #11 #12 #13 #14 #16 #17
	<var> state 15
	<var>::string state 19
	[] state 23
  state 15: #10 #11 #14 #17
	<var> state 16
	<var>::string state 17
	[] state 18
  state 16: #11
  state 17: #10 #11 #14
  state 18: #11 #17
  state 19: #8 #9 #10 #11 #12 #13 #14 #17
	<var> state 20
	<var>::string state 21
	[] state 22
  state 20: #9 #11 #13
  state 21: #8 #9 #10 #11 #12 #13 #14
  state 22: #9 #11 #13 #17
  state 23: #10 #11 #14 #16 #17
	<var> state 24
	<var>::string state 25
	[] state 26
  state 24: #11 #16
  state 25: #10 #11 #14 #16
  state 26: #11 #16 #17
  state 27: #12 #13 #14 #16 #17 #18
	<var> state 28
	<app> state 41
  state 28: #12 #13 #14 #16 #17
	<var> state 29
  state 29: #12 #13 #14 #16 #17
	<var> state 30
	<var>::string state 33
	[] state 37
  state 30: #14 #17
	<var>::string state 31
	[] state 32
  state 31: #14
  state 32: #17
  state 33: #12 #13 #14 #17
	<var> state 34
	<var>::string state 35
	[] state 36
  state 34: #13
  state 35: #12 #13 #14
  state 36: #13 #17
  state 37: #14 #16 #17
	<var> state 38
	<var>::string state 39
	[] state 40
  state 38: #16
  state 39: #14 #16
  state 40: #16 #17
  state 41: #12 #13 #14 #16 #17 #18
	<var> state 42
	: state 56
  state 42: #12 #13 #14 #16 #17
	<var> state 43
  state 43: #12 #13 #14 #16 #17
	<var> state 44
  state 44: #12 #13 #14 #16 #17
	<var> state 45
	<var>::string state 48
	[] state 52
  state 45: #14 #17
	<var>::string state 46
	[] state 47
  state 46: #14
  state 47: #17
  state 48: #12 #13 #14 #17
	<var> state 49
	<var>::string state 50
	[] state 51
  state 49: #13
  state 50: #12 #13 #14
  state 51: #13 #17
  state 52: #14 #16 #17
	<var> state 53
	<var>::string state 54
	[] state 55
  state 53: #16
  state 54: #14 #16
  state 55: #16 #17
  state 56: #12 #13 #14 #16 #17 #18
	<var> state 57
  state 57: #12 #13 #14 #16 #17 #18
	<var> state 58
  state 58: #12 #13 #14 #16 #17 #18
	<var> state 59
	<var>::string state 62
	<app> state 66
	[] state 87
  state 59: #14 #17
	<var>::string state 60
	[] state 61
  state 60: #14
  state 61: #17
  state 62: #12 #13 #14 #17
	<var> state 63
	<var>::string state 64
	[] state 65
  state 63: #13
  state 64: #12 #13 #14
  state 65: #13 #17
  state 66: #14 #17 #18
	<var> state 67
	<app> state 71
  state 67: #14 #17
	<var> state 68
  state 68: #14 #17
	<var>::string state 69
	[] state 70
  state 69: #14
  state 70: #17
  state 71: #14 #17 #18
	<var> state 72
	: state 77
  state 72: #14 #17
	<var> state 73
  state 73: #14 #17
	<var> state 74
  state 74: #14 #17
	<var>::string state 75
	[] state 76
  state 75: #14
  state 76: #17
  state 77: #14 #17 #18
	<var> state 78
  state 78: #14 #17 #18
	<var> state 79
  state 79: #14 #17 #18
	<var>::string state 80
	<app> state 81
	[] state 86
  state 80: #14
  state 81: #18
	<app> state 82
  state 82: #18
	: state 83
  state 83: #18
	<var> state 84
  state 84: #18
	<var> state 85
  state 85: #18
  state 86: #17
  state 87: #14 #16 #17
	<var> state 88
	<var>::string state 89
	[] state 90
  state 88: #16
  state 89: #14 #16
  state 90: #16 #17
  state 91: #12 #13 #14 #15 #16 #17
	<var> state 92
	<var>::string state 96
	[] state 100
  state 92: #14 #15 #17
	<var> state 93
	<var>::string state 94
	[] state 95
  state 93: #15
  state 94: #14 #15
  state 95: #15 #17
  state 96: #12 #13 #14 #15 #17
	<var> state 97
	<var>::string state 98
	[] state 99
  state 97: #13 #15
  state 98: #12 #13 #14 #15
  state 99: #13 #15 #17
  state 100: #14 #15 #16 #17
	<var> state 101
	<var>::string state 102
	[] state 103
  state 101: #15 #16
  state 102: #14 #15 #16
  state 103: #15 #16 #17
  state 104: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16 #17 #18
	<var> state 105
	<var>::string state 118
	<app> state 131
	[] state 206
  state 105: #4 #5 #6 #7 #12 #13 #14 #16 #17
	<var> state 106
	<var>::string state 110
	[] state 114
  state 106: #6 #7 #14 #17
	<var> state 107
	<var>::string state 108
	[] state 109
  state 107: #7
  state 108: #6 #7 #14
  state 109: #7 #17
  state 110: #4 #5 #6 #7 #12 #13 #14 #17
	<var> state 111
	<var>::string state 112
	[] state 113
  state 111: #5 #7 #13
  state 112: #4 #5 #6 #7 #12 #13 #14
  state 113: #5 #7 #13 #17
  state 114: #6 #7 #14 #16 #17
	<var> state 115
	<var>::string state 116
	[] state 117
  state 115: #7 #16
  state 116: #6 #7 #14 #16
  state 117: #7 #16 #17
  state 118: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #16 #17
	<var> state 119
	<var>::string state 123
	[] state 127
  state 119: #2 #3 #6 #7 #10 #11 #14 #17
	<var> state 120
	<var>::string state 121
	[] state 122
  state 120: #3 #7 #11
  state 121: #2 #3 #6 #7 #10 #11 #14
  state 122: #3 #7 #11 #17
  state 123: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #17
	<var> state 124
	<var>::string state 125
	[] state 126
  state 124: #1 #3 #5 #7 #9 #11 #13
  state 125: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14
  state 126: #1 #3 #5 #7 #9 #11 #13 #17
  state 127: #2 #3 #6 #7 #10 #11 #14 #16 #17
	<var> state 128
	<var>::string state 129
	[] state 130
  state 128: #3 #7 #11 #16
  state 129: #2 #3 #6 #7 #10 #11 #14 #16
  state 130: #3 #7 #11 #16 #17
  state 131: #4 #5 #6 #7 #12 #13 #14 #16 #17 #18
	<var> state 132
	<app> state 146
  state 132: #4 #5 #6 #7 #12 #13 #14 #16 #17
	<var> state 133
  state 133: #4 #5 #6 #7 #12 #13 #14 #16 #17
	<var> state 134
	<var>::string state 138
	[] state 142
  state 134: #6 #7 #14 #17
	<var> state 135
	<var>::string state 136
	[] state 137
  state 135: #7
  state 136: #6 #7 #14
  state 137: #7 #17
  state 138: #4 #5 #6 #7 #12 #13 #14 #17
	<var> state 139
	<var>::string state 140
	[] state 141
  state 139: #5 #7 #13
  state 140: #4 #5 #6 #7 #12 #13 #14
  state 141: #5 #7 #13 #17
  state 142: #6 #7 #14 #16 #17
	<var> state 143
	<var>::string state 144
	[] state 145
  state 143: #7 #16
  state 144: #6 #7 #14 #16
  state 145: #7 #16 #17
  state 146: #4 #5 #6 #7 #12 #13 #14 #16 #17 #18
	<var> state 147
	: state 162
  state 147: #4 #5 #6 #7 #12 #13 #14 #16 #17
	<var> state 148
  state 148: #4 #5 #6 #7 #12 #13 #14 #16 #17
	<var> state 149
  state 149: #4 #5 #6 #7 #12 #13 #14 #16 #17
	<var> state 150
	<var>::string state 154
	[] state 158
  state 150: #6 #7 #14 #17
	<var> state 151
	<var>::string state 152
	[] state 153
  state 151: #7
  state 152: #6 #7 #14
  state 153: #7 #17
  state 154: #4 #5 #6 #7 #12 #13 #14 #17
	<var> state 155
	<var>::string state 156
	[] state 157
  state 155: #5 #7 #13
  state 156: #4 #5 #6 #7 #12 #13 #14
  state 157: #5 #7 #13 #17
  state 158: #6 #7 #14 #16 #17
	<var> state 159
	<var>::string state 160
	[] state 161
  state 159: #7 #16
  state 160: #6 #7 #14 #16
  state 161: #7 #16 #17
  state 162: #4 #5 #6 #7 #12 #13 #14 #16 #17 #18
	<var> state 163
  state 163: #4 #5 #6 #7 #12 #13 #14 #16 #17 #18
	<var> state 164
  state 164: #4 #5 #6 #7 #12 #13 #14 #16 #17 #18
	<var> state 165
	<var>::string state 169
	<app> state 173
	[] state 202
  state 165: #6 #7 #14 #17
	<var> state 166
	<var>::string state 167
	[] state 168
  state 166: #7
  state 167: #6 #7 #14
  state 168: #7 #17
  state 169: #4 #5 #6 #7 #12 #13 #14 #17
	<var> state 170
	<var>::string state 171
	[] state 172
  state 170: #5 #7 #13
  state 171: #4 #5 #6 #7 #12 #13 #14
  state 172: #5 #7 #13 #17
  state 173: #6 #7 #14 #17 #18
	<var> state 174
	<app> state 179
  state 174: #6 #7 #14 #17
	<var> state 175
  state 175: #6 #7 #14 #17
	<var> state 176
	<var>::string state 177
	[] state 178
  state 176: #7
  state 177: #6 #7 #14
  state 178: #7 #17
  state 179: #6 #7 #14 #17 #18
	<var> state 180
	: state 186
  state 180: #6 #7 #14 #17
	<var> state 181
  state 181: #6 #7 #14 #17
	<var> state 182
  state 182: #6 #7 #14 #17
	<var> state 183
	<var>::string state 184
	[] state 185
  state 183: #7
  state 184: #6 #7 #14
  state 185: #7 #17
  state 186: #6 #7 #14 #17 #18
	<var> state 187
  state 187: #6 #7 #14 #17 #18
	<var> state 188
  state 188: #6 #7 #14 #17 #18
	<var> state 189
	<var>::string state 190
	<app> state 191
	[] state 201
  state 189: #7
  state 190: #6 #7 #14
  state 191: #7 #18
	<var> state 192
	<app> state 194
  state 192: #7
	<var> state 193
  state 193: #7
  state 194: #7 #18
	<var> state 195
	: state 198
  state 195: #7
	<var> state 196
  state 196: #7
	<var> state 197
  state 197: #7
  state 198: #7 #18
	<var> state 199
  state 199: #7 #18
	<var> state 200
  state 200: #7 #18
  state 201: #7 #17
  state 202: #6 #7 #14 #16 #17
	<var> state 203
	<var>::string state 204
	[] state 205
  state 203: #7 #16
  state 204: #6 #7 #14 #16
  state 205: #7 #16 #17
  state 206: #4 #5 #6 #7 #12 #13 #14 #15 #16 #17
	<var> state 207
	<var>::string state 211
	[] state 215
  state 207: #6 #7 #14 #15 #17
	<var> state 208
	<var>::string state 209
	[] state 210
  state 208: #7 #15
  state 209: #6 #7 #14 #15
  state 210: #7 #15 #17
  state 211: #4 #5 #6 #7 #12 #13 #14 #15 #17
	<var> state 212
	<var>::string state 213
	[] state 214
  state 212: #5 #7 #13 #15
  state 213: #4 #5 #6 #7 #12 #13 #14 #15
  state 214: #5 #7 #13 #15 #17
  state 215: #6 #7 #14 #15 #16 #17
	<var> state 216
	<var>::string state 217
	[] state 218
  state 216: #7 #15 #16
  state 217: #6 #7 #14 #15 #16
  state 218: #7 #15 #16 #17
}
{
  rule #0: zipwith_onto f b::string s::string t::string = zipwith_onto f (chars b) (chars s) (chars t)
  rule #1: zipwith_onto f b::string s::string t = zipwith_onto f (chars b) (chars s) t
  rule #2: zipwith_onto f b::string s t::string = zipwith_onto f (chars b) s (chars t)
  rule #3: zipwith_onto f b::string s t = zipwith_onto f (chars b) s t
  rule #4: zipwith_onto f b s::string t::string = zipwith_onto f b (chars s) (chars t)
  rule #5: zipwith_onto f b s::string t = zipwith_onto f b (chars s) t
  rule #6: zipwith_onto f b s t::string = zipwith_onto f b s (chars t)
  rule #7: zipwith_onto f base [] _ = base
  rule #8: zipwith_onto f base _ [] = base
  rule #9: zipwith_onto f base xs@(_:_) ys@(_:_) = __std__::zip f base (zipwith_onto f base) xs ys
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9
	<var> state 2
	<var>::string state 35
  state 2: #4 #5 #6 #7 #8 #9
	<var> state 3
	<var>::string state 6
	<app> state 10
	[] state 31
  state 3: #6 #8
	<var>::string state 4
	[] state 5
  state 4: #6
  state 5: #8
  state 6: #4 #5 #6 #8
	<var> state 7
	<var>::string state 8
	[] state 9
  state 7: #5
  state 8: #4 #5 #6
  state 9: #5 #8
  state 10: #6 #8 #9
	<var> state 11
	<app> state 15
  state 11: #6 #8
	<var> state 12
  state 12: #6 #8
	<var>::string state 13
	[] state 14
  state 13: #6
  state 14: #8
  state 15: #6 #8 #9
	<var> state 16
	: state 21
  state 16: #6 #8
	<var> state 17
  state 17: #6 #8
	<var> state 18
  state 18: #6 #8
	<var>::string state 19
	[] state 20
  state 19: #6
  state 20: #8
  state 21: #6 #8 #9
	<var> state 22
  state 22: #6 #8 #9
	<var> state 23
  state 23: #6 #8 #9
	<var>::string state 24
	<app> state 25
	[] state 30
  state 24: #6
  state 25: #9
	<app> state 26
  state 26: #9
	: state 27
  state 27: #9
	<var> state 28
  state 28: #9
	<var> state 29
  state 29: #9
  state 30: #8
  state 31: #6 #7 #8
	<var> state 32
	<var>::string state 33
	[] state 34
  state 32: #7
  state 33: #6 #7
  state 34: #7 #8
  state 35: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9
	<var> state 36
	<var>::string state 40
	<app> state 44
	[] state 73
  state 36: #2 #3 #6 #8
	<var> state 37
	<var>::string state 38
	[] state 39
  state 37: #3
  state 38: #2 #3 #6
  state 39: #3 #8
  state 40: #0 #1 #2 #3 #4 #5 #6 #8
	<var> state 41
	<var>::string state 42
	[] state 43
  state 41: #1 #3 #5
  state 42: #0 #1 #2 #3 #4 #5 #6
  state 43: #1 #3 #5 #8
  state 44: #2 #3 #6 #8 #9
	<var> state 45
	<app> state 50
  state 45: #2 #3 #6 #8
	<var> state 46
  state 46: #2 #3 #6 #8
	<var> state 47
	<var>::string state 48
	[] state 49
  state 47: #3
  state 48: #2 #3 #6
  state 49: #3 #8
  state 50: #2 #3 #6 #8 #9
	<var> state 51
	: state 57
  state 51: #2 #3 #6 #8
	<var> state 52
  state 52: #2 #3 #6 #8
	<var> state 53
  state 53: #2 #3 #6 #8
	<var> state 54
	<var>::string state 55
	[] state 56
  state 54: #3
  state 55: #2 #3 #6
  state 56: #3 #8
  state 57: #2 #3 #6 #8 #9
	<var> state 58
  state 58: #2 #3 #6 #8 #9
	<var> state 59
  state 59: #2 #3 #6 #8 #9
	<var> state 60
	<var>::string state 61
	<app> state 62
	[] state 72
  state 60: #3
  state 61: #2 #3 #6
  state 62: #3 #9
	<var> state 63
	<app> state 65
  state 63: #3
	<var> state 64
  state 64: #3
  state 65: #3 #9
	<var> state 66
	: state 69
  state 66: #3
	<var> state 67
  state 67: #3
	<var> state 68
  state 68: #3
  state 69: #3 #9
	<var> state 70
  state 70: #3 #9
	<var> state 71
  state 71: #3 #9
  state 72: #3 #8
  state 73: #2 #3 #6 #7 #8
	<var> state 74
	<var>::string state 75
	[] state 76
  state 74: #3 #7
  state 75: #2 #3 #6 #7
  state 76: #3 #7 #8
}
{
  rule #0: zipwith3_onto f b::string s::string t::string u::string = zipwith3_onto f (chars b) (chars s) (chars t) (chars u)
  rule #1: zipwith3_onto f b::string s::string t::string u = zipwith3_onto f (chars b) (chars s) (chars t) u
  rule #2: zipwith3_onto f b::string s::string t u::string = zipwith3_onto f (chars b) (chars s) t (chars u)
  rule #3: zipwith3_onto f b::string s::string t u = zipwith3_onto f (chars b) (chars s) t u
  rule #4: zipwith3_onto f b::string s t::string u::string = zipwith3_onto f (chars b) s (chars t) (chars u)
  rule #5: zipwith3_onto f b::string s t::string u = zipwith3_onto f (chars b) s (chars t) u
  rule #6: zipwith3_onto f b::string s t u::string = zipwith3_onto f (chars b) s t (chars u)
  rule #7: zipwith3_onto f b::string s t u = zipwith3_onto f (chars b) s t u
  rule #8: zipwith3_onto f b s::string t::string u::string = zipwith3_onto f b (chars s) (chars t) (chars u)
  rule #9: zipwith3_onto f b s::string t::string u = zipwith3_onto f b (chars s) (chars t) u
  rule #10: zipwith3_onto f b s::string t u::string = zipwith3_onto f b (chars s) t (chars u)
  rule #11: zipwith3_onto f b s::string t u = zipwith3_onto f b (chars s) t u
  rule #12: zipwith3_onto f b s t::string u::string = zipwith3_onto f b s (chars t) (chars u)
  rule #13: zipwith3_onto f b s t::string u = zipwith3_onto f b s (chars t) u
  rule #14: zipwith3_onto f b s t u::string = zipwith3_onto f b s t (chars u)
  rule #15: zipwith3_onto f base [] _ _ = base
  rule #16: zipwith3_onto f base _ [] _ = base
  rule #17: zipwith3_onto f base _ _ [] = base
  rule #18: zipwith3_onto f base xs@(_:_) ys@(_:_) zs@(_:_) = __std__::zip3 f base (zipwith3_onto f base) xs ys zs
  state 0: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16 #17 #18
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16 #17 #18
	<var> state 2
	<var>::string state 105
  state 2: #8 #9 #10 #11 #12 #13 #14 #15 #16 #17 #18
	<var> state 3
	<var>::string state 15
	<app> state 28
	[] state 92
  state 3: #12 #13 #14 #16 #17
	<var> state 4
	<var>::string state 7
	[] state 11
  state 4: #14 #17
	<var>::string state 5
	[] state 6
  state 5: #14
  state 6: #17
  state 7: #12 #13 #14 #17
	<var> state 8
	<var>::string state 9
	[] state 10
  state 8: #13
  state 9: #12 #13 #14
  state 10: #13 #17
  state 11: #14 #16 #17
	<var> state 12
	<var>::string state 13
	[] state 14
  state 12: #16
  state 13: #14 #16
  state 14: #16 #17
  state 15: #8 #9 #10 #11 #12 #13 #14 #16 #17
	<var> state 16
	<var>::string state 20
	[] state 24
  state 16: #10 #11 #14 #17
	<var> state 17
	<var>::string state 18
	[] state 19
  state 17: #11
  state 18: #10 #11 #14
  state 19: #11 #17
  state 20: #8 #9 #10 #11 #12 #13 #14 #17
	<var> state 21
	<var>::string state 22
	[] state 23
  state 21: #9 #11 #13
  state 22: #8 #9 #10 #11 #12 #13 #14
  state 23: #9 #11 #13 #17
  state 24: #10 #11 #14 #16 #17
	<var> state 25
	<var>::string state 26
	[] state 27
  state 25: #11 #16
  state 26: #10 #11 #14 #16
  state 27: #11 #16 #17
  state 28: #12 #13 #14 #16 #17 #18
	<var> state 29
	<app> state 42
  state 29: #12 #13 #14 #16 #17
	<var> state 30
  state 30: #12 #13 #14 #16 #17
	<var> state 31
	<var>::string state 34
	[] state 38
  state 31: #14 #17
	<var>::string state 32
	[] state 33
  state 32: #14
  state 33: #17
  state 34: #12 #13 #14 #17
	<var> state 35
	<var>::string state 36
	[] state 37
  state 35: #13
  state 36: #12 #13 #14
  state 37: #13 #17
  state 38: #14 #16 #17
	<var> state 39
	<var>::string state 40
	[] state 41
  state 39: #16
  state 40: #14 #16
  state 41: #16 #17
  state 42: #12 #13 #14 #16 #17 #18
	<var> state 43
	: state 57
  state 43: #12 #13 #14 #16 #17
	<var> state 44
  state 44: #12 #13 #14 #16 #17
	<var> state 45
  state 45: #12 #13 #14 #16 #17
	<var> state 46
	<var>::string state 49
	[] state 53
  state 46: #14 #17
	<var>::string state 47
	[] state 48
  state 47: #14
  state 48: #17
  state 49: #12 #13 #14 #17
	<var> state 50
	<var>::string state 51
	[] state 52
  state 50: #13
  state 51: #12 #13 #14
  state 52: #13 #17
  state 53: #14 #16 #17
	<var> state 54
	<var>::string state 55
	[] state 56
  state 54: #16
  state 55: #14 #16
  state 56: #16 #17
  state 57: #12 #13 #14 #16 #17 #18
	<var> state 58
  state 58: #12 #13 #14 #16 #17 #18
	<var> state 59
  state 59: #12 #13 #14 #16 #17 #18
	<var> state 60
	<var>::string state 63
	<app> state 67
	[] state 88
  state 60: #14 #17
	<var>::string state 61
	[] state 62
  state 61: #14
  state 62: #17
  state 63: #12 #13 #14 #17
	<var> state 64
	<var>::string state 65
	[] state 66
  state 64: #13
  state 65: #12 #13 #14
  state 66: #13 #17
  state 67: #14 #17 #18
	<var> state 68
	<app> state 72
  state 68: #14 #17
	<var> state 69
  state 69: #14 #17
	<var>::string state 70
	[] state 71
  state 70: #14
  state 71: #17
  state 72: #14 #17 #18
	<var> state 73
	: state 78
  state 73: #14 #17
	<var> state 74
  state 74: #14 #17
	<var> state 75
  state 75: #14 #17
	<var>::string state 76
	[] state 77
  state 76: #14
  state 77: #17
  state 78: #14 #17 #18
	<var> state 79
  state 79: #14 #17 #18
	<var> state 80
  state 80: #14 #17 #18
	<var>::string state 81
	<app> state 82
	[] state 87
  state 81: #14
  state 82: #18
	<app> state 83
  state 83: #18
	: state 84
  state 84: #18
	<var> state 85
  state 85: #18
	<var> state 86
  state 86: #18
  state 87: #17
  state 88: #14 #16 #17
	<var> state 89
	<var>::string state 90
	[] state 91
  state 89: #16
  state 90: #14 #16
  state 91: #16 #17
  state 92: #12 #13 #14 #15 #16 #17
	<var> state 93
	<var>::string state 97
	[] state 101
  state 93: #14 #15 #17
	<var> state 94
	<var>::string state 95
	[] state 96
  state 94: #15
  state 95: #14 #15
  state 96: #15 #17
  state 97: #12 #13 #14 #15 #17
	<var> state 98
	<var>::string state 99
	[] state 100
  state 98: #13 #15
  state 99: #12 #13 #14 #15
  state 100: #13 #15 #17
  state 101: #14 #15 #16 #17
	<var> state 102
	<var>::string state 103
	[] state 104
  state 102: #15 #16
  state 103: #14 #15 #16
  state 104: #15 #16 #17
  state 105: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16 #17 #18
	<var> state 106
	<var>::string state 119
	<app> state 132
	[] state 207
  state 106: #4 #5 #6 #7 #12 #13 #14 #16 #17
	<var> state 107
	<var>::string state 111
	[] state 115
  state 107: #6 #7 #14 #17
	<var> state 108
	<var>::string state 109
	[] state 110
  state 108: #7
  state 109: #6 #7 #14
  state 110: #7 #17
  state 111: #4 #5 #6 #7 #12 #13 #14 #17
	<var> state 112
	<var>::string state 113
	[] state 114
  state 112: #5 #7 #13
  state 113: #4 #5 #6 #7 #12 #13 #14
  state 114: #5 #7 #13 #17
  state 115: #6 #7 #14 #16 #17
	<var> state 116
	<var>::string state 117
	[] state 118
  state 116: #7 #16
  state 117: #6 #7 #14 #16
  state 118: #7 #16 #17
  state 119: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #16 #17
	<var> state 120
	<var>::string state 124
	[] state 128
  state 120: #2 #3 #6 #7 #10 #11 #14 #17
	<var> state 121
	<var>::string state 122
	[] state 123
  state 121: #3 #7 #11
  state 122: #2 #3 #6 #7 #10 #11 #14
  state 123: #3 #7 #11 #17
  state 124: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #17
	<var> state 125
	<var>::string state 126
	[] state 127
  state 125: #1 #3 #5 #7 #9 #11 #13
  state 126: #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14
  state 127: #1 #3 #5 #7 #9 #11 #13 #17
  state 128: #2 #3 #6 #7 #10 #11 #14 #16 #17
	<var> state 129
	<var>::string state 130
	[] state 131
  state 129: #3 #7 #11 #16
  state 130: #2 #3 #6 #7 #10 #11 #14 #16
  state 131: #3 #7 #11 #16 #17
  state 132: #4 #5 #6 #7 #12 #13 #14 #16 #17 #18
	<var> state 133
	<app> state 147
  state 133: #4 #5 #6 #7 #12 #13 #14 #16 #17
	<var> state 134
  state 134: #4 #5 #6 #7 #12 #13 #14 #16 #17
	<var> state 135
	<var>::string state 139
	[] state 143
  state 135: #6 #7 #14 #17
	<var> state 136
	<var>::string state 137
	[] state 138
  state 136: #7
  state 137: #6 #7 #14
  state 138: #7 #17
  state 139: #4 #5 #6 #7 #12 #13 #14 #17
	<var> state 140
	<var>::string state 141
	[] state 142
  state 140: #5 #7 #13
  state 141: #4 #5 #6 #7 #12 #13 #14
  state 142: #5 #7 #13 #17
  state 143: #6 #7 #14 #16 #17
	<var> state 144
	<var>::string state 145
	[] state 146
  state 144: #7 #16
  state 145: #6 #7 #14 #16
  state 146: #7 #16 #17
  state 147: #4 #5 #6 #7 #12 #13 #14 #16 #17 #18
	<var> state 148
	: state 163
  state 148: #4 #5 #6 #7 #12 #13 #14 #16 #17
	<var> state 149
  state 149: #4 #5 #6 #7 #12 #13 #14 #16 #17
	<var> state 150
  state 150: #4 #5 #6 #7 #12 #13 #14 #16 #17
	<var> state 151
	<var>::string state 155
	[] state 159
  state 151: #6 #7 #14 #17
	<var> state 152
	<var>::string state 153
	[] state 154
  state 152: #7
  state 153: #6 #7 #14
  state 154: #7 #17
  state 155: #4 #5 #6 #7 #12 #13 #14 #17
	<var> state 156
	<var>::string state 157
	[] state 158
  state 156: #5 #7 #13
  state 157: #4 #5 #6 #7 #12 #13 #14
  state 158: #5 #7 #13 #17
  state 159: #6 #7 #14 #16 #17
	<var> state 160
	<var>::string state 161
	[] state 162
  state 160: #7 #16
  state 161: #6 #7 #14 #16
  state 162: #7 #16 #17
  state 163: #4 #5 #6 #7 #12 #13 #14 #16 #17 #18
	<var> state 164
  state 164: #4 #5 #6 #7 #12 #13 #14 #16 #17 #18
	<var> state 165
  state 165: #4 #5 #6 #7 #12 #13 #14 #16 #17 #18
	<var> state 166
	<var>::string state 170
	<app> state 174
	[] state 203
  state 166: #6 #7 #14 #17
	<var> state 167
	<var>::string state 168
	[] state 169
  state 167: #7
  state 168: #6 #7 #14
  state 169: #7 #17
  state 170: #4 #5 #6 #7 #12 #13 #14 #17
	<var> state 171
	<var>::string state 172
	[] state 173
  state 171: #5 #7 #13
  state 172: #4 #5 #6 #7 #12 #13 #14
  state 173: #5 #7 #13 #17
  state 174: #6 #7 #14 #17 #18
	<var> state 175
	<app> state 180
  state 175: #6 #7 #14 #17
	<var> state 176
  state 176: #6 #7 #14 #17
	<var> state 177
	<var>::string state 178
	[] state 179
  state 177: #7
  state 178: #6 #7 #14
  state 179: #7 #17
  state 180: #6 #7 #14 #17 #18
	<var> state 181
	: state 187
  state 181: #6 #7 #14 #17
	<var> state 182
  state 182: #6 #7 #14 #17
	<var> state 183
  state 183: #6 #7 #14 #17
	<var> state 184
	<var>::string state 185
	[] state 186
  state 184: #7
  state 185: #6 #7 #14
  state 186: #7 #17
  state 187: #6 #7 #14 #17 #18
	<var> state 188
  state 188: #6 #7 #14 #17 #18
	<var> state 189
  state 189: #6 #7 #14 #17 #18
	<var> state 190
	<var>::string state 191
	<app> state 192
	[] state 202
  state 190: #7
  state 191: #6 #7 #14
  state 192: #7 #18
	<var> state 193
	<app> state 195
  state 193: #7
	<var> state 194
  state 194: #7
  state 195: #7 #18
	<var> state 196
	: state 199
  state 196: #7
	<var> state 197
  state 197: #7
	<var> state 198
  state 198: #7
  state 199: #7 #18
	<var> state 200
  state 200: #7 #18
	<var> state 201
  state 201: #7 #18
  state 202: #7 #17
  state 203: #6 #7 #14 #16 #17
	<var> state 204
	<var>::string state 205
	[] state 206
  state 204: #7 #16
  state 205: #6 #7 #14 #16
  state 206: #7 #16 #17
  state 207: #4 #5 #6 #7 #12 #13 #14 #15 #16 #17
	<var> state 208
	<var>::string state 212
	[] state 216
  state 208: #6 #7 #14 #15 #17
	<var> state 209
	<var>::string state 210
	[] state 211
  state 209: #7 #15
  state 210: #6 #7 #14 #15
  state 211: #7 #15 #17
  state 212: #4 #5 #6 #7 #12 #13 #14 #15 #17
	<var> state 213
	<var>::string state 214
	[] state 215
  state 213: #5 #7 #13 #15
  state 214: #4 #5 #6 #7 #12 #13 #14 #15
  state 215: #5 #7 #13 #15 #17
  state 216: #6 #7 #14 #15 #16 #17
	<var> state 217
	<var>::string state 218
	[] state 219
  state 217: #7 #15 #16
  state 218: #6 #7 #14 #15 #16
  state 219: #7 #15 #16 #17
}
{
  rule #0: iterate f x = x:iterate f (f x)&
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: iterwhile p f x = accum [] p f x with accum xs p f x = accum (x:xs) p f (f x) if p x; accum xs p f x = __std__::reverse_onto [] xs end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
}
{
  rule #0: repeat x = x:repeat x&
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: iteraten n::int f x = [] if n<=0
  rule #1: iteraten n::int f x = accum [] n f x with accum xs n::int f x = __std__::reverse_onto [] (x:xs) if n==1; accum xs n::int f x = accum (x:xs) (n-1) f (f x) end
  state 0: #0 #1
	<var>::int state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
	<var> state 3
  state 3: #0 #1
}
{
  rule #0: repeatn n::int x = accum [] n x with accum xs n::int x = xs if n<=0; accum xs n::int x = accum (x:xs) (n-1) x end
  state 0: #0
	<var>::int state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
{
  rule #0: __std__::zip f base improper xs@(_:_) ys@(_:_) = aux xs ys with aux xs ys = zip_pre len_pre xs ys with zip_pre 0 _ _ = zipped_tail; zip_pre n::int (x:xs) (y:ys) = f x y:zip_pre (n-1) xs ys end when len_pre@_ zipped_tail = skip_ahead 0 xs ys end; skip_ahead n::int [] _ = n base; skip_ahead n::int _ [] = n base; skip_ahead n::int xs@(_:_) ys@(_:_) = n (aux xs ys) if n==4096; skip_ahead n::int (x:xs) (y:ys) = n (f x y:aux xs ys&) if thunkp xs||thunkp ys; skip_ahead n::int (x:xs) (y:ys) = skip_ahead (n+1) xs ys; skip_ahead n::int xs ys = n (improper xs ys) end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
	<app> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	: state 6
  state 6: #0
	<var> state 7
  state 7: #0
	<var> state 8
  state 8: #0
	<app> state 9
  state 9: #0
	<app> state 10
  state 10: #0
	: state 11
  state 11: #0
	<var> state 12
  state 12: #0
	<var> state 13
  state 13: #0
}
{
  rule #0: __std__::zip3 f base improper xs@(_:_) ys@(_:_) zs@(_:_) = aux xs ys zs with aux xs ys zs = zip_pre len_pre xs ys zs with zip_pre 0 _ _ _ = zipped_tail; zip_pre n::int (x:xs) (y:ys) (z:zs) = f x y z:zip_pre (n-1) xs ys zs end when len_pre@_ zipped_tail = skip_ahead 0 xs ys zs end; skip_ahead n::int [] _ _ = n base; skip_ahead n::int _ [] _ = n base; skip_ahead n::int _ _ [] = n base; skip_ahead n::int xs@(_:_) ys@(_:_) zs@(_:_) = n (aux xs ys zs) if n==4096; skip_ahead n::int (x:xs) (y:ys) (z:zs) = n (f x y z:aux xs ys zs&) if thunkp xs||thunkp ys||thunkp zs; skip_ahead n::int (x:xs) (y:ys) (z:zs) = skip_ahead (n+1) xs ys zs; skip_ahead n::int xs ys zs = n (improper xs ys zs) end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
	<app> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	: state 6
  state 6: #0
	<var> state 7
  state 7: #0
	<var> state 8
  state 8: #0
	<app> state 9
  state 9: #0
	<app> state 10
  state 10: #0
	: state 11
  state 11: #0
	<var> state 12
  state 12: #0
	<var> state 13
  state 13: #0
	<app> state 14
  state 14: #0
	<app> state 15
  state 15: #0
	: state 16
  state 16: #0
	<var> state 17
  state 17: #0
	<var> state 18
  state 18: #0
}
{
  rule #0: catstream [] = []
  rule #1: catstream ((x:xs):yss) = x:catstream (xs:yss)&
  rule #2: catstream ([]:yss) = catstream yss
  rule #3: catstream (xs::string:yss) = catstream (chars xs:yss)
  rule #4: catstream (xs:yss) = xs+catstream yss
  state 0: #0 #1 #2 #3 #4
	<app> state 1
	[] state 23
  state 1: #1 #2 #3 #4
	<app> state 2
  state 2: #1 #2 #3 #4
	: state 3
  state 3: #1 #2 #3 #4
	<var> state 4
	<var>::string state 6
	<app> state 8
	[] state 21
  state 4: #4
	<var> state 5
  state 5: #4
  state 6: #3 #4
	<var> state 7
  state 7: #3 #4
  state 8: #1 #4
	<var> state 9
	<app> state 12
  state 9: #4
	<var> state 10
  state 10: #4
	<var> state 11
  state 11: #4
  state 12: #1 #4
	<var> state 13
	: state 17
  state 13: #4
	<var> state 14
  state 14: #4
	<var> state 15
  state 15: #4
	<var> state 16
  state 16: #4
  state 17: #1 #4
	<var> state 18
  state 18: #1 #4
	<var> state 19
  state 19: #1 #4
	<var> state 20
  state 20: #1 #4
  state 21: #2 #4
	<var> state 22
  state 22: #2 #4
  state 23: #0
}
const __std__::__voidfun__ = void;
def __std__::__voidchk__ x/*0:1*/ = __std__::__voidchk2__ x/*0:1*/;
def __std__::__voidchk2__ x/*0:01*/ y/*0:1*/ = __std__::__voidfun__ y/*0:1*/;
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(listmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(rowmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(colmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(catmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(rowcatmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(colcatmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__$__lambda__ [x/*0:10101*/] (void y/*0:11*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ z/*0:1101*/ [])) = __std__::__do__$__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ (void z/*0:1101*/) ());
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ z/*0:1101*/ {})) = __std__::__do__$__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ (void z/*0:1101*/) ());
def __std__::__do__ (__lambda__ [x/*0:10101*/] (void y/*0:111*/)) = __std__::__do__ (__lambda__ [x/*0:10101*/] y/*0:111*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__std__::__voidfun__ y/*0:111*/)) = __std__::__do__ (__lambda__ [x/*0:10101*/] y/*0:111*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ (void z/*0:11011*/) ())) = __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ z/*0:11011*/ ()));
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ (__std__::__voidfun__ z/*0:11011*/) ())) = __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ z/*0:11011*/ ()));
def __std__::__do__ f/*0:1*/ = do f/*0:1*/;
__C::pure_quoted_symbol s/*0:1*/ :: string = __C::pure_quoted_symbol id/*0:*/ if id/*0:*/>0 when id/*0:*/ :: int = __C::pure_getsym s/*0:1*/ {
  rule #0: id::int = __C::pure_getsym s
  state 0: #0
	<var>::int state 1
  state 1: #0
} end;
globsym pat/*0:01*/ :: string level/*0:1*/ :: int = uniq/*2*/ (catmap descr/*2*/ info/*0:*/) when res/*0:*/ = evalcmd ("show -gst"+str level/*0:1*/+" "+pat/*0:01*/); stringp res/*0:*/||throw evalcmd; info/*0:*/ = init (init (split "\n" res/*0:*/)) {
  rule #0: info = init (init (split "\n" res))
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: _ = stringp res||throw evalcmd
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: res = evalcmd ("show -gst"+str level+" "+pat)
  state 0: #0
	<var> state 1
  state 1: #0
} end with uniq (x/*0:101*/:xs@(y/*0:1101*/:_/*0:111*/)) = if x/*0:101*/===y/*0:1101*/ then uniq/*1*/ xs/*0:11*/ else x/*0:101*/:uniq/*1*/ xs/*0:11*/; uniq xs/*0:1*/ = xs/*0:1*/ {
  rule #0: uniq (x:xs@(y:_)) = if x===y then uniq xs else x:uniq xs
  rule #1: uniq xs = xs
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	: state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
	<app> state 12
  state 11: #1
  state 12: #0 #1
	<var> state 13
	<app> state 15
  state 13: #1
	<var> state 14
  state 14: #1
  state 15: #0 #1
	<var> state 16
	: state 19
  state 16: #1
	<var> state 17
  state 17: #1
	<var> state 18
  state 18: #1
  state 19: #0 #1
	<var> state 20
  state 20: #0 #1
	<var> state 21
  state 21: #0 #1
}; descr s/*0:1*/ :: string = case filter (flip (~=) "") (split " " s/*0:1*/) of sym/*0:01*/:_/*0:1*/ = if any (flip (==) sym/*0:01*/) ["extern","private","infix","infixl","infixr","prefix","postfix","outfix","nonfix"] then [] else catmap (\x/*0:1*/ -> if symbolp x/*0:1*/ then [x/*0:1*/] else [] {
  rule #0: _ x = if symbolp x then [x] else []
  state 0: #0
	<var> state 1
  state 1: #0
}) [__C::pure_quoted_symbol sym/*0:01*/]; _/*0:*/ = [] {
  rule #0: sym:_ = if any (flip (==) sym) ["extern","private","infix","infixl","infixr","prefix","postfix","outfix","nonfix"] then [] else catmap (\x -> if symbolp x then [x] else []) [__C::pure_quoted_symbol sym]
  rule #1: _ = []
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	: state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
} end {
  rule #0: descr s::string = case filter (flip (~=) "") (split " " s) of sym:_ = if any (flip (==) sym) ["extern","private","infix","infixl","infixr","prefix","postfix","outfix","nonfix"] then [] else catmap (\x -> if symbolp x then [x] else []) [__C::pure_quoted_symbol sym]; _ = [] end
  state 0: #0
	<var>::string state 1
  state 1: #0
} end;
clearsym sym/*0:01*/ :: string level/*0:1*/ :: int = () when res/*0:*/ = evalcmd ("clear -t"+str level/*0:1*/+" "+sym/*0:01*/); stringp res/*0:*/||throw evalcmd {
  rule #0: _ = stringp res||throw evalcmd
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: res = evalcmd ("clear -t"+str level+" "+sym)
  state 0: #0
	<var> state 1
  state 1: #0
} end;
clearsym sym/*0:01*/ :: symbol level/*0:1*/ :: int = clearsym sym/*0:*/ level/*2:1*/ when sym/*0:*/ = str sym/*0:01*/; sym/*0:*/ = if sym/*0:*/!0=="(" then substr sym/*0:*/ 2 (#sym/*0:*/-2) else sym/*0:*/ {
  rule #0: sym = if sym!0=="(" then substr sym 2 (#sym-2) else sym
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: sym = str sym
  state 0: #0
	<var> state 1
  state 1: #0
} end;
