
/* Basic list functions. */

/* Copyright (c) 2008-2012 by Albert Graef <Dr.Graef@t-online.de>.
   Copyright (c) 2012 by Dubiousjim <dubiousjim@gmail.com>.

   This file is part of the Pure standard library.

   The Pure standard library is free software: you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
   more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */


/* We default to using the existing, reverse-based algorithms. If one
   runs the interpreter using ``--enable=list-opt``, we instead use
   algorithms based on the skip-ahead technique described at
   <http://ocaml.janestreet.com/?q=node/71>. This protects against
   stack overflows without needing to reverse, gaining some speed
   and using substantially less memory.

   Note that with ``--enable=list-opt``, you no longer are guaranteed
   left-to-right evaluation order for `map` and `catmap`. If you need
   that, you can just explicitly use `foldl` and `reverse`, or
   disable the optimizations.
*/

#! --if list-opt
namespace __std__ with const SKIPSIZE = 4096; end;
#! --endif


/* List reversal. This is a strict operation, of course, so it will loop on
   infinite lists. Also, this is one of the few list operations which throws
   an exception for improper lists, since in that case there really isn't any
   meaningful value to return. */

reverse []	= [];
reverse (x:xs)	= accum [x] xs with
  accum ys (x:xs)	= accum (x:ys) xs;
  accum ys []		= ys;
  accum	ys xs		= throw (bad_list_value xs);
end;


/* List concatenation. For a robust implementation which works with both
   ordinary lists and streams, we want this to be tail-recursive *and*
   non-strict. */
[]+ys		= ys;
#! --ifnot list-opt
/* This implementation first walks down the list, popping elements from the first
   operand until we find an empty or thunked tail ('tick'), then walk back up
   again, pushing elements in front of the result list ('tack'). */
xs@(_:_)+ys	= tick [] xs ys
with
  tick zs (x:xs) ys	= tack (x:zs) ((xs+ys)&) if thunkp xs;
			= tick (x:zs) xs ys;
  tick zs [] ys		= tack zs ys;
  /* Handle an improper list tail (xs+ys is in normal form here). */
  tick zs xs ys		= tack zs (xs+ys);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

#! --else
// skip-ahead
xs@(_:_)+ys = aux xs with
    aux xs = fold_pre len_pre xs with
        fold_pre 0 _           = folded_tail;
        fold_pre n::int (x:xs) = x:fold_pre (n-1) xs;
    end when
        len_pre@_ folded_tail  = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n ys;
    skip_ahead n::int xs@(_:_) = n (aux xs) if n== __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n (x:aux xs&) if thunkp xs;
                               = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (xs+ys);
end;
#! --endif


/* ..

   List Functions
   --------------

   This mostly comes straight from the Q prelude which in turn was based on
   the first edition of the Bird/Wadler book, and is very similar to what you
   can find in the Haskell prelude. Some functions have slightly different
   names, though, and of course everything is typed dynamically.

   Common List Functions
   ~~~~~~~~~~~~~~~~~~~~~

   .. function:: any p xs

      test whether the predicate ``p`` holds for any of the members of ``xs``

   .. function:: all p xs

      test whether the predicate ``p`` holds for all of the members of ``xs``

   .. function:: cat xs

      concatenate a list of lists

   .. function:: catmap f xs

      convenience function which combines '\ :func:`cat`\ ' and
      '\ :func:`map`\ '; this is also used to implement list comprehensions

   .. function:: delete xs y

      return ``xs`` without the first member satisfying ``(y==?)``;
      if no member matches ``y``, will just return ``xs``

   .. function:: do f xs

      apply ``f`` to all members of ``xs``, like '\ :func:`map`\ ', but throw
      away all intermediate results and return ``()``

   .. function:: drop n xs

      remove ``n`` elements from the front of ``xs``

   .. function:: dropwhile p xs

      remove elements from the front of ``xs`` while the predicate ``p`` is
      satisfied

   .. function:: filter p xs

      return the list of all members of ``xs`` satisfying the predicate ``p``

   .. function:: foldl f a xs

      accumulate the binary function ``f`` over all members of ``xs``,
      starting from the initial value ``a`` and working from the front of the
      list towards its end

   .. function:: foldl1 f xs

      accumulate the binary function ``f`` over all members of ``xs``,
      starting from the value ``head xs`` and working from the front of the
      list towards its end; ``xs`` must be nonempty

   .. function:: foldr f a xs

      accumulate the binary function ``f`` over all members of ``xs``,
      starting from the initial value ``a`` and working from the end of the
      list towards its front

   .. function:: foldr1 f xs

      accumulate the binary function ``f`` over all members of ``xs``,
      starting from the value ``last xs`` and working from the end of the list
      towards its front; ``xs`` must be nonempty

   .. function:: head xs

      return the first element of ``xs``; ``xs`` must be nonempty

   .. function:: index xs x

      search for an occurrence of ``x`` in ``xs`` and return the index of the
      first occurrence, if any, ``-1`` otherwise

      This uses '\ :func:`==?`\ ' to decide whether a member of ``xs``
      is an occurrence of ``x``.

   .. function:: init xs

      return all but the last element of ``xs``; ``xs`` must be nonempty

   .. function:: last xs

      return the last element of ``xs``; ``xs`` must be nonempty

   .. function:: listmap f xs

      convenience function which works like :func:`map`, but also deals with
      matrix and string arguments while ensuring that the result is always a
      list; this is primarily used to implement list comprehensions

   .. function:: map f xs

      apply ``f`` to each member of ``xs``

   .. function:: member xs x

      return whether ``x`` is a member of ``xs``

      Note: This uses :func:`==?` to decide whether a member of ``xs``
      is an occurrence of ``x``.

   .. function:: scanl f a xs

      accumulate the binary function ``f`` over all members of ``xs``, as with
      :func:`foldl`, but return all intermediate results as a list

   .. function:: scanl1 f xs

      accumulate the binary function ``f`` over all members of ``xs``, as with
      :func:`foldl1`, but return all intermediate results as a list

   .. function:: scanr f a xs

      accumulate the binary function ``f`` over all members of ``xs``, as with
      :func:`foldr`, but return all intermediate results as a list

   .. function:: scanr1 f xs

      accumulate the binary function ``f`` over all members of ``xs``, as with
      :func:`foldr1`, but return all intermediate results as a list

   .. function:: sort p xs

      Sorts the elements of the list ``xs`` in ascending order according to
      the given predicate ``p``, using the C ``qsort`` function. The predicate
      ``p`` is invoked with two arguments and should return a truth value
      indicating whether the first argument is "less than" the second. (An
      exception is raised if the result of a comparison is not a machine
      integer.) ::

        > sort (>) (1..10);
	[10,9,8,7,6,5,4,3,2,1]
	> sort (<) ans;
	[1,2,3,4,5,6,7,8,9,10]

   .. function:: tail xs

      return all but the first element of ``xs``; ``xs`` must be nonempty

   .. function:: take n xs

      take ``n`` elements from the front of ``xs``

   .. function:: takewhile p xs

      take elements from the front of ``xs`` while the predicate ``p`` is
      satisfied

*/

/* Some of the definitions aren't exactly pretty, but they are like that
   because we want them to be both efficient and robust. In particular, we
   require that they do all the necessary argument checking, are
   tail-recursive and handle lazy lists as gracefully as possible. */

all p []		= 1;
all p (x:xs)		= p x && all p xs;

any p []		= 0;
any p (x:xs)		= p x || any p xs;

// we don't provide skip-ahead version
delete [] y = [];
delete xs@(_:_) y = tick xs [] with
    tick [] _ = xs; // no match
    tick (x:xs) ws      = if y==?x then tack ws xs else tick xs (x:ws);
    tick xs ws          = tack ws (delete xs y);
    tack (x:xs) ys      = tack xs (x:ys);
    tack [] ys          = ys;
end;

do f []			= ();
do f (x:xs)		= f x $$ do f xs;

drop n::int []		= [];
drop n::int ys@(x:xs)	= drop (n-1) xs if n>1;
			= xs if n==1;
			= ys otherwise;

dropwhile p []		= [];
dropwhile p ys@(x:xs)	= dropwhile p xs if p x;
			= ys otherwise;

filter p []		= [];
#! --ifnot list-opt
// reverse-based
filter p xs@(_:_)	= tick [] xs
with
  add p x xs		= if p x then x:xs else xs;
  tick zs (x:xs)	= tack (add p x zs) (filter p xs&) if thunkp xs;
			= tick (add p x zs) xs;
  tick zs []		= tack zs [];
  tick _ xs		= throw (bad_list_value xs);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

#! --else
// skip-ahead
filter p xs@(_:_) = aux xs with
    add p x hs = if p x then x:hs else hs;
    aux xs = filter_pre len_pre xs with
        filter_pre 0 _ = filtered_tail;
        filter_pre n::int (x:xs) = add p x (filter_pre (n-1) xs);
    end when
        len_pre@_ filtered_tail = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n [];
    skip_ahead n::int xs@(_:_) = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n (add p x (aux xs&)) if thunkp xs;
                               = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (filter p xs);
end;
#! --endif

foldl f a []		= a;
foldl f a (x:xs)	= foldl f (f a x) xs;

foldl1 f (x:xs)		= foldl f x xs;

foldr f a []		= a;
foldr1 f [x]		= x;
#! --ifnot list-opt
// reverse-based
foldr f a xs@(_:_)	= tick [] xs
with
  tick zs (x:xs)	= tack (x:zs) (foldr f a xs&) if thunkp xs;
			= tick (x:zs) xs;
  tick zs []		= tack zs a;
  tick zs xs		= tack zs (foldr f a xs);
  tack (x:xs) y		= tack xs (f x y);
  tack [] y		= y;
end;

foldr1 f xs@(_:_)	= tick [] xs
with
  /* Do the thunkp check first, before probing the tail. Note that the first
     foldr1 rule above ensures that the topmost tail is already evaluated, so
     that we always make some progress here. */
  tick zs ys@(_:xs)	= tack zs (foldr1 f ys&) if thunkp xs;
  tick zs xs		= case xs of
			    [x]  = tack zs x;
			    x:xs = tick (x:zs) xs;
			    _    = tack zs (foldr1 f xs);
			  end;
  tack (x:xs) y		= tack xs (f x y);
  tack [] y		= y;
end;

#! --else
// skip-ahead
foldr f a xs@(_:_) = aux xs with
    aux xs = fold_pre len_pre xs with
        fold_pre 0 _           = folded_tail;
        fold_pre n::int (x:xs) = f x (fold_pre (n-1) xs);
    end when
        len_pre@_ folded_tail  = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n a;
    skip_ahead n::int xs@(_:_) = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n (f x (aux xs&)) if thunkp xs;
                               = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (foldr f a xs);
end;

foldr1 f xs@(_:_) = aux xs with
    aux xs = fold_pre len_pre xs with
        fold_pre 0 _           = folded_tail;
        fold_pre n::int (x:xs) = f x (fold_pre (n-1) xs);
    end when
        len_pre@_ folded_tail  = skip_ahead 0 xs;
    end;
    skip_ahead n::int ys@(_:xs) = n (aux ys) if n == __std__::SKIPSIZE;
                                = n (foldr1 f ys&) if thunkp xs;
    skip_ahead n::int xs        = case xs of
                                    [x]  = n x;
                                    x:xs = skip_ahead (n+1) xs;
                                    _    = n (foldr1 f xs);
                                  end;
end;
#! --endif

head (x:xs)		= x;

init [_]		= [];
#! --ifnot list-opt
// reverse-based
init xs@(_:_)		= tick [] xs
with
  tick zs ys@(_:xs)	= tack zs (init ys&) if thunkp xs;
  tick zs xs		= case xs of
			    [x]  = tack zs [];
			    x:xs = tick (x:zs) xs;
			    _    = tack zs (init xs);
			  end;
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

#! --else
// skip-ahead
init xs@(_:_) = aux xs with
    aux xs = init_pre len_pre xs with
        init_pre 0 _           = chopped_tail;
        init_pre n::int (x:xs) = x:init_pre (n-1) xs;
    end when
        len_pre@_ chopped_tail = skip_ahead 0 xs;
    end;
    skip_ahead n::int ys@(x:xs) = n (aux ys) if n == __std__::SKIPSIZE;
                                = n (init ys&) if thunkp xs;
    skip_ahead n::int xs        = case xs of
                                    [_]  = n [];
                                    _:xs = skip_ahead (n+1) xs;
                                    _    = n (init xs);
                                  end;
end;
#! --endif

last [x]		= x;
last (x:xs)		= last xs;

map f []		= [];
#! --ifnot list-opt
// reverse-based
map f xs@(_:_)		= tick [] xs
with
  tick zs (x:xs)	= tack (f x:zs) (map f xs&) if thunkp xs;
			= tick (f x:zs) xs;
  tick zs []		= tack zs [];
  tick zs xs		= tack zs (map f xs);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;
#! --else
// skip-ahead
map f xs@(_:_) = aux xs with
    aux xs = map_pre len_pre xs with
        map_pre 0 _            = mapped_tail;
        map_pre n::int (x:xs)  = f x:map_pre (n-1) xs;
    end when
        len_pre@_ mapped_tail  = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n [];
    skip_ahead n::int xs@(_:_) = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n (f x:aux xs&) if thunkp xs;
                               = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (map f xs);
end;
#! --endif

// no skip-ahead implementations yet, I'm lazy
scanl f a []		= [a];
scanl f a xs@(_:_)	= tick a [] xs
with
  tick a zs (x:xs)	= tack (a:zs) (scanl f (f a x) xs&) if thunkp xs;
			= tick (f a x) (a:zs) xs;
  tick a zs []		= tack zs [a];
  tick a zs xs		= tack zs (scanl f a xs);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

scanl1 f []		= [];
scanl1 f (x:xs)		= scanl f x xs;

scanr f a []		= [a];
scanr f a xs@(_:_)	= tick [] xs
with
  /* Hack around with thunks to make these matches irrefutable. */
  tick zs (x:xs)	= tack zs us when
			    ys = scanr f a xs&;
			    y  = (case ys of
				    y:_ = y;
				    scanr _ _ ys = throw (bad_list_value ys);
				    _ = throw (bad_list_value ys);
				  end)&;
			    us = f x y : ys;
			  end if thunkp xs;
  tick zs (x:xs)	= tack zs (f x (y when y:_ = ys end)&:ys
				   when ys = scanr f a xs& end) if thunkp xs;
			= tick (x:zs) xs;
  tick zs []		= tack zs [a];
  tick zs xs		= throw (bad_list_value xs);
  tack (x:xs) ys	= tack xs (f x y:ys) when y:_ = ys end;
  tack [] ys		= ys;
end;

scanr1 f []		= [];
scanr1 f [x]		= [x];
scanr1 f xs@(_:_)	= tick [] xs
with
  tick zs (x:xs)	= tack zs us when
			    ys = scanr1 f xs&;
			    y  = (case ys of
				    y:_ = y;
				    scanr1 _ ys = throw (bad_list_value ys);
				    _ = throw (bad_list_value ys);
				  end)&;
			    us = f x y : ys;
			  end if thunkp xs;
  tick zs xs		= case xs of
			    [x]  = tack zs [x];
			    x:xs = tick (x:zs) xs;
			    _    = throw (bad_list_value xs);
			  end;
  tack (x:xs) ys	= tack xs (f x y:ys) when y:_ = ys end;
  tack [] ys		= ys;
end;

tail (x:xs)		= xs;

take m::int []		= [];
takewhile p []	= [];
#! --ifnot list-opt
// reverse-based
take m::int xs@(_:_)	= tick m [] xs
with
  tick m::int zs xs	= tack zs [] if m<=0;
			= tack zs (take m xs&) if thunkp xs;
			= case xs of
			    []   = tack zs [];
			    x:xs = tick (m-1) (x:zs) xs;
			    _    = tack zs (take m xs);
			  end;
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

takewhile p xs@(_:_)	= tick [] xs
with
  tick zs xs		= tack zs (takewhile p xs&) if thunkp xs;
			= case xs of
			    []   = tack zs [];
			    x:xs = tick (x:zs) xs if p x;
			         = tack zs [];
			    _    = tack zs (takewhile p xs);
			  end;
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

#! --else
// skip-ahead
take m::int xs@(_:_) = aux m xs with
    aux 0 xs = [];
    aux m::int xs = take_pre len_pre xs with
        take_pre 0      _             = front_tail;
        take_pre n::int (x:xs)        = x:take_pre (n-1) xs;
    end when
        len_pre@_ front_tail          = skip_ahead m 0 xs;
    end;
    skip_ahead m::int n::int []       = n [];
    skip_ahead m::int n::int xs@(_:_) = n (aux m xs) if n == __std__::SKIPSIZE;
    skip_ahead m::int n::int (x:xs)   = n [] if m <= 0;
                                      = n (x:aux (m-1) xs&) if thunkp xs;
                                      = skip_ahead (m-1) (n+1) xs;
    skip_ahead m::int n::int xs       = n (take m xs);
end;

takewhile p xs@(_:_) = aux xs with
    aux xs = take_pre len_pre xs with
        take_pre 0      _      = front_tail;
        take_pre n::int (x:xs) = x:take_pre (n-1) xs;
    end when
        len_pre@_ front_tail   = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n [];
    skip_ahead n::int xs@(_:_) = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n [] if ~p x;
                               = n (x:aux xs&) if thunkp xs;
                               = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (takewhile p xs);
end;
#! --endif

/* Concatenate a list of lists. */

cat []			= [];
#! --ifnot list-opt
// reverse-based
cat xs@(_:_)		= foldr (tick []) [] xs
with
  /* Unfortunately, the global list concatenation operator (+) isn't fully
     lazy in Pure, because it's also used for arithmetic operations. Using it
     here would make foldr (and hence cat) eager. Therefore we use our own
     concatenation operation here, which properly deals with the case that ys
     is an infinite stream when applied recursively. */
  tick zs (x:xs) ys	= tack (x:zs) (tick [] xs ys&) if thunkp xs;
			= tick (x:zs) xs ys;
  tick zs [] ys		= tack zs ys;
  tick zs xs ys		= tack zs (xs+ys);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
  /* We also use a slightly modified foldr function here, so that we can
     handle the case that xs is an improper list more gracefully. */
  foldr f a []		= a;
  foldr f a xs@(_:_)	= tick [] xs
  with
    tick zs (x:xs)	= tack (x:zs) (foldr f a xs&) if thunkp xs;
			= tick (x:zs) xs;
    tick zs []		= tack zs a;
    tick zs xs		= tack zs (foldr f a xs);
    tack (x:xs) y	= tack xs (f x y);
    tack [] y		= y;
  end;
  foldr (tick _) [] x	= cat x;
end;

#! --else
// skip-ahead
cat (xs::list:yss) = aux xs with
    aux xs = cat_pre len_pre xs with
        cat_pre 0 _           = catted_tail;
        cat_pre n::int (x:xs) = x:cat_pre (n-1) xs;
    end when
        len_pre@_ catted_tail  = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n (cat yss);
    skip_ahead n::int xs@(_:_) = n (aux xs) if n== __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n (x:aux xs&) if thunkp xs;
    skip_ahead n::int (x:xs)   = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (xs+cat yss);
end;
#! --endif

/* Map a function to a list and concatenate the results. This is used by list
   comprehensions. */

catmap f []		= [];
#! --ifnot list-opt
// reverse-based
catmap f xs@(_:_)	= cat (map f xs);

/* NOTE: This definition (from the Haskell prelude) is better, but doesn't
   preserve left-to-right execution order. */
//catmap f xs@(_:_)	= foldr ((+).f) [] xs;

#! --else
// skip-ahead
catmap f xs@(_:_) = aux xs with
    aux xs = map_pre len_pre xs with
        map_pre 0 _              = mapped_tail;
        map_pre n::int (x:xs)    = lazy_cat (f x) (map_pre (n-1) xs);
    end when
        len_pre@_ mapped_tail    = skip_map 0 xs;
    end;
    skip_map n::int []           = n [];
    skip_map n::int xs@(_:_)     = n (aux xs) if n == __std__::SKIPSIZE;
    skip_map n::int (x:xs)       = n (lazy_cat (f x) (aux xs&)) if thunkp xs;
                                 = skip_map (n+1) xs;
    skip_map n::int xs           = n (catmap f xs);
    lazy_cat xs yss              = cat_pre len_pre xs with
        cat_pre 0 _              = catted_tail;
        cat_pre n::int (x:xs)    = x:cat_pre (n-1) xs;
    end when
        len_pre@_ catted_tail    = skip_cat yss 0 xs;
    end;
    skip_cat yss n::int []       = n yss;
    skip_cat yss n::int xs@(_:_) = n (aux xs) if n== __std__::SKIPSIZE;
    skip_cat yss n::int (x:xs)   = n (x:lazy_cat xs yss&) if thunkp xs;
    skip_cat yss n::int (x:xs)   = skip_cat yss (n+1) xs;
    skip_cat yss n::int xs       = n (xs+yss);
end;
#! --endif

/* Map a function to a list, like map, but first promote the argument to a
   list if possible. This is used by list comprehensions. */

listmap f []		= [];
listmap f xs@(_:_)	= map f xs;

/* Search an element in a list. Returns -1 if not found, index of first
   occurrence otherwise. */

index [] _		= -1;
index (x:xs) y		= search 0 (x:xs) with
  search _ []		= -1;
  search n::int (x:xs)	= n if x==?y;
			= search (n+1) xs;
  search _ xs		= index xs y;
end;

member [] y             = 0;
// member xs@(_:_) y    = index xs y+1;
// member xs@(_:_) y    = any (y==?) xs;
member (x:xs) y         = 1 if y==? x;
                        = member xs y;

/* Arithmetic sequences. */

public iterate iterwhile; // see below for these

n1:n2..m	= if nanp n1 || nanp m || double m===-s then []
		  else if double m===s then iterate (+k) n1
		  else iterwhile (p (m+0.5*k)) (+k) n1
		  when s,p = if k>0 then inf,(>=) else -inf,(<=) end
		  if realp k && k~=0 && ~infp n1 && ~infp n2
		  when k = n2-n1 end;
n..m		= if nanp n || nanp m || double m===-inf then []
		  else if double m===inf then iterate (+1) n
		  else iterwhile ((>=) m) (+1) n
		  if ~listp n && ~infp n;


/* ..

   List Generators
   ~~~~~~~~~~~~~~~

   Some useful (infinite) list generators, as well as some finite (and eager)
   variations of these. The latter work like a combination of :func:`take` or
   :func:`takewhile` and the former, but are implemented directly for better
   efficiency.

   .. function:: cycle xs

      cycles through the elements of the nonempty list ``xs``, ad infinitum

   .. function:: cyclen n xs

      eager version of :func:`cycle`, returns the first ``n`` elements of
      ``cycle xs``

   .. function:: iterate f x

      returns the stream containing ``x``, ``f x``, ``f (f x)``, etc.,
      ad infinitum

   .. function:: iteraten n f x

      eager version of :func:`iterate`, returns the first ``n`` elements of
      ``iterate f x``

   .. function:: iterwhile p f x

      another eager version of :func:`iterate`, returns the list of all
      elements from the front of ``iterate f x`` for which the predicate ``p``
      holds

   .. function:: repeat x

      returns an infinite stream of ``x``\ s

   .. function:: repeatn n x

      eager version of :func:`repeat`, returns a list with ``n`` ``x``\ s

*/

/* Some useful (infinite) list generators. */

iterate f x		= x : iterate f (f x)&;
repeat x		= x : repeat x&;
cycle ys@(x:xs)		= x : (xs+cycle ys)&;

/* Some finite (and strict) generators. These work like the a combination of
   takewhile/take and the above, but are implemented directly for maximum
   efficiency. */

// no skip-ahead implentations yet, I'm lazy
iterwhile p f x		= accum [] p f x with
			    accum xs p f x = accum (x:xs) p f (f x) if p x;
				           = reverse xs otherwise;
			  end;

iteraten n::int f x	= [] if n<=0;
			= accum [] n f x
with
  accum xs n::int f x	= reverse (x:xs) if n==1;
			= accum (x:xs) (n-1) f (f x);
end;

repeatn n::int x	= accum [] n x with
  accum xs n::int x	= xs if n<=0;
			= accum (x:xs) (n-1) x;
end;

cyclen n::int (x:xs)	= [] if n<=0;
			= accum [] n with
			    accum ys n::int = cat ys+take n xs if n<=m;
			                    = accum (xs:ys) (n-m) otherwise;
			  end when xs = x:xs; m::int = #xs end if rlistp xs;

/* ..

   Zip and Friends
   ~~~~~~~~~~~~~~~

   .. function:: unzip xys

      takes a list of pairs to a pair of lists of corresponding elements

   .. function:: unzip3 xyzs

      :func:`unzip` with triples

   .. function:: zip xs ys

      return the list of corresponding pairs ``(x,y)`` where ``x`` runs
      through the elements of ``xs`` and ``y`` runs through the elements of
      ``ys``

   .. function:: zip3 xs ys zs

      :func:`zip` with three lists, returns a list of triples

   .. function:: zipwith f xs ys

      apply the binary function ``f`` to corresponding elements of ``xs``
      and ``ys``

   .. function:: zipwith3 f xs ys zs

      apply the ternary function ``f`` to corresponding elements of ``xs``,
      ``ys`` and ``zs``

   Pure also has the following variations of :func:`zipwith` and
   :func:`zipwith3` which throw away all intermediate results and return the
   empty tuple ``()``. That is, these work like :func:`do` but pull arguments
   from two or three lists, respectively:

   .. function:: dowith f xs ys

      apply the binary function ``f`` to corresponding elements of ``xs``
      and ``ys``, return ``()``

   .. function:: dowith3 f xs ys zs

      apply the ternary function ``f`` to corresponding elements of ``xs``,
      ``ys`` and ``zs``, return ``()``

*/

zip [] _		|
zip _ []		|
zipwith f [] _		|
zipwith f _ []		= [];

zip3 [] _ _		|
zip3 _ [] _		|
zip3 _ _ []		|
zipwith3 f [] _ _	|
zipwith3 f _ [] _	|
zipwith3 f _ _ []	= [];


namespace __std__ with
#! --ifnot list-opt
// reverse-based
zip f improper xs@(_:_) ys@(_:_)
			= tick [] xs ys
with
  tick us (x:xs) (y:ys)	= tack (f x y:us) (zip f improper xs ys&)
			    if thunkp xs || thunkp ys;
			= tick (f x y:us) xs ys;
  tick us [] _		|
  tick us _ []		= tack us [];
  tick us xs ys		= tack us (improper xs ys);
  tack (u:us) vs	= tack us (u:vs);
  tack [] vs		= vs;
end;

zip3 f improper xs@(_:_) ys@(_:_) zs@(_:_)
			= tick [] xs ys zs
with
  tick us (x:xs) (y:ys) (z:zs)
			= tack (f x y z:us) (zip3 f improper xs ys zs&)
			    if thunkp xs || thunkp ys || thunkp zs;
			= tick (f x y z:us) xs ys zs;
  tick us [] _ _	|
  tick us _ [] _	|
  tick us _ _ []	= tack us [];
  tick us xs ys zs	= tack us (improper xs ys zs);
  tack (u:us) vs	= tack us (u:vs);
  tack [] vs		= vs;
end;

#! --else
// skip-ahead
zip f improper xs@(_:_) ys@(_:_) = aux xs ys with
    aux xs ys = zip_pre len_pre xs ys with
        zip_pre 0 _ _ = zipped_tail;
        zip_pre n::int (x:xs) (y:ys) = f x y:zip_pre (n-1) xs ys;
    end when
        len_pre@_ zipped_tail = skip_ahead 0 xs ys;
    end;
    skip_ahead n::int [] _  |
    skip_ahead n::int _ []  = n [];
    skip_ahead n::int xs@(_:_) ys@(_:_)
                            = n (aux xs ys) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs) (y:ys)
                            = n (f x y:aux xs ys&)
                              if thunkp xs || thunkp ys;
                            = skip_ahead (n+1) xs ys;
    skip_ahead n::int xs ys = n (improper xs ys);
end;

zip3 f improper xs@(_:_) ys@(_:_) zs@(_:_) = aux xs ys zs with
    aux xs ys zs = zip_pre len_pre xs ys zs with
        zip_pre 0 _ _ _ = zipped_tail;
        zip_pre n::int (x:xs) (y:ys) (z:zs) = f x y z:zip_pre (n-1) xs ys zs;
    end when
        len_pre@_ zipped_tail = skip_ahead 0 xs ys zs;
    end;
    skip_ahead n::int [] _ _   |
    skip_ahead n::int _ [] _   |
    skip_ahead n::int _ _ []   = n [];
    skip_ahead n::int xs@(_:_) ys@(_:_) zs@(_:_)
                               = n (aux xs ys zs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs) (y:ys) (z:zs)
                               = n (f x y z:aux xs ys zs&)
                                 if thunkp xs || thunkp ys || thunkp zs;
                               = skip_ahead (n+1) xs ys zs;
    skip_ahead n::int xs ys zs = n (improper xs ys zs);
end;
#! --endif
end;

zip xs@(_:_) ys@(_:_) = __std__::zip (,) (zip) xs ys;
zipwith f xs@(_:_) ys@(_:_) = __std__::zip f (zipwith f) xs ys;

zip3 xs@(_:_) ys@(_:_) zs@(_:_) = __std__::zip3 comma (zip3) xs ys zs with comma x y z = x,y,z end;
zipwith3 f xs@(_:_) ys@(_:_) zs@(_:_) = __std__::zip3 f (zipwith3 f) xs ys zs;

unzip []		= [],[];
unzip us@(_:_)		= foldr accum ([],[]) us
with
  accum u@(x,y) us	= x:(xs when xs,_ = check us end)&,
			  y:(ys when _,ys = check us end)& if thunkp us;
			= x:xs,y:ys when xs,ys = check us end;
  accum u _		= throw (bad_tuple_value u);
  check us@(_,_)	= us;
  check (foldr _ _ us)	= throw (bad_list_value us);
  check us		= throw (bad_tuple_value us);
end;

unzip3 []		= [],[],[];
unzip3 us@(_:_)		= foldr accum ([],[],[]) us
with
  accum u@(x,y,z) us	= x:(xs when xs,_,_ = check us end)&,
			  y:(ys when _,ys,_ = check us end)&,
			  z:(zs when _,_,zs = check us end)& if thunkp us;
			= x:xs,y:ys,z:zs when xs,ys,zs = check us end;
  accum u _		= throw (bad_tuple_value u);
  check us@(_,_,_)	= us;
  check (foldr _ _ us)	= throw (bad_list_value us);
  check us		= throw (bad_tuple_value us);
end;

dowith f (x:xs) (y:ys)	= f x y $$ dowith f xs ys;
dowith f _ _		= () otherwise;

dowith3 f (x:xs) (y:ys) (z:zs)
                        = f x y z $$ dowith3 f xs ys zs;
dowith3 f _ _ _		= () otherwise;
