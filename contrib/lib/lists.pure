
/* Basic list functions. */

/* Copyright (c) 2008-2012 by Albert Graef <Dr.Graef@t-online.de>.
   Copyright (c) 2012 by Dubiousjim <dubiousjim@gmail.com>.

   This file is part of the Pure standard library.

   The Pure standard library is free software: you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
   more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */


/* We default to using the existing, reverse-based algorithms. If one
   runs the interpreter using ``--enable=list-opt``, we instead use
   algorithms based on the skip-ahead technique described at
   <http://ocaml.janestreet.com/?q=node/71>. This protects against
   stack overflows without needing to reverse, gaining some speed
   and using substantially less memory.

   Note that with ``--enable=list-opt``, you no longer are guaranteed
   left-to-right evaluation order for `map` and `catmap`. If you need
   that, you can just explicitly use `foldl` and `reverse`, or
   disable the optimizations.
*/

#! --if list-opt
namespace __std__ with const SKIPSIZE = 4096; end;
#! --endif


/* List reversal. These are inherently eager operations, so they will loop on
   an infinite final argument. Also, these are some of the few list operations
   which throw an exception when that argument is an improper list, since in
   that case there really isn't any meaningful value to return.

   The stdlib needs a version that doesn't typecheck its base, so that the
   toplevel API can present a (base::string)-friendly version that doesn't
   mess up stdlib's handling of thunks. Functions should only
   use this when they know that the second argument is a proper list. */

namespace __std__;
reverse_onto base [] = base;
reverse_onto base (x:xs) = reverse_onto (x:base) xs;
namespace;

reverse_onto base []     = base;
reverse_onto base (x:xs) = accum (x:base) xs with
  accum ys (x:xs)	 = accum (x:ys) xs;
  accum ys []		 = ys;
  accum	ys xs		 = throw (bad_list_value xs);
end;

reverse []	         = [];
reverse xs@(_:_)	 = reverse_onto [] xs;


/* List concatenation. For a robust implementation which works with both
   ordinary lists and streams, we want this to be tail-recursive *and*
   non-strict. */
[]+ys		= ys;
#! --ifnot list-opt
/* This implementation first walks down the list, popping elements from the first
   operand until we find an empty or thunked tail ('tick'), then walk back up
   again, pushing elements in front of the result list ('reverse_onto'). */
xs@(_:_)+ys	= tick [] xs ys
with
  tick zs (x:xs) ys	= __std__::reverse_onto (tick [] xs ys&) (x:zs) if thunkp xs;
			= tick (x:zs) xs ys;
  tick zs [] ys		= __std__::reverse_onto ys zs;
  /* Handle an improper list tail (xs+ys is in normal form here). */
  tick zs xs ys		= __std__::reverse_onto (xs+ys) zs;
end;

#! --else
// skip-ahead
xs@(_:_)+ys = aux xs with
    aux xs = fold_pre len_pre xs with
        fold_pre 0 _           = folded_tail;
        fold_pre n::int (x:xs) = x:fold_pre (n-1) xs;
    end when
        len_pre@_ folded_tail  = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n ys;
    skip_ahead n::int xs@(_:_) = n (aux xs) if n== __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n (x:aux xs&) if thunkp xs;
                               = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (xs+ys);
end;
#! --endif


/* ..

   List Functions
   --------------

   This mostly comes straight from the Q prelude which in turn was based on
   the first edition of the Bird/Wadler book, and is very similar to what you
   can find in the Haskell prelude. Some functions have slightly different
   names, though, and of course everything is typed dynamically.

   Common List Functions
   ~~~~~~~~~~~~~~~~~~~~~

   .. function:: any p xs

      test whether the predicate ``p`` holds for any of the members of ``xs``

   .. function:: all p xs

      test whether the predicate ``p`` holds for all of the members of ``xs``

   .. function:: cat xs

      concatenate a list of lists

   .. function:: catmap f xs

      convenience function which combines '\ :func:`cat`\ ' and
      '\ :func:`map`\ '; this is also used to implement list comprehensions

   .. function:: catmap_onto f base xs

      '\ :func:`catmap`\ ' onto the specified base

   .. function:: delete xs y

      return ``xs`` without the first member satisfying ``(y==?)``;
      if no member matches ``y``, will just return ``xs``

   .. function:: do f xs

      apply ``f`` to all members of ``xs``, like '\ :func:`map`\ ', but throw
      away all intermediate results and return ``()``

   .. function:: drop n xs

      remove ``n`` elements from the front of ``xs``

   .. function:: dropwhile p xs

      remove elements from the front of ``xs`` while the predicate ``p`` is
      satisfied

   .. function:: filter p xs

      return the list of all members of ``xs`` satisfying the predicate ``p``

   .. function:: firstby p none xs

      return the first member of ``xs`` satisfying the predicate ``p``; else
      return the supplied ``none`` value

      See also '\ :func:`pickfirstby`\ ' and '\ :func:`lastby`\ ';
      '\ :func:`filter`\ ' can be thought of as an "allby".

   .. function:: foldl f a xs

      accumulate the binary function ``f`` over all members of ``xs``,
      starting from the initial value ``a`` and working from the front of the
      list towards its end

   .. function:: foldl1 f xs

      accumulate the binary function ``f`` over all members of ``xs``,
      starting from the value ``head xs`` and working from the front of the
      list towards its end; ``xs`` must be nonempty

   .. function:: foldl2 f a xs ys

      accumulate the binary function ``f`` over all members of ``xs`` and
      ``ys`` in parallel, starting from the initial value ``a`` and working
      from the front of the lists towards their end; stops when the shorter of
      ``xs`` and ``ys`` does

   .. function:: foldl3 f a xs ys zs

      like '\ :func:`foldl2`\ ' but processes three lists in parallel

   .. function:: foldr f a xs

      accumulate the binary function ``f`` over all members of ``xs``,
      starting from the initial value ``a`` and working from the end of the
      list towards its front

   .. function:: foldr1 f xs

      accumulate the binary function ``f`` over all members of ``xs``,
      starting from the value ``last xs`` and working from the end of the list
      towards its front; ``xs`` must be nonempty

   .. function:: foldr2 f a xs ys

      accumulate the binary function ``f`` over all members of ``xs`` and
      ``ys`` in parallel, starting from the initial value ``a`` and working
      from the end of the shorter of `xs` and `ys` towards their front

   .. function:: foldr3 f a xs ys zs

      like '\ :func:`foldr2`\ ' but processes three lists in parallel

   .. function:: head xs

      return the first element of ``xs``; ``xs`` must be nonempty

   .. function:: index xs x

      search for an occurrence of ``x`` in ``xs`` and return the index of the
      first occurrence, if any, ``-1`` otherwise

      This uses '\ :func:`==?`\ ' to decide whether a member of ``xs``
      is an occurrence of ``x``.

   .. function:: init xs

      return all but the last element of ``xs``; ``xs`` must be nonempty

   .. function:: last xs

      return the last element of ``xs``; ``xs`` must be nonempty

   .. function:: lastby p none xs

      return the last member of ``xs`` satisfying the predicate ``p``; else
      return the supplied ``none`` value

   .. function:: listmap f xs

      convenience function which works like :func:`map`, but also deals with
      matrix and string arguments while ensuring that the result is always a
      list; this is primarily used to implement list comprehensions

   .. function:: map f xs

      apply ``f`` to each member of ``xs``

   .. function:: map_onto f base xs

      :func:`map` onto the specified base

   .. function:: member xs x

      return whether ``x`` is a member of ``xs``

      Note: This uses :func:`==?` to decide whether a member of ``xs``
      is an occurrence of ``x``.

   .. function:: partition p xs

      equivalent to ``filter p xs, filter ((~).p) xs``, but more efficient

   .. function:: pickfirstby p xs

      equivalent to ``firstby p _ xs, rmfirstby p xs``, but more efficient;
      if no member of ``xs`` satisfies predicate ``p``, returns ``()``

      Note: ``partition`` can be thought of as a `popall`.

   .. function:: picklastby p xs

      equivalent to ``lastby p _ xs, rmlastby p xs``, but more efficient;
      if no member of ``xs`` satisfies predicate ``p``, returns ``()``

   .. function:: revmap f xs

      equivalent to ``reverse (map f xs)``, but more efficient than even plain :func:`map`

   .. function:: revmap_onto f base xs

      equivalent to ``reverse (map f xs) + base``, but more efficient

   .. function:: rmfirstby p xs

      return ``xs`` without the first member satisfying the predicate ``p``;
      if no member satisfies ``p`` will just return ``xs``

      Note: ``filter ((~).p)` can be thought of as a `deleteall`.

   .. function:: rmlastby p xs

      return ``xs`` without the last member satisfying the predicate ``p``;
      if no member satisfies ``p`` will just return ``xs``

   .. function:: scanl f a xs

      accumulate the binary function ``f`` over all members of ``xs``, as with
      :func:`foldl`, but return all intermediate results as a list

   .. function:: scanl1 f xs

      accumulate the binary function ``f`` over all members of ``xs``, as with
      :func:`foldl1`, but return all intermediate results as a list

   .. function:: scanr f a xs

      accumulate the binary function ``f`` over all members of ``xs``, as with
      :func:`foldr`, but return all intermediate results as a list

   .. function:: scanr1 f xs

      accumulate the binary function ``f`` over all members of ``xs``, as with
      :func:`foldr1`, but return all intermediate results as a list

   .. function:: sort p xs

      Sorts the elements of the list ``xs`` in ascending order according to
      the given predicate ``p``, using the C ``qsort`` function. The predicate
      ``p`` is invoked with two arguments and should return a truth value
      indicating whether the first argument is "less than" the second. (An
      exception is raised if the result of a comparison is not a machine
      integer.) ::

        > sort (>) (1..10);
	[10,9,8,7,6,5,4,3,2,1]
	> sort (<) ans;
	[1,2,3,4,5,6,7,8,9,10]

   .. function:: span p xs

      equivalent to ``takewhile p xs, dropwhile p xs``, but more efficient

   .. function:: split n xs

      equivalent to ``take n xs, drop n xs``, but more efficient

   .. function:: tail xs

      return all but the first element of ``xs``; ``xs`` must be nonempty

   .. function:: take n xs

      take ``n`` elements from the front of ``xs``

   .. function:: takewhile p xs

      take elements from the front of ``xs`` while the predicate ``p`` is
      satisfied

*/

/* Some of the definitions aren't exactly pretty, but they are like that
   because we want them to be both efficient and robust. In particular, we
   require that they do all the necessary argument checking, are
   tail-recursive and handle lazy lists as gracefully as possible. */

all p []		= 1;
all p xs@(_:_)          = tick xs 1 with
    tick _ 0            = 0;
    tick [] a           = a;
    tick (x:xs) a       = tick xs (a && p x);
    tick xs a           = a && all p xs;
end;

any p []		= 0;
any p (x:xs)		= p x || any p xs;

// we don't provide skip-ahead version
delete [] y = [];
delete xs@(_:_) y = tick xs [] with
    tick [] _ = xs; // no match
    tick (x:xs) ws      = if y==?x then __std__::reverse_onto xs ws else tick xs (x:ws);
    tick xs ws          = __std__::reverse_onto (delete xs y) ws;
end;

do f []			= ();
do f (x:xs)		= f x $$ do f xs;

drop n::int []		= [];
drop n::int ys@(x:xs)	= drop (n-1) xs if n>1;
			= xs if n==1;
			= ys otherwise;

dropwhile p []		= [];
dropwhile p ys@(x:xs)	= dropwhile p xs if p x;
			= ys otherwise;

filter p []		= [];
#! --ifnot list-opt
// reverse-based
filter p xs@(_:_)	= tick [] xs
with
  add p x xs		= if p x then x:xs else xs;
  tick zs (x:xs)	= __std__::reverse_onto (tick [] xs&) (add p x zs) if thunkp xs;
			= tick (add p x zs) xs;
  tick zs []		= __std__::reverse_onto [] zs;
  tick zs xs		= __std__::reverse_onto (filter p xs) zs;
end;

#! --else
// skip-ahead
filter p xs@(_:_) = aux xs with
    add p x hs = if p x then x:hs else hs;
    aux xs = filter_pre len_pre xs with
        filter_pre 0 _ = filtered_tail;
        filter_pre n::int (x:xs) = add p x (filter_pre (n-1) xs);
    end when
        len_pre@_ filtered_tail = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n [];
    skip_ahead n::int xs@(_:_) = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n (add p x (aux xs&)) if thunkp xs;
                               = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (filter p xs);
end;
#! --endif

firstby p none [] = none; // no match
firstby p none (x:xs) = if p x then x else firstby p none xs;

// we don't provide skip-ahead version
pickfirstby p [] = ();
pickfirstby p xs@(_:_) = tick xs [] with
    tick [] _ = (); // no match
    tick (x:xs) ws = if p x then tuple2 x (__std__::reverse_onto xs ws)
                     else tick xs (x:ws);
    tick xs ws     = throw (bad_list_value xs);
    // doesn't handle case where no match is found:
    // tick xs ws     = tuple2 (firstby p _ xs) (reverse_onto (rmfirstby p xs) ws);
end;

// we don't provide skip-ahead version
rmfirstby p [] = [];
rmfirstby p ys@(_:_) = tick ys [] with
    tick [] _ = ys; // no match
    tick (x:xs) ws = if p x then __std__::reverse_onto xs ws else tick xs (x:ws);
    tick xs ws = __std__::reverse_onto (rmfirstby p xs) ws;
end;

/* We have to juggle a bit to keep `notfound` private but let these methods access
   it. All of `lastby`, `rmlastby`, and `picklastby` are inherently eager. */

public lastby picklastby rmlastby;
namespace __std__;
private nonfix notfound;

::lastby p none [] = none;
::lastby p none xs@(_:_) = tick xs notfound with
    tick [] w = if w===notfound then none else w;
    tick (x:xs) w = tick xs (if p x then x else w);
    tick xs w = throw (bad_list_value xs);
end;

#! --ifnot list-opt
// reverse-based
::picklastby p [] = ();
::picklastby p xs@(_:_) = tick xs [] [] [] with
    tick []     _  []     _   = (); // no match
    tick []     ms (h:hs) hss = tuple2 h (tack (__std__::reverse_onto [] ms) hs hss);
    tick (x:xs) ms hs     hss = if p x
                                then tick xs [] (x:ms) (hs:hss)
                                else tick xs (x:ms) hs hss;
    tick xs     _  _      _   = throw (bad_list_value xs);
    tack zs []     []         = zs;
    tack zs []     (xs:xss)   = tack zs xs xss;
    tack zs (y:ys) xss        = tack (y:zs) ys xss;
end;

::rmlastby p [] = [];
::rmlastby p ys@(_:_) = tick ys [] [] [] with
    tick []     _  []     _   = ys; // no match
    tick []     ms (_:hs) hss = tack (__std__::reverse_onto [] ms) hs hss;
    tick (x:xs) ms hs     hss = if p x
                                then tick xs [] (x:ms) (hs:hss)
                                else tick xs (x:ms) hs hss;
    tick xs     _  _      _   = throw (bad_list_value xs);
    tack zs []     []         = zs;
    tack zs []     (xs:xss)   = tack zs xs xss;
    tack zs (y:ys) xss        = tack (y:zs) ys xss;
end;

#! --else
// skip-ahead
::picklastby p [] = ();
::picklastby p xs@(_:_) = aux xs with
    aux xs = case skip_ahead 0 xs of
        len_pre@_ () = pop_pre len_pre xs with
            pop_pre 0 _ = ();
            pop_pre n::int xx@(x:xs) = case pop_pre (n-1) xs of
                                          () = if p x then xx else ();
                                          y,ys = tuple2 y (x:ys);
                                       end;
        end;
        len_pre@_ (y:ys) = tuple2 y (append len_pre xs ys);
    end;
    append n::int [] ys | append 0 _ ys = ys;
    append n::int (x:xs) ys = x:append (n-1) xs ys;
    skip_ahead n::int [] = n ();
    skip_ahead n::int xs = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (_:xs) = skip_ahead (n+1) xs;
    skip_ahead n::int xs = throw (bad_list_value xs);
end;

::rmlastby p [] = [];
::rmlastby p ys@(_:_) = case aux ys of
    notfound = ys; // no match
    ys = ys;
end with
    aux xs = case skip_ahead 0 xs of
        len_pre@_ notfound = pop_pre len_pre xs with
            pop_pre 0 _ = notfound;
            pop_pre n::int (x:xs) = case pop_pre (n-1) xs of
                                       notfound = if p x then xs else notfound;
                                       ys = x:ys;
                                    end;
        end;
        len_pre@_ ys = append len_pre xs ys;
    end;
    append n::int [] ys | append 0 _ ys = ys;
    append n::int (x:xs) ys = x:append (n-1) xs ys;
    skip_ahead n::int [] = n notfound;
    skip_ahead n::int xs = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (_:xs) = skip_ahead (n+1) xs;
    skip_ahead n::int xs = throw (bad_list_value xs);
end;
#! --endif
namespace;

foldl f a []		= a;
foldl f a (x:xs)	= foldl f (f a x) xs;

foldl1 f (x:xs)		= foldl f x xs;

foldl2 f a _ [] | foldl2 f a [] _ = a;
foldl2 f a (x:xs) (y:ys) = foldl2 f (f a x y) xs ys;

foldl3 f a _ _ [] | foldl3 f a _ [] _ | foldl3 f a [] _ _ = a;
foldl3 f a (x:xs) (y:ys) (z:zs) = foldl3 f (f a x y z) xs ys zs;

foldr f a []		= a;
foldr1 f [x]		= x;
foldr2 f a _ [] | foldr2 f a [] _ = a;
foldr3 f a _ _ [] | foldr3 f a _ [] _ | foldr3 f a [] _ _ = a;
#! --ifnot list-opt
// reverse-based
foldr f a xs@(_:_)	= tick [] xs
with
  tick zs (x:xs)	= tack (x:zs) (tick [] xs&) if thunkp xs;
			= tick (x:zs) xs;
  tick zs []		= tack zs a;
  tick zs xs		= tack zs (foldr f a xs);
  tack (x:xs) y		= tack xs (f x y);
  tack [] y		= y;
end;

foldr1 f xs@(_:_)	= tick [] xs
with
  /* Do the thunkp check first, before probing the tail. Note that the first
     foldr1 rule above ensures that the topmost tail is already evaluated, so
     that we always make some progress here. */
  tick zs ys@(_:xs)	= tack zs (foldr1 f ys&) if thunkp xs;
  tick zs xs		= case xs of
			    [x]  = tack zs x;
			    x:xs = tick (x:zs) xs;
			    _    = tack zs (foldr1 f xs);
			  end;
  tack (x:xs) y		= tack xs (f x y);
  tack [] y		= y;
end;

foldr2 f a xs@(_:_) ys@(_:_)      = tick [] xs ys
with
  tick us (x:xs) (y:ys)           = tack (x:y:us) (tick [] xs ys&)
                                    if thunkp xs || thunkp ys;
                                  = tick (x:y:us) xs ys;
  tick us _ [] | tick us [] _     = tack us a;
  tick us xs ys                   = tack us (foldr2 f a xs ys);
  tack (x:y:us) a                 = tack us (f x y a);
  tack [] a                       = a;
end;

foldr3 f a xs@(_:_) ys@(_:_) zs@(_:_) = tick [] xs ys zs
with
  tick us (x:xs) (y:ys) (z:zs)    = tack (x:y:z:us) (tick [] xs ys zs&)
                                    if thunkp xs || thunkp ys || thunkp zs;
                                  = tick (x:y:z:us) xs ys zs;
  tick us _ _ [] | tick us _ [] _ | tick us [] _ _
                                  = tack us a;
  tick us xs ys zs                = tack us (foldr3 f a xs ys zs);
  tack (x:y:z:us) a               = tack us (f x y z a);
  tack [] a                       = a;
end;

#! --else
// skip-ahead
foldr f a xs@(_:_) = aux xs with
    aux xs = fold_pre len_pre xs with
        fold_pre 0 _           = folded_tail;
        fold_pre n::int (x:xs) = f x (fold_pre (n-1) xs);
    end when
        len_pre@_ folded_tail  = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n a;
    skip_ahead n::int xs@(_:_) = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n (f x (aux xs&)) if thunkp xs;
                               = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (foldr f a xs);
end;

foldr1 f xs@(_:_) = aux xs with
    aux xs = fold_pre len_pre xs with
        fold_pre 0 _           = folded_tail;
        fold_pre n::int (x:xs) = f x (fold_pre (n-1) xs);
    end when
        len_pre@_ folded_tail  = skip_ahead 0 xs;
    end;
    skip_ahead n::int ys@(_:xs) = n (aux ys) if n == __std__::SKIPSIZE;
                                = n (foldr1 f ys&) if thunkp xs;
    skip_ahead n::int xs        = case xs of
                                    [x]  = n x;
                                    x:xs = skip_ahead (n+1) xs;
                                    _    = n (foldr1 f xs);
                                  end;
end;

foldr2 f a xs@(_:_) ys@(_:_) = aux xs ys with
    aux xs ys = fold_pre len_pre xs ys with
        fold_pre 0 _ _        = folded_tail;
        fold_pre n::int (x:xs) (y:ys) = f x y (fold_pre (n-1) xs ys);
    end when
        len_pre@_ folded_tail = skip_ahead 0 xs ys;
    end;
    skip_ahead n::int [] _    |
    skip_ahead n::int _ []    = n a;
    skip_ahead n::int xs@(_:_) ys@(_:_)
                              = n (aux xs ys) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs) (y:ys)
                              = n (f x y (aux xs ys&))
                                if thunkp xs || thunkp ys;
                              = skip_ahead (n+1) xs ys;
    skip_ahead n::int xs ys   = n (foldr2 f a xs ys);
end;

foldr3 f a xs@(_:_) ys@(_:_) zs@(_:_) = aux xs ys zs with
    aux xs ys zs = fold_pre len_pre xs ys zs with
        fold_pre 0 _ _ _       = folded_tail;
        fold_pre n::int (x:xs) (y:ys) (z:zs) = f x y z (fold_pre (n-1) xs ys zs);
    end when
        len_pre@_ folded_tail  = skip_ahead 0 xs ys zs;
    end;
    skip_ahead n::int [] _ _   |
    skip_ahead n::int _ [] _   |
    skip_ahead n::int _ _ []   = n a;
    skip_ahead n::int xs@(_:_) ys@(_:_) zs@(_:_)
                               = n (aux xs ys zs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs) (y:ys) (z:zs)
                               = n (f x y z (aux xs ys zs&))
                                 if thunkp xs || thunkp ys || thunkp zs;
                               = skip_ahead (n+1) xs ys zs;
    skip_ahead n::int xs ys zs = n (foldr3 f a xs ys zs);
end;
#! --endif

head (x:xs)		= x;

init [_]		= [];
#! --ifnot list-opt
// reverse-based
init xs@(_:_)		= tick [] xs
with
  tick zs ys@(_:xs)	= __std__::reverse_onto (init ys&) zs if thunkp xs;
  tick zs xs		= case xs of
			    [_]  = __std__::reverse_onto [] zs;
			    x:xs = tick (x:zs) xs;
			    _    = __std__::reverse_onto (init xs) zs;
			  end;
end;

#! --else
// skip-ahead
init xs@(_:_) = aux xs with
    aux xs = init_pre len_pre xs with
        init_pre 0 _           = chopped_tail;
        init_pre n::int (x:xs) = x:init_pre (n-1) xs;
    end when
        len_pre@_ chopped_tail = skip_ahead 0 xs;
    end;
    skip_ahead n::int ys@(x:xs) = n (aux ys) if n == __std__::SKIPSIZE;
                                = n (init ys&) if thunkp xs;
    skip_ahead n::int xs        = case xs of
                                    [_]  = n [];
                                    _:xs = skip_ahead (n+1) xs;
                                    _    = n (init xs);
                                  end;
end;
#! --endif

last [x]		= x;
last (x:xs)		= last xs;

map_onto f base []	= base;
map f []		= [];
#! --ifnot list-opt
// reverse-based
map_onto f base xs@(_:_) = tick [] xs
with
  tick zs (x:xs)	= __std__::reverse_onto (tick [] xs&) (f x:zs) if thunkp xs;
			= tick (f x:zs) xs;
  tick zs []		= __std__::reverse_onto base zs;
  tick zs xs		= __std__::reverse_onto (map_onto f base xs) zs;
end;

map f xs@(_:_)		= tick [] xs
with
  tick zs (x:xs)	= __std__::reverse_onto (tick [] xs&) (f x:zs) if thunkp xs;
			= tick (f x:zs) xs;
  tick zs []		= __std__::reverse_onto [] zs;
  tick zs xs		= __std__::reverse_onto (map f xs) zs;
end;

#! --else
// skip-ahead
map_onto f base xs@(_:_) = aux xs with
    aux xs = map_pre len_pre xs with
        map_pre 0 _            = mapped_tail;
        map_pre n::int (x:xs)  = f x:map_pre (n-1) xs;
    end when
        len_pre@_ mapped_tail  = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n base;
    skip_ahead n::int xs@(_:_) = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n (f x:aux xs&) if thunkp xs;
                               = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (map_onto f base xs);
end;

map f xs@(_:_) = aux xs with
    aux xs = map_pre len_pre xs with
        map_pre 0 _            = mapped_tail;
        map_pre n::int (x:xs)  = f x:map_pre (n-1) xs;
    end when
        len_pre@_ mapped_tail  = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n [];
    skip_ahead n::int xs@(_:_) = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n (f x:aux xs&) if thunkp xs;
                               = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (map f xs);
end;
#! --endif

partition p [] = [], [];
#! --ifnot list-opt
// reverse-based
partition p xs@(_:_) = aux xs [] [] with
    aux []     [] _  = xs, []; // no misses, use original
    aux []     _  [] = [], xs; // no hits, use original
    aux []     ms hs = __std__::reverse_onto [] hs, __std__::reverse_onto [] ms;
    aux (x:xs) ms hs
        = if p x
          then __std__::reverse_onto (filter p xs&) (x:hs), __std__::reverse_onto (filter ((~).p) xs&) ms
          else __std__::reverse_onto (filter p xs&) hs, __std__::reverse_onto (filter ((~).p) xs&) (x:ms) if thunkp xs;
        = if p x
          then aux xs ms (x:hs)
          else aux xs (x:ms) hs;
    aux xs ms hs     = __std__::reverse_onto (filter p xs) hs, __std__::reverse_onto (filter ((~).p) xs) ms;
end;

#! --else
// skip-ahead
partition p xs@(_:_) = aux xs with
    add p x (yes, no) = if p x then x:yes, no else yes, x:no;
    aux xs = split_pre len_pre xs with
        split_pre 0 _           = split_tails;
        split_pre n::int (x:xs) = add p x (split_pre (n-1) xs);
    end when
        len_pre@_ split_tails   = skip_ahead 0 xs;
    end;
    skip_ahead n::int []        = n ([],[]);
    skip_ahead n::int xs@(_:_)  = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)
                         = n (add p x (filter p xs&, filter ((~).p) xs&))
                           if thunkp xs;
                         = skip_ahead (n+1) xs;
    skip_ahead n::int xs = n (filter p xs, filter ((~).p) xs);
end;
#! --endif

revmap_onto f base [] = base;
revmap_onto f base xs@(_:_) = tick base xs with
    tick a [] = a;
    tick a (x:xs) = tick (f x:a) xs;
    tick _ xs = throw (bad_list_value xs);
end;

revmap f [] = [];
revmap f xs@(_:_) = revmap_onto f [] xs;

// no skip-ahead implementations yet, I'm lazy
scanl f a []		= [a];
scanl f a xs@(_:_)	= tick a [] xs
with
  tick a zs (x:xs)	= __std__::reverse_onto (tick (f a x) xs&) (a:zs) if thunkp xs;
			= tick (f a x) (a:zs) xs;
  tick a zs []		= __std__::reverse_onto [a] zs;
  tick a zs xs		= __std__::reverse_onto (scanl f a xs) zs;
end;

scanl1 f []		= [];
scanl1 f (x:xs)		= scanl f x xs;

scanr f a []		= [a];
scanr f a xs@(_:_)	= tick [] xs
with
  /* Hack around with thunks to make these matches irrefutable. */
  tick zs (x:xs)	= tack zs us when
			    ys = scanr f a xs&;
			    y  = (case ys of
				    y:_ = y;
				    scanr _ _ ys = throw (bad_list_value ys);
				    _ = throw (bad_list_value ys);
				  end)&;
			    us = f x y : ys;
			  end if thunkp xs;
  tick zs (x:xs)	= tack zs (f x (y when y:_ = ys end)&:ys
				   when ys = scanr f a xs& end) if thunkp xs;
			= tick (x:zs) xs;
  tick zs []		= tack zs [a];
  tick zs xs		= throw (bad_list_value xs);
  tack (x:xs) ys	= tack xs (f x y:ys) when y:_ = ys end;
  tack [] ys		= ys;
end;

scanr1 f []		= [];
scanr1 f [x]		= [x];
scanr1 f xs@(_:_)	= tick [] xs
with
  tick zs (x:xs)	= tack zs us when
			    ys = scanr1 f xs&;
			    y  = (case ys of
				    y:_ = y;
				    scanr1 _ ys = throw (bad_list_value ys);
				    _ = throw (bad_list_value ys);
				  end)&;
			    us = f x y : ys;
			  end if thunkp xs;
  tick zs xs		= case xs of
			    [x]  = tack zs [x];
			    x:xs = tick (x:zs) xs;
			    _    = throw (bad_list_value xs);
			  end;
  tack (x:xs) ys	= tack xs (f x y:ys) when y:_ = ys end;
  tack [] ys		= ys;
end;

span p []	= [], [];
#! --ifnot list-opt
// reverse-based
span p xs@(_:_)	= tick [] xs
with
  tick zs xs		= __std__::reverse_onto (takewhile p xs&) zs, dropwhile p xs& if thunkp xs; // we don't deconstruct xs so as to check p x only one on one codepath
			= case xs of
			    []   = __std__::reverse_onto [] zs, [];
			    x:xs = tick (x:zs) xs if p x;
			    xs@(_:_)  = __std__::reverse_onto [] zs, xs;
			    xs   = __std__::reverse_onto (takewhile p xs) zs, dropwhile p xs;
			  end;
end;

#! --else
// skip-ahead
span p xs@(_:_) = aux xs with
    aux xs = split_pre len_pre xs with
        add x (pre, post)        = x:pre, post;
        split_pre 0      _      = split_tails;
        split_pre n::int (x:xs) = add x (split_pre (n-1) xs);
    end when
        len_pre@_ split_tails   = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n ([],[]);
    skip_ahead n::int xs@(_:_) = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int xx@(x:xs)
            = n ([],xx) if ~p x;
            = n (x:takewhile p xs&, dropwhile p xs&) if thunkp xs;
            = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (takewhile p xs, dropwhile p xs);
end;
#! --endif

// split m xs = subseq xs 0 (m-1), subseq xs m (#xs-1);
split m::int [] = [], [];
#! --ifnot list-opt
// reverse-based
split m::int xs@(_:_) = aux m [] xs with
    aux _::int ws []     = xs, []; // use original
    aux 0 ws xs          = __std__::reverse_onto [] ws, xs;
    aux m::int ws (x:xs) = __std__::reverse_onto (x:take (m-1) xs&) ws, drop (m-1) xs&
                           if thunkp xs;
                         = aux (m-1) (x:ws) xs;
    aux m::int ws xs     = __std__::reverse_onto (take m xs) ws, drop m xs;
end;

#! --else
// skip-ahead
split m::int xs@(_:_) = aux m xs with
    add x (front, back) = x:front, back;
    aux m::int xs = split_pre len_pre xs with
        split_pre 0      _            = split_tails;
        split_pre n::int (x:xs)       = add x (split_pre (n-1) xs);
    end when
        len_pre@_ split_tails         = skip_ahead m 0 xs;
    end;
    skip_ahead m::int n::int []       = n ([],[]);
    skip_ahead m::int n::int xs@(_:_) = n (aux m xs) if n == __std__::SKIPSIZE;
    skip_ahead m::int n::int xs       = n ([],xs) if m <= 0;
    skip_ahead m::int n::int (x:xs)
                           = n (x:take (m-1) xs&, drop (m-1) xs&)
                             if thunkp xs;
                           = skip_ahead (m-1) (n+1) xs;
    skip_ahead m::int n::int xs       = n (take m xs, drop m xs);
end;
#! --endif

tail (x:xs)		= xs;

take m::int []		= [];
takewhile p []	= [];
#! --ifnot list-opt
// reverse-based
take m::int xs@(_:_)	= tick m [] xs
with
  tick m::int zs xs     = __std__::reverse_onto (take m xs&) zs if thunkp xs; // we don't deconstruct xs so as to check p x only one on one codepath
                        = __std__::reverse_onto [] zs if m<=0;
			= case xs of
			    []   = __std__::reverse_onto [] zs;
			    x:xs = tick (m-1) (x:zs) xs;
			    _    = __std__::reverse_onto (take m xs) zs;
			  end;
end;

takewhile p xs@(_:_)	= tick [] xs
with
  tick zs xs		= __std__::reverse_onto (takewhile p xs&) zs if thunkp xs; // we don't deconstruct xs so as to check p x only one on one codepath
			= case xs of
			    []   = __std__::reverse_onto [] zs;
			    x:xs = tick (x:zs) xs if p x;
			         = __std__::reverse_onto [] zs;
			    _    = __std__::reverse_onto (takewhile p xs) zs;
			  end;
end;

#! --else
// skip-ahead
take m::int xs@(_:_) = aux m xs with
    aux 0 xs = [];
    aux m::int xs = take_pre len_pre xs with
        take_pre 0      _             = front_tail;
        take_pre n::int (x:xs)        = x:take_pre (n-1) xs;
    end when
        len_pre@_ front_tail          = skip_ahead m 0 xs;
    end;
    skip_ahead m::int n::int []       = n [];
    skip_ahead m::int n::int xs@(_:_) = n (aux m xs) if n == __std__::SKIPSIZE;
    skip_ahead m::int n::int (x:xs)   = n [] if m <= 0;
                                      = n (x:aux (m-1) xs&) if thunkp xs;
                                      = skip_ahead (m-1) (n+1) xs;
    skip_ahead m::int n::int xs       = n (take m xs);
end;

takewhile p xs@(_:_) = aux xs with
    aux xs = take_pre len_pre xs with
        take_pre 0      _      = front_tail;
        take_pre n::int (x:xs) = x:take_pre (n-1) xs;
    end when
        len_pre@_ front_tail   = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n [];
    skip_ahead n::int xs@(_:_) = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n [] if ~p x;
                               = n (x:aux xs&) if thunkp xs;
                               = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (takewhile p xs);
end;
#! --endif

/* Concatenate a list of lists. */

cat []			= [];
#! --ifnot list-opt
// reverse-based
cat xs@(_:_)		= foldr (tick []) [] xs
with
  /* Unfortunately, the global list concatenation operator (+) isn't fully
     lazy in Pure, because it's also used for arithmetic operations. Using it
     here would make foldr (and hence cat) eager. Therefore we use our own
     concatenation operation here, which properly deals with the case that ys
     is an infinite stream when applied recursively. */
  tick zs (x:xs) ys	= __std__::reverse_onto (tick [] xs ys&) (x:zs) if thunkp xs;
			= tick (x:zs) xs ys;
  tick zs [] ys		= __std__::reverse_onto ys zs;
  tick zs xs ys		= __std__::reverse_onto (xs+ys) zs;
  /* We also use a slightly modified foldr function here, so that we can
     handle the case that xs is an improper list more gracefully. */
  foldr f a []		= a;
  foldr f a xs@(_:_)	= tick [] xs
  with
    tick zs (x:xs)	= tack (x:zs) (tick [] xs&) if thunkp xs;
			= tick (x:zs) xs;
    tick zs []		= tack zs a;
    tick zs xs		= tack zs (foldr f a xs);
    tack (x:xs) y	= tack xs (f x y);
    tack [] y		= y;
  end;
  foldr (tick _) [] x	= cat x;
end;

#! --else
// skip-ahead
cat (xs::list:yss) = aux xs with
    aux xs = cat_pre len_pre xs with
        cat_pre 0 _           = catted_tail;
        cat_pre n::int (x:xs) = x:cat_pre (n-1) xs;
    end when
        len_pre@_ catted_tail  = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n (cat yss);
    skip_ahead n::int xs@(_:_) = n (aux xs) if n== __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n (x:aux xs&) if thunkp xs;
    skip_ahead n::int (x:xs)   = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (xs+cat yss);
end;
#! --endif

/* Map a function to a list and concatenate the results. This is used by list
   comprehensions. */

catmap_onto f base []	= base;
catmap f []		= [];
#! --ifnot list-opt
// reverse-based
catmap_onto f base xs@(_:_)	= cat (map_onto f base xs);

catmap f xs@(_:_)	= cat (map f xs);

/* NOTE: This definition (from the Haskell prelude) is better, but doesn't
   preserve left-to-right execution order. */
//catmap f xs@(_:_)	= foldr ((+).f) [] xs;

#! --else
// skip-ahead
catmap_onto f base xs@(_:_) = aux xs with
    aux xs = map_pre len_pre xs with
        map_pre 0 _              = mapped_tail;
        map_pre n::int (x:xs)    = lazy_cat (f x) (map_pre (n-1) xs);
    end when
        len_pre@_ mapped_tail    = skip_map 0 xs;
    end;
    skip_map n::int []           = n base;
    skip_map n::int xs@(_:_)     = n (aux xs) if n == __std__::SKIPSIZE;
    skip_map n::int (x:xs)       = n (lazy_cat (f x) (aux xs&)) if thunkp xs;
                                 = skip_map (n+1) xs;
    skip_map n::int xs           = n (catmap_onto f base xs);
    lazy_cat xs yss              = cat_pre len_pre xs with
        cat_pre 0 _              = catted_tail;
        cat_pre n::int (x:xs)    = x:cat_pre (n-1) xs;
    end when
        len_pre@_ catted_tail    = skip_cat yss 0 xs;
    end;
    skip_cat yss n::int []       = n yss;
    skip_cat yss n::int xs@(_:_) = n (aux xs) if n== __std__::SKIPSIZE;
    skip_cat yss n::int (x:xs)   = n (x:lazy_cat xs yss&) if thunkp xs;
    skip_cat yss n::int (x:xs)   = skip_cat yss (n+1) xs;
    skip_cat yss n::int xs       = n (xs+yss);
end;

catmap f xs@(_:_) = aux xs with
    aux xs = map_pre len_pre xs with
        map_pre 0 _              = mapped_tail;
        map_pre n::int (x:xs)    = lazy_cat (f x) (map_pre (n-1) xs);
    end when
        len_pre@_ mapped_tail    = skip_map 0 xs;
    end;
    skip_map n::int []           = n [];
    skip_map n::int xs@(_:_)     = n (aux xs) if n == __std__::SKIPSIZE;
    skip_map n::int (x:xs)       = n (lazy_cat (f x) (aux xs&)) if thunkp xs;
                                 = skip_map (n+1) xs;
    skip_map n::int xs           = n (catmap f xs);
    lazy_cat xs yss              = cat_pre len_pre xs with
        cat_pre 0 _              = catted_tail;
        cat_pre n::int (x:xs)    = x:cat_pre (n-1) xs;
    end when
        len_pre@_ catted_tail    = skip_cat yss 0 xs;
    end;
    skip_cat yss n::int []       = n yss;
    skip_cat yss n::int xs@(_:_) = n (aux xs) if n== __std__::SKIPSIZE;
    skip_cat yss n::int (x:xs)   = n (x:lazy_cat xs yss&) if thunkp xs;
    skip_cat yss n::int (x:xs)   = skip_cat yss (n+1) xs;
    skip_cat yss n::int xs       = n (xs+yss);
end;
#! --endif

/* Map a function to a list, like map, but first promote the argument to a
   list if possible. This is used by list comprehensions. */

listmap f []		= [];
listmap f xs@(_:_)	= map f xs;

/* Search an element in a list. Returns -1 if not found, index of first
   occurrence otherwise. */

index [] _		= -1;
index (x:xs) y		= search 0 (x:xs) with
  search _ []		= -1;
  search n::int (x:xs)	= n if x==?y;
			= search (n+1) xs;
  search _ xs		= index xs y;
end;

member [] y             = 0;
// member xs@(_:_) y    = index xs y+1;
// member xs@(_:_) y    = any (y==?) xs;
member (x:xs) y         = 1 if y==? x;
                        = member xs y;

/* Arithmetic sequences. */

public iterate iterwhile; // see below for these

n1:n2..m	= if nanp n1 || nanp m || double m===-s then []
		  else if double m===s then iterate (+k) n1
		  else iterwhile (p (m+0.5*k)) (+k) n1
		  when s,p = if k>0 then inf,(>=) else -inf,(<=) end
		  if realp k && k~=0 && ~infp n1 && ~infp n2
		  when k = n2-n1 end;
n..m		= if nanp n || nanp m || double m===-inf then []
		  else if double m===inf then iterate (+1) n
		  else iterwhile ((>=) m) (+1) n
		  if ~listp n && ~infp n;


/* ..

   List Generators
   ~~~~~~~~~~~~~~~

   Some useful (infinite) list generators, as well as some finite (and eager)
   variations of these. The latter work like a combination of :func:`take` or
   :func:`takewhile` and the former, but are implemented directly for better
   efficiency.

   .. function:: cycle xs

      cycles through the elements of the nonempty list ``xs``, ad infinitum

   .. function:: cyclen n xs

      eager version of :func:`cycle`, returns the first ``n`` elements of
      ``cycle xs``

   .. function:: iterate f x

      returns the stream containing ``x``, ``f x``, ``f (f x)``, etc.,
      ad infinitum

   .. function:: iteraten n f x

      eager version of :func:`iterate`, returns the first ``n`` elements of
      ``iterate f x``

   .. function:: iterwhile p f x

      another eager version of :func:`iterate`, returns the list of all
      elements from the front of ``iterate f x`` for which the predicate ``p``
      holds

   .. function:: repeat x

      returns an infinite stream of ``x``\ s

   .. function:: repeatn n x

      eager version of :func:`repeat`, returns a list with ``n`` ``x``\ s

*/

/* Some useful (infinite) list generators. */

iterate f x		= x : iterate f (f x)&;
repeat x		= x : repeat x&;
cycle ys@(x:xs)		= x : (xs+cycle ys)&;

/* Some finite (and strict) generators. These work like the a combination of
   takewhile/take and the above, but are implemented directly for maximum
   efficiency. */

// no skip-ahead implentations yet, I'm lazy
iterwhile p f x		= accum [] p f x with
			    accum xs p f x = accum (x:xs) p f (f x) if p x;
				           = __std__::reverse_onto [] xs otherwise;
			  end;

iteraten n::int f x	= [] if n<=0;
			= accum [] n f x
with
  accum xs n::int f x	= __std__::reverse_onto [] (x:xs) if n==1;
			= accum (x:xs) (n-1) f (f x);
end;

repeatn n::int x	= accum [] n x with
  accum xs n::int x	= xs if n<=0;
			= accum (x:xs) (n-1) x;
end;

cyclen n::int (x:xs)	= [] if n<=0;
			= accum [] n with
			    accum ys n::int = cat ys+take n xs if n<=m;
			                    = accum (xs:ys) (n-m) otherwise;
			  end when xs = x:xs; m::int = #xs end if rlistp xs;

/* ..

   Zip and Friends
   ~~~~~~~~~~~~~~~

   .. function:: unzip xys

      takes a list of pairs to a pair of lists of corresponding elements

   .. function:: unzip3 xyzs

      :func:`unzip` with triples

   .. function:: zip xs ys

      return the list of corresponding pairs ``(x,y)`` where ``x`` runs
      through the elements of ``xs`` and ``y`` runs through the elements of
      ``ys``

   .. function:: zip3 xs ys zs

      :func:`zip` with three lists, returns a list of triples

   .. function:: zip_onto f base xs ys

      :func:`zip` onto the specified base

   .. function:: zip3_onto f base xs ys zs

      :func:`zip3` onto the specified base

   .. function:: zipwith f xs ys

      apply the binary function ``f`` to corresponding elements of ``xs``
      and ``ys``

   .. function:: zipwith3 f xs ys zs

      apply the ternary function ``f`` to corresponding elements of ``xs``,
      ``ys`` and ``zs``

   .. function:: zipwith_onto f base xs ys

      :func:`zipwith` onto the specified base

   .. function:: zipwith3_onto f base xs ys zs

      :func:`zipwith3` onto the specified base

   Pure also has the following variations of :func:`zipwith` and
   :func:`zipwith3` which throw away all intermediate results and return the
   empty tuple ``()``. That is, these work like :func:`do` but pull arguments
   from two or three lists, respectively:

   .. function:: dowith f xs ys

      apply the binary function ``f`` to corresponding elements of ``xs``
      and ``ys``, return ``()``

   .. function:: dowith3 f xs ys zs

      apply the ternary function ``f`` to corresponding elements of ``xs``,
      ``ys`` and ``zs``, return ``()``

*/

zip [] _		|
zip _ []		|
zipwith f [] _		|
zipwith f _ []		= [];

zip3 [] _ _		|
zip3 _ [] _		|
zip3 _ _ []		|
zipwith3 f [] _ _	|
zipwith3 f _ [] _	|
zipwith3 f _ _ []	= [];

zip_onto base [] _		|
zip_onto base _ []		|
zipwith_onto f base [] _	|
zipwith_onto f base _ []	= base;

zip3_onto base [] _ _		|
zip3_onto base _ [] _		|
zip3_onto base _ _ []		|
zipwith3_onto f base [] _ _	|
zipwith3_onto f base _ [] _	|
zipwith3_onto f base _ _ []	= base;


namespace __std__ with
#! --ifnot list-opt
// reverse-based
zip f base improper xs@(_:_) ys@(_:_)
			= tick [] xs ys
with
  tick us (x:xs) (y:ys)	= __std__::reverse_onto (tick [] xs ys&) (f x y:us)
			    if thunkp xs || thunkp ys;
			= tick (f x y:us) xs ys;
  tick us [] _		|
  tick us _ []		= __std__::reverse_onto base us;
  tick us xs ys		= __std__::reverse_onto (improper xs ys) us;
end;

zip3 f base improper xs@(_:_) ys@(_:_) zs@(_:_)
			= tick [] xs ys zs
with
  tick us (x:xs) (y:ys) (z:zs)
			= __std__::reverse_onto (tick [] xs ys zs&) (f x y z:us)
			    if thunkp xs || thunkp ys || thunkp zs;
			= tick (f x y z:us) xs ys zs;
  tick us [] _ _	|
  tick us _ [] _	|
  tick us _ _ []	= __std__::reverse_onto base us;
  tick us xs ys zs	= __std__::reverse_onto (improper xs ys zs) us;
end;

#! --else
// skip-ahead
zip f base improper xs@(_:_) ys@(_:_) = aux xs ys with
    aux xs ys = zip_pre len_pre xs ys with
        zip_pre 0 _ _ = zipped_tail;
        zip_pre n::int (x:xs) (y:ys) = f x y:zip_pre (n-1) xs ys;
    end when
        len_pre@_ zipped_tail = skip_ahead 0 xs ys;
    end;
    skip_ahead n::int [] _  |
    skip_ahead n::int _ []  = n base;
    skip_ahead n::int xs@(_:_) ys@(_:_)
                            = n (aux xs ys) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs) (y:ys)
                            = n (f x y:aux xs ys&)
                              if thunkp xs || thunkp ys;
                            = skip_ahead (n+1) xs ys;
    skip_ahead n::int xs ys = n (improper xs ys);
end;

zip3 f base improper xs@(_:_) ys@(_:_) zs@(_:_) = aux xs ys zs with
    aux xs ys zs = zip_pre len_pre xs ys zs with
        zip_pre 0 _ _ _ = zipped_tail;
        zip_pre n::int (x:xs) (y:ys) (z:zs) = f x y z:zip_pre (n-1) xs ys zs;
    end when
        len_pre@_ zipped_tail = skip_ahead 0 xs ys zs;
    end;
    skip_ahead n::int [] _ _   |
    skip_ahead n::int _ [] _   |
    skip_ahead n::int _ _ []   = n base;
    skip_ahead n::int xs@(_:_) ys@(_:_) zs@(_:_)
                               = n (aux xs ys zs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs) (y:ys) (z:zs)
                               = n (f x y z:aux xs ys zs&)
                                 if thunkp xs || thunkp ys || thunkp zs;
                               = skip_ahead (n+1) xs ys zs;
    skip_ahead n::int xs ys zs = n (improper xs ys zs);
end;
#! --endif
end;

zip xs@(_:_) ys@(_:_) = __std__::zip (,) [] (zip) xs ys;
zipwith f xs@(_:_) ys@(_:_) = __std__::zip f [] (zipwith f) xs ys;
zip_onto base xs@(_:_) ys@(_:_) = __std__::zip (,) base (zip_onto base) xs ys;
zipwith_onto f base xs@(_:_) ys@(_:_) = __std__::zip f base (zipwith_onto f base) xs ys;

zip3 xs@(_:_) ys@(_:_) zs@(_:_) = __std__::zip3 comma [] (zip3) xs ys zs with comma x y z = x,y,z end;
zipwith3 f xs@(_:_) ys@(_:_) zs@(_:_) = __std__::zip3 f [] (zipwith3 f) xs ys zs;
zip3_onto base xs@(_:_) ys@(_:_) zs@(_:_) = __std__::zip3 comma base (zip3_onto base) xs ys zs with comma x y z = x,y,z end;
zipwith3_onto f base xs@(_:_) ys@(_:_) zs@(_:_) = __std__::zip3 f base (zipwith3_onto f base) xs ys zs;


unzip []		= [],[];
unzip us@(_:_)		= foldr accum ([],[]) us
with
  accum u@(x,y) us	= x:(xs when xs,_ = check us end)&,
			  y:(ys when _,ys = check us end)& if thunkp us;
			= x:xs,y:ys when xs,ys = check us end;
  accum u _		= throw (bad_tuple_value u);
  check us@(_,_)	= us;
  check (foldr _ _ us)	= throw (bad_list_value us);
  check us		= throw (bad_tuple_value us);
end;

unzip3 []		= [],[],[];
unzip3 us@(_:_)		= foldr accum ([],[],[]) us
with
  accum u@(x,y,z) us	= x:(xs when xs,_,_ = check us end)&,
			  y:(ys when _,ys,_ = check us end)&,
			  z:(zs when _,_,zs = check us end)& if thunkp us;
			= x:xs,y:ys,z:zs when xs,ys,zs = check us end;
  accum u _		= throw (bad_tuple_value u);
  check us@(_,_,_)	= us;
  check (foldr _ _ us)	= throw (bad_list_value us);
  check us		= throw (bad_tuple_value us);
end;

dowith f (x:xs) (y:ys)	= f x y $$ dowith f xs ys;
dowith f _ _		= () otherwise;

dowith3 f (x:xs) (y:ys) (z:zs)
                        = f x y z $$ dowith3 f xs ys zs;
dowith3 f _ _ _		= () otherwise;
