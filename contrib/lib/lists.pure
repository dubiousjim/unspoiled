
/* Basic list functions. */

/* Copyright (c) 2008-2012 by Albert Graef <Dr.Graef@t-online.de>.

   This file is part of the Pure standard library.

   The Pure standard library is free software: you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
   more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* .. _List Functions:

   Lists
   -----

   .. index:: lists

   The prelude defines the list constructor, as well as equality
   and inequality on this structure. It also provides a number of other
   useful basic operations on lists. These are all described below.

   .. constructor:: []

      Empty list.

   .. constructor:: infix : x y

      List constructor. This is right-associative.

   Lists are the usual right-recursive aggregates of the form ``x:xs``, where
   ``x`` denotes the `head` and ``xs`` the `tail` of the list, pretty much the
   same as in Lisp or Prolog except that they use a Haskell-like syntax. In
   contrast to Haskell, list concatenation is denoted '\ :func:`+/list`\ '
   (see below), and lists may contain an arbitrary mixture of arguments, i.e.,
   they are fully polymorphic::

     > 1:2:3:[];
     [1,2,3]
     > [1,2,3]+[u,v,w]+[3.14];
     [1,2,3,u,v,w,3.14]

   Lists are `eager` in Pure by default, but they can also be made `lazy` (in
   the latter case they are also called `streams`). This is accomplished by
   turning the tail of a list into a "thunk" (a.k.a. "future") which defers
   evaluation until the list tail is actually needed, see section :ref:`Lazy
   Evaluation and Streams` in the Pure Manual. For instance, an infinite
   arithmetic sequence (see below) will always produce a list with a thunked
   tail::

     > 1:3..inf;
     1:#<thunk 0x7f696cd2dbd8>

   Pure also distinguishes `proper` and `improper` lists. The former are
   always terminated by an empty list in the final tail and can thus be
   written using the conventional ``[x1,x2,...,xn]`` syntax::

     > 1:2:3:[];
     [1,2,3]

   In contrast, improper lists are terminated with a non-list value and
   can only be represented using the '\ :func:`:`\ ' operator::

     > 1:2:3;
     1:2:3

   These aren't of much use as ordinary list values, but are frequently
   encountered as patterns on the left-hand side of an equation, where the
   final tail is usually a variable. Also note that technically, a lazy list
   is also an improper list (although it may expand to a proper list value as
   it is traversed).

   Some important basic operations on lists are listed below.

   .. index:: list; concatenation

   .. function:: infix + /list x y

      List concatenation. This non-destructively appends the elements of ``y``
      to ``x``. ::

        > [1,2,3]+[u,v,w];
        [1,2,3,u,v,w]

      Note that this operation in fact just recurses into ``x`` and replaces
      the empty list marking the "end" of ``x`` with ``y``, as if defined by
      the following equations (however, the prelude actually defines this
      operation in a tail-recursive fashion)::

        [] + ys = ys;
	(x:xs) + ys = x : xs+ys;

      To make this work, both operands should be proper lists, otherwise you
      may get somewhat surprising (but correct) improper list results like the
      following::

        > [1,2,3]+99;
	1:2:3:99
	> (1:2:3)+33;
	1:2:36

      This happens because Pure is dynamically typed and places no limits on
      ad hoc polymorphism. Note that the latter result is due to the fact
      that '\ :func:`+`\ ' also denotes the addition of numbers, and the
      improper tail of the first operand is a number in this case, as is the
      second operand. Otherwise you might have got an unreduced instance of
      the '\ :func:`+`\ ' operator instead.

   .. index:: list; equality

   .. function:: infix == /list x y
                 infix ~= /list x y

      Equality and inequality of lists. These compare two lists
      by recursively comparing their members, so '\ :func:`==`\ ' must
      be defined on the list members if you want to use these
      operations. ::

        > reverse [a,b,c] == [c,b,a];
	1
	> [a,b,c] == [];
	0

      '\ :funct: `==?`\ ' is another alternative, that checks whether
      the members of the lists are '\ :func:`==`\ ', or when that's not
      defined, whether they are '\ :func:`===`\ '.

      Note that all these operations are inherently eager, so
      applying them to two infinite lists may take an infinite amount of
      time.

   .. index:: list; size

   .. function:: prefix # x

      List size. This operation counts the number of elements in a
      list::

        > #[a,b,c];
	3

      Please note that for obvious reasons this operation is inherently eager,
      so trying to compute the size of an infinite list will take forever.

   .. index:: list; indexing

   .. function:: infix ! x i

      Indexing of lists is always zero-based (i.e., indices run
      from ``0`` to ``#x-1``), and an exception will be raised if the index is
      out of bounds::

        > [1,2,3]!2;
        3
        > [1,2,3]!4;
        <stdin>, line 34: unhandled exception 'out_of_bounds' while evaluating
        '[1,2,3]!4'

   .. index:: list; slicing

   .. function:: infix !! x is

      The slicing operation takes a list and a list of indices and
      returns the list of the corresponding elements.
      Indices which are out of the valid range are silently ignored::

        > (1..5)!!(3..10);
        [4,5]

      The case of contiguous index ranges, as shown above, is optimized so
      that it always works in linear time, see Slicing_ in the prelude for
      details. But indices can actually be specified in any order, so that you
      can retrieve any permutation of the members, also with duplicates. E.g.::

        > (1..5)!![2,4,4,1];
        [3,5,5,2]

      This is less efficient than the case of contiguous index ranges, because
      it requires repeated traversals of the list for each index. For larger
      lists you should hence use vectors or matrices instead, to avoid the
      quadratic complexity.

   .. index:: list; arithmetic sequence

   .. function:: infix .. x y

      Arithmetic sequences. Note that the Pure syntax differs from Haskell in
      that there are no brackets around the construct and a step width is
      indicated by specifying the first two elements as ``x:y`` instead of
      ``x,y``. ::

        > 1..5;
	[1,2,3,4,5]
	> 1:3..11;
	[1,3,5,7,9,11]

      To prevent unwanted artifacts due to rounding errors, the upper bound in
      a floating point sequence is always rounded to the nearest grid point::

        > 0.0:0.1..0.29;
        [0.0,0.1,0.2,0.3]
	> 0.0:0.1..0.31;
        [0.0,0.1,0.2,0.3]

      Last but not least, you can specify infinite sequences with an infinite
      upper bound (``inf`` or ``-inf``)::

        > 1:3..inf;
        1:#<thunk 0x7f696cd2dbd8>
        > -1:-3..-inf;
        -1:#<thunk 0x7f696cd2fde8>

      The lower bounds of an arithmetic sequence must always be finite.

   .. function:: null x

      Test for the empty list. ::

        > null [];
	1

   .. function:: reverse x

      Reverse a list. ::

        > reverse (1..5);
	[5,4,3,2,1]

   .. function:: reverse_onto base x

      Reverse a list onto a specified base. ::

        > reverse_onto [20,10] (3..5);
        [5, 4, 3, 20, 10]

   In addition, the prelude provides conversion operations between lists,
   tuples, and streams. */

/* We default to using the existing, reverse-based algorithms. If one
   runs the interpreter using --enable=list-opt, we instead use
   algorithms based on the skip-ahead technique described at
   <http://ocaml.janestreet.com/?q=node/71>. This protects against
   stack overflows without needing to reverse, gaining some speed
   and using substantially less memory.
*/
#! --ifndef list-opt
#! --disable list-opt
#! --endif
#! --if list-opt
namespace __std__;
const SKIPSIZE = 4096;
namespace;
#! --endif

/* Lists are the usual "conses" written using the infix ':' operator. '[]'
   denotes the empty list. Moreover, the parser provides the customary sugar
   for proper list values [x] where x is any singleton or tuple (in the latter
   case you'll get a list made from all the elements of x). The usual basic
   operations are provided to test for equality/inequality and emptiness, to
   compute the size of a list, for indexing, slicing and concatenation, and
   for reversing a list. */

[]==[]		= 1;
(x:xs)==[]	= 0;
[]==(x:xs)	= 0;
(x:xs)==(y:ys)	= x==y && xs==ys;

[]~=[]		= 0;
(x:xs)~=[]	= 1;
[]~=(x:xs)	= 1;
(x:xs)~=(y:ys)	= x~=y || xs~=ys;

null []		= 1;
null (x:xs)	= 0;

#[]		= 0;
#(x:xs)		= accum 1 xs with
  accum n::int (x:xs)	= accum (n+1) xs;
  accum n::int []	= n;
  accum	n::int xs	= n+#xs;
end;

[]!n::int	= throw out_of_bounds;
(x:xs)!0	= x;
(x:xs)!n::int	= xs!(n-1) if n>0;
		= throw out_of_bounds otherwise;



/* List reversal. This is a strict operation, of course, so it will loop on
   infinite lists. Also, these are some of the few list operations which throw
   an exception for improper lists xs, since in that case there really isn't any
   meaningful value to return. */

reverse_onto base []     = base;
reverse_onto base (x:xs) = accum (x:base) xs with
  accum ys (x:xs)	 = accum (x:ys) xs;
  accum ys []		 = ys;
  accum	ys xs		 = throw (bad_list_value xs);
end;

reverse []	         = [];
reverse xs@(_:_)	 = reverse_onto [] xs;


/* List concatenation. For a robust implementation which works with both
   ordinary lists and streams, we want this to be tail-recursive *and*
   non-strict. */
[]+ys		= ys;
#! --ifnot list-opt
/* This implementation first walks down the list, popping elements from the first
   operand until we find an empty or thunked tail ('tick'), then walk back up
   again, pushing elements in front of the result list ('reverse_onto'). */
xs@(_:_)+ys	= tick [] xs ys
with
  tick zs (x:xs) ys	= reverse_onto ((xs+ys)&) (x:zs) if thunkp xs;
			= tick (x:zs) xs ys;
  tick zs [] ys		= reverse_onto ys zs;
  /* Handle an improper list tail (xs+ys is in normal form here). */
  tick zs xs ys		= reverse_onto (xs+ys) zs;
end;

#! --else
// skip-ahead
xs@(_:_)+ys = aux xs with
    aux xs = fold_pre len_pre xs with
        fold_pre 0 _           = folded_tail;
        fold_pre n::int (x:xs) = x:fold_pre (n-1) xs;
    end when
        len_pre@_ folded_tail  = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n ys;
    skip_ahead n::int xs@(_:_) = n (aux xs) if n== __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n (x:aux xs&) if thunkp xs;
                               = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (xs+ys);
end;
#! --endif



/* ..

   List Functions
   --------------

   This mostly comes straight from the Q prelude which in turn was based on
   the first edition of the Bird/Wadler book, and is very similar to what you
   can find in the Haskell prelude. Some functions have slightly different
   names, though, and of course everything is typed dynamically.

   Common List Functions
   ~~~~~~~~~~~~~~~~~~~~~

   .. function:: any p xs

      test whether the predicate ``p`` holds for any of the members of ``xs``

   .. function:: all p xs

      test whether the predicate ``p`` holds for all of the members of ``xs``

   .. function:: cat xs

      concatenate a list of lists

   .. function:: catmap f xs

      convenience function which combines :func:`cat` and :func:`map`; this is
      also used to implement list comprehensions

   .. function:: deletel p xs

      return ``xs`` without the first member satisfying the predicate ``p``;
      if no member satisfies ``p`` will just return ``xs``

      Note: ``filter ((~).p)` can be thought of as a `deleteall`.

   .. function:: deleter p xs

      return ``xs`` without the last member satisfying the predicate ``p``;
      if no member satisfies ``p`` will just return ``xs``

   .. function:: do f xs

      apply ``f`` to all members of ``xs``, like :func:`map`, but throw away
      all intermediate results and return ``()``

   .. function:: drop n xs

      remove ``n`` elements from the front of ``xs``

   .. function:: dropwhile p xs

      remove elements from the front of ``xs`` while the predicate ``p`` is
      satisfied

   .. function:: filter p xs

      return the list of all members of ``xs`` satisfying the predicate ``p``

   .. function:: findl p xs

      return the first member of ``xs`` satisfying the predicate ``p``; an
      exception will be raised if no member does

      Note: :func:`filter` can be thought of as a `findall`.

   .. function:: findr p xs

      return the last member of ``xs`` satisfying the predicate ``p``; an
      exception will be raised if no member does

   .. function:: foldl f a xs

      accumulate the binary function ``f`` over all members of ``xs``,
      starting from the initial value ``a`` and working from the front of the
      list towards its end

   .. function:: foldl1 f xs

      accumulate the binary function ``f`` over all members of ``xs``,
      starting from the value ``head xs`` and working from the front of the
      list towards its end; ``xs`` must be nonempty

   .. function:: foldl2 f a xs ys

      accumulate the binary function ``f`` over all members of ``xs`` and
      ``ys`` in parallel, starting from the initial value ``a`` and working
      from the front of the lists towards their end; stops when the shorter of
      ``xs`` and ``ys`` does

   .. function:: foldl3 f a xs ys zs

      like foldl2 but processes three lists in parallel

   .. function:: foldr f a xs

      accumulate the binary function ``f`` over all members of ``xs``,
      starting from the initial value ``a`` and working from the end of the
      list towards its front

   .. function:: foldr1 f xs

      accumulate the binary function ``f`` over all members of ``xs``,
      starting from the value ``last xs`` and working from the end of the list
      towards its front; ``xs`` must be nonempty

   .. function:: foldr2 f a xs ys

      accumulate the binary function ``f`` over all members of ``xs`` and
      ``ys`` in parallel, starting from the initial value ``a`` and working
      from the end of the shorter of `xs` and `ys` towards their front

   .. function:: foldr3 f a xs ys zs

      like foldr2 but processes three lists in parallel

   .. function:: head xs

      return the first element of ``xs``; ``xs`` must be nonempty

   .. function:: index xs x

      search for an occurrence of ``x`` in ``xs`` and return the index of the
      first occurrence, if any, ``-1`` otherwise

      Note: This uses :func:`==?` to decide whether a member of ``xs``
      is an occurrence of ``x``.

   .. function:: init xs

      return all but the last element of ``xs``; ``xs`` must be nonempty

   .. function:: last xs

      return the last element of ``xs``; ``xs`` must be nonempty

   .. function:: listmap f xs

      convenience function which works like :func:`map`, but also deals with
      matrix and string arguments while ensuring that the result is always a
      list; this is primarily used to implement list comprehensions

   .. function:: map f xs

      apply ``f`` to each member of ``xs``

   .. function:: member xs x

      return whether ``x`` is a member of ``xs``

      Note: This uses :func:`==?` to decide whether a member of ``xs``
      is an occurrence of ``x``.

   .. function:: popl p xs

      equivalent to ``{| findl p xs, deletel p xs |}``, but more efficient;
      if no member of ``xs`` satisfies predicate ``p``, returns ``{}``

      Note: ``splitby` can be thought of as a `popall`.

   .. function:: popr p xs

      equivalent to ``{| findr p xs, deleter p xs |}``, but more efficient;
      if no member of ``xs`` satisfies predicate ``p``, returns ``{}``


   .. function:: scanl f a xs

      accumulate the binary function ``f`` over all members of ``xs``, as with
      :func:`foldl`, but return all intermediate results as a list

   .. function:: scanl1 f xs

      accumulate the binary function ``f`` over all members of ``xs``, as with
      :func:`foldl1`, but return all intermediate results as a list

   .. function:: scanr f a xs

      accumulate the binary function ``f`` over all members of ``xs``, as with
      :func:`foldr`, but return all intermediate results as a list

   .. function:: scanr1 f xs

      accumulate the binary function ``f`` over all members of ``xs``, as with
      :func:`foldr1`, but return all intermediate results as a list

   .. function:: sort p xs

      Sorts the elements of the list ``xs`` in ascending order according to
      the given predicate ``p``, using the C ``qsort`` function. The predicate
      ``p`` is invoked with two arguments and should return a truth value
      indicating whether the first argument is "less than" the second. (An
      exception is raised if the result of a comparison is not a machine
      integer.) ::

        > sort (>) (1..10);
        [10,9,8,7,6,5,4,3,2,1]
        > sort (<) ans;
        [1,2,3,4,5,6,7,8,9,10]

   .. function:: split n xs

      equivalent to ``{ take n xs, drop n xs }``, but more efficient

   .. function:: splitby p xs

      equivalent to ``{ filter p xs, filter ((~).p) xs }``, but more efficient

   .. function:: tail xs

      return all but the first element of ``xs``; ``xs`` must be nonempty

   .. function:: take n xs

      take ``n`` elements from the front of ``xs``

   .. function:: takewhile p xs

      take elements from the front of ``xs`` while the predicate ``p`` is
      satisfied

*/

/* Some of the definitions aren't exactly pretty, but they are like that
   because we want them to be both efficient and robust. In particular, we
   require that they do all the necessary argument checking, are
   tail-recursive and handle lazy lists as gracefully as possible. */

all p []		= 1;
all p (x:xs)		= p x && all p xs;

any p []		= 0;
any p (x:xs)		= p x || any p xs;

do f []			= ();
do f (x:xs)		= f x $$ do f xs;

drop n::int []		= [];
drop n::int ys@(x:xs)	= drop (n-1) xs if n>1;
			= xs if n==1;
			= ys otherwise;

dropwhile p []		= [];
dropwhile p ys@(x:xs)	= dropwhile p xs if p x;
			= ys otherwise;

filter p []		= [];
#! --ifnot list-opt
// reverse-based
filter p xs@(_:_)	= tick [] xs
with
  add p x xs		= if p x then x:xs else xs;
  tick zs (x:xs)	= reverse_onto (filter p xs&) (add p x zs) if thunkp xs;
			= tick (add p x zs) xs;
  tick zs []		= reverse_onto [] zs;
  tick zs xs		= reverse_onto (filter p xs) zs;
end;

#! --else
// skip-ahead
filter p xs@(_:_) = aux xs with
    add p x hs = if p x then x:hs else hs;
    aux xs = filter_pre len_pre xs with
        filter_pre 0 _ = filtered_tail;
        filter_pre n::int (x:xs) = add p x (filter_pre (n-1) xs);
    end when
        len_pre@_ filtered_tail = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n [];
    skip_ahead n::int xs@(_:_) = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n (add p x (aux xs&)) if thunkp xs;
                               = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (filter p xs);
end;
#! --endif


findl p [] = throw out_of_bounds; // no match
findl p (x:xs) = if p x then x else findl p xs;

// we don't provide skip-ahead version
popl p [] = {};
popl p xs@(_:_) = tick xs [] with
    tick [] _ = {}; // no match
    tick (x:xs) ws = if p x then {| x, reverse_onto xs ws |}
                     else tick xs (x:ws);
    tick xs ws     = throw (bad_list_value xs); // returning an unreduced function in this case would get ugly
end;

// we don't provide skip-ahead version
deletel p [] = [];
deletel p ys@(_:_) = tick ys [] with
    tick [] _ = ys; // no match
    tick (x:xs) ws = if p x then reverse_onto xs ws else tick xs (x:ws);
    tick xs ws = reverse_onto (deletel p xs) ws;
end;

// we have to juggle a bit to keep notfound private but let these methods access it
public findr popr deleter;
namespace __std__;
private nonfix notfound;

// findr p xs::list = gfold::right (\x _ e -> if p x then abort x else e) throw improper out_of_bounds xs;
::findr p [] = throw out_of_bounds;
::findr p xs@(_:_) = tick xs notfound with
    tick [] w = if w===notfound then throw out_of_bounds else w;
    tick (x:xs) w = tick xs (if p x then x else w);
    tick xs w = throw (bad_list_value xs); // returning an unreduced function in this case would get ugly
end;

#! --ifnot list-opt
// reverse-based
::popr p [] = {};
::popr p xs@(_:_) = tick xs [] [] [] with
    tick []     _  []     _   = {}; // no match
    tick []     ms (h:hs) hss = {| h, tack (reverse ms) hs hss |};
    tick (x:xs) ms hs     hss = if p x
                                then tick xs [] (x:ms) (hs:hss)
                                else tick xs (x:ms) hs hss;
    tick xs     _  _      _   = throw (bad_list_value xs); // returning an unreduced function in this case would get ugly
    tack zs []     []         = zs;
    tack zs []     (xs:xss)   = tack zs xs xss;
    tack zs (y:ys) xss        = tack (y:zs) ys xss;
end;

::deleter p [] = [];
::deleter p ys@(_:_) = tick ys [] [] [] with
    tick []     _  []     _   = ys; // no match
    tick []     ms (_:hs) hss = tack (reverse ms) hs hss;
    tick (x:xs) ms hs     hss = if p x
                                then tick xs [] (x:ms) (hs:hss)
                                else tick xs (x:ms) hs hss;
    tick xs     _  _      _   = throw (bad_list_value xs); // returning an unreduced function in this case would get ugly
    tack zs []     []         = zs;
    tack zs []     (xs:xss)   = tack zs xs xss;
    tack zs (y:ys) xss        = tack (y:zs) ys xss;
end;

#! --else
// skip-ahead
::popr p [] = {};
::popr p xs@(_:_) = case aux xs of
    notfound = {}; // no match
    y:ys = {| y, ys |};
end with
    aux xs = case skip_ahead 0 xs of
        len_pre@_ notfound = pop_pre len_pre xs with
            pop_pre 0 _ = notfound;
            pop_pre n::int xx@(x:xs) = case pop_pre (n-1) xs of
                                          notfound = if p x then xx else notfound;
                                          y:ys = y:x:ys;
                                       end;
        end;
        len_pre@_ (y:ys) = y:append len_pre xs ys;
    end;
    append n::int [] ys | append 0 _ ys = ys;
    append n::int (x:xs) ys = x:append (n-1) xs ys;
    skip_ahead n::int [] = n notfound;
    skip_ahead n::int xs = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (_:xs) = skip_ahead (n+1) xs;
    skip_ahead n::int xs = throw (bad_list_value xs);
end;

::deleter p [] = [];
::deleter p ys@(_:_) = case aux ys of
    notfound = ys; // no match
    ys = ys;
end with
    aux xs = case skip_ahead 0 xs of
        len_pre@_ notfound = pop_pre len_pre xs with
            pop_pre 0 _ = notfound;
            pop_pre n::int (x:xs) = case pop_pre (n-1) xs of
                                       notfound = if p x then xs else notfound;
                                       ys = x:ys;
                                    end;
        end;
        len_pre@_ ys = append len_pre xs ys;
    end;
    append n::int [] ys | append 0 _ ys = ys;
    append n::int (x:xs) ys = x:append (n-1) xs ys;
    skip_ahead n::int [] = n notfound;
    skip_ahead n::int xs = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (_:xs) = skip_ahead (n+1) xs;
    skip_ahead n::int xs = throw (bad_list_value xs);
end;
#! --endif
namespace;


// These are inherently eager.

foldl f a []		= a;
foldl f a (x:xs)	= foldl f (f a x) xs;

foldl1 f (x:xs)		= foldl f x xs;

foldl2 f a _ [] | foldl2 f a [] _ = a;
foldl2 f a (x:xs) (y:ys) = foldl2 f (f a x y) xs ys;

foldl3 f a _ _ [] | foldl3 f a _ [] _ | foldl3 f a [] _ _ = a;
foldl3 f a (x:xs) (y:ys) (z:zs) = foldl3 f (f a x y z) xs ys zs;

foldr f a []		= a;
foldr1 f [x]		= x;
foldr2 f a _ [] | foldr2 f a [] _ = a;
foldr3 f a _ _ [] | foldr3 f a _ [] _ | foldr3 f a [] _ _ = a;
#! --ifnot list-opt
// reverse-based
foldr f a xs@(_:_)	= tick [] xs
with
  tick zs (x:xs)	= tack (x:zs) (foldr f a xs&) if thunkp xs;
			= tick (x:zs) xs;
  tick zs []		= tack zs a;
  tick zs xs		= tack zs (foldr f a xs);
  tack (x:xs) y		= tack xs (f x y);
  tack [] y		= y;
end;

foldr1 f xs@(_:_)	= tick [] xs
with
  /* Do the thunkp check first, before probing the tail. Note that the first
     foldr1 rule above ensures that the topmost tail is already evaluated, so
     that we always make some progress here. */
  tick zs ys@(_:xs)	= tack zs (foldr1 f ys&) if thunkp xs;
  tick zs xs		= case xs of
			    [x]  = tack zs x;
			    x:xs = tick (x:zs) xs;
			    _    = tack zs (foldr1 f xs);
			  end;
  tack (x:xs) y		= tack xs (f x y);
  tack [] y		= y;
end;

foldr2 f a xs@(_:_) ys@(_:_)      = tick [] xs ys
with
  tick us (x:xs) (y:ys)           = tack (x:y:us) (foldr2 f a xs ys&)
                                    if thunkp xs || thunkp ys;
                                  = tick (x:y:us) xs ys;
  tick us _ [] | tick us [] _     = tack us a;
  tick us xs ys                   = tack us (foldr2 f a xs ys);
  tack (x:y:us) a                 = tack us (f x y a);
  tack [] a                       = a;
end;

foldr3 f a xs@(_:_) ys@(_:_) zs@(_:_) = tick [] xs ys zs
with
  tick us (x:xs) (y:ys) (z:zs)    = tack (x:y:z:us) (foldr3 f a xs ys zs&)
                                    if thunkp xs || thunkp ys || thunkp zs;
                                  = tick (x:y:z:us) xs ys zs;
  tick us _ _ [] | tick us _ [] _ | tick us [] _ _
                                  = tack us a;
  tick us xs ys zs                = tack us (foldr3 f a xs ys zs);
  tack (x:y:z:us) a               = tack us (f x y z a);
  tack [] a                       = a;
end;

#! --else
// skip-ahead
foldr f a xs@(_:_) = aux xs with
    aux xs = fold_pre len_pre xs with
        fold_pre 0 _           = folded_tail;
        fold_pre n::int (x:xs) = f x (fold_pre (n-1) xs);
    end when
        len_pre@_ folded_tail  = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n a;
    skip_ahead n::int xs@(_:_) = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n (f x (aux xs&)) if thunkp xs;
                               = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (foldr f a xs);
end;

foldr1 f xs@(_:_) = aux xs with
    aux xs = fold_pre len_pre xs with
        fold_pre 0 _           = folded_tail;
        fold_pre n::int (x:xs) = f x (fold_pre (n-1) xs);
    end when
        len_pre@_ folded_tail  = skip_ahead 0 xs;
    end;
    skip_ahead n::int ys@(_:xs) = n (aux ys) if n == __std__::SKIPSIZE;
                                = n (foldr1 f ys&) if thunkp xs;
    skip_ahead n::int xs        = case xs of
                                    [x]  = n x;
                                    x:xs = skip_ahead (n+1) xs;
                                    _    = n (foldr1 f xs);
                                  end;
end;

foldr2 f a xs@(_:_) ys@(_:_) = aux xs ys with
    aux xs ys = fold_pre len_pre xs ys with
        fold_pre 0 _ _        = folded_tail;
        fold_pre n::int (x:xs) (y:ys) = f x y (fold_pre (n-1) xs ys);
    end when
        len_pre@_ folded_tail = skip_ahead 0 xs ys;
    end;
    skip_ahead n::int [] _    |
    skip_ahead n::int _ []    = n a;
    skip_ahead n::int xs@(_:_) ys@(_:_)
                              = n (aux xs ys) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs) (y:ys)
                              = n (f x y (aux xs ys&))
                                if thunkp xs || thunkp ys;
                              = skip_ahead (n+1) xs ys;
    skip_ahead n::int xs ys   = n (foldr2 f a xs ys);
end;

foldr3 f a xs@(_:_) ys@(_:_) zs@(_:_) = aux xs ys zs with
    aux xs ys zs = fold_pre len_pre xs ys zs with
        fold_pre 0 _ _ _       = folded_tail;
        fold_pre n::int (x:xs) (y:ys) (z:zs) = f x y z (fold_pre (n-1) xs ys zs);
    end when
        len_pre@_ folded_tail  = skip_ahead 0 xs ys zs;
    end;
    skip_ahead n::int [] _ _   |
    skip_ahead n::int _ [] _   |
    skip_ahead n::int _ _ []   = n a;
    skip_ahead n::int xs@(_:_) ys@(_:_) zs@(_:_)
                               = n (aux xs ys zs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs) (y:ys) (z:zs)
                               = n (f x y z (aux xs ys zs&))
                                 if thunkp xs || thunkp ys || thunkp zs;
                               = skip_ahead (n+1) xs ys zs;
    skip_ahead n::int xs ys zs = n (foldr3 f a xs ys zs);
end;
#! --endif

head (x:xs)		= x;

init [x]		= [];
#! --ifnot list-opt
// reverse-based
init xs@(_:_)		= tick [] xs
with
  tick zs ys@(_:xs)	= reverse_onto (init ys&) zs if thunkp xs;
  tick zs xs		= case xs of
			    [x]  = reverse_onto [] zs;
			    x:xs = tick (x:zs) xs;
			    _    = reverse_onto (init xs) zs;
			  end;
end;

#! --else
// skip-ahead
init xs@(_:_) = aux xs with
    aux xs = init_pre len_pre xs with
        init_pre 0 _           = chopped_tail;
        init_pre n::int (x:xs) = x:init_pre (n-1) xs;
    end when
        len_pre@_ chopped_tail = skip_ahead 0 xs;
    end;
    skip_ahead n::int ys@(x:xs) = n (aux ys) if n == __std__::SKIPSIZE;
                                = n (init ys&) if thunkp xs;
    skip_ahead n::int xs        = case xs of
                                    [_]  = n [];
                                    _:xs = skip_ahead (n+1) xs;
                                    _    = n (init xs);
                                  end;
end;
#! --endif

last [x]		= x;
last (x:xs)		= last xs;


map f []		= [];
#! --ifnot list-opt
// reverse-based
map f xs@(_:_)		= tick [] xs
with
  tick zs (x:xs)	= reverse_onto (map f xs&) (f x:zs) if thunkp xs;
			= tick (f x:zs) xs;
  tick zs []		= reverse_onto [] zs;
  tick zs xs		= reverse_onto (map f xs) zs;
end;

#! --else
// skip-ahead
map f xs@(_:_) = aux xs with
    aux xs = map_pre len_pre xs with
        map_pre 0 _            = mapped_tail;
        map_pre n::int (x:xs)  = f x:map_pre (n-1) xs;
    end when
        len_pre@_ mapped_tail  = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n [];
    skip_ahead n::int xs@(_:_) = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n (f x:aux xs&) if thunkp xs;
                               = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (map f xs);
end;
#! --endif


// no skip-ahead implementations yet, I'm lazy
scanl f a []		= [a];
scanl f a xs@(_:_)	= tick a [] xs
with
  tick a zs (x:xs)	= reverse_onto (scanl f (f a x) xs&) (a:zs) if thunkp xs;
			= tick (f a x) (a:zs) xs;
  tick a zs []		= reverse_onto [a] zs;
  tick a zs xs		= reverse_onto (scanl f a xs) zs;
end;

scanl1 f []		= [];
scanl1 f (x:xs)		= scanl f x xs;

scanr f a []		= [a];
scanr f a xs@(_:_)	= tick [] xs
with
  /* Hack around with thunks to make these matches irrefutable. */
  tick zs (x:xs)	= tack zs us when
			    ys = scanr f a xs&;
			    y  = (case ys of
				    y:_ = y;
				    scanr _ _ ys = throw (bad_list_value ys);
				    _ = throw (bad_list_value ys);
				  end)&;
			    us = f x y : ys;
			  end if thunkp xs;
  tick zs (x:xs)	= tack zs (f x (y when y:_ = ys end)&:ys
				   when ys = scanr f a xs& end) if thunkp xs;
			= tick (x:zs) xs;
  tick zs []		= tack zs [a];
  tick zs xs		= throw (bad_list_value xs);
  tack (x:xs) ys	= tack xs (f x y:ys) when y:_ = ys end;
  tack [] ys		= ys;
end;

scanr1 f []		= [];
scanr1 f [x]		= [x];
scanr1 f xs@(_:_)	= tick [] xs
with
  tick zs (x:xs)	= tack zs us when
			    ys = scanr1 f xs&;
			    y  = (case ys of
				    y:_ = y;
				    scanr1 _ ys = throw (bad_list_value ys);
				    _ = throw (bad_list_value ys);
				  end)&;
			    us = f x y : ys;
			  end if thunkp xs;
  tick zs xs		= case xs of
			    [x]  = tack zs [x];
			    x:xs = tick (x:zs) xs;
			    _    = throw (bad_list_value xs);
			  end;
  tack (x:xs) ys	= tack xs (f x y:ys) when y:_ = ys end;
  tack [] ys		= ys;
end;


// split m xs = { subseq xs 0 (m-1), subseq xs m (#xs-1) };
split m::int [] = { [], [] };
splitby p [] = { [], [] };
#! --ifnot list-opt
// reverse-based
split m::int xs@(_:_) = aux m [] xs with
    aux _::int ws []     = {| xs, [] |}; // use original
    aux 0 ws xs          = {| reverse ws, xs |};
    aux m::int ws (x:xs) = {| reverse_onto (x:take (m-1) xs&) ws, drop (m-1) xs& |}
                           if thunkp xs;
                         = aux (m-1) (x:ws) xs;
    aux m::int ws xs     = {| reverse_onto (take m xs) ws, drop m xs |};
end;

splitby p xs@(_:_) = aux xs [] [] with
    aux []     [] _  = {| xs, [] |}; // no misses, use original
    aux []     _  [] = {| [], xs |}; // no hits, use original
    aux []     ms hs = {| reverse hs, reverse ms |};
    aux (x:xs) ms hs
        = if p x
          then {| reverse_onto (filter p xs&) (x:hs), reverse_onto (filter ((~).p) xs&) ms |}
          else {| reverse_onto (filter p xs&) hs, reverse_onto (filter ((~).p) xs&) (x:ms) |} if thunkp xs;
        = if p x
          then aux xs ms (x:hs)
          else aux xs (x:ms) hs;
    aux xs ms hs     = {| reverse_onto (filter p xs) hs, reverse_onto (filter ((~).p) xs) ms |};
end;

#! --else
// skip-ahead
split m::int xs@(_:_) = case aux m xs of
    front:back = {| front, back |};
end with
    add x (front:back) = (x:front):back;
    aux m::int xs = split_pre len_pre xs with
        split_pre 0      _            = split_tails;
        split_pre n::int (x:xs)       = add x (split_pre (n-1) xs);
    end when
        len_pre@_ split_tails         = skip_ahead m 0 xs;
    end;
    skip_ahead m::int n::int xs       = n ([]:xs) if m <= 0 || xs === [];
    skip_ahead m::int n::int xs@(_:_) = n (aux m xs) if n == __std__::SKIPSIZE;
    skip_ahead m::int n::int (x:xs)
                           = n ((x:take (m-1) xs&):drop (m-1) xs&)
                             if thunkp xs;
                           = skip_ahead (m-1) (n+1) xs;
    skip_ahead m::int n::int xs       = n ((take m xs):drop m xs);
end;

splitby p xs@(_:_) = case aux xs of
    yes:no = {| yes, no |};
end with
    add p x (yes:no) = if p x then (x:yes):no else yes:(x:no);
    aux xs = split_pre len_pre xs with
        split_pre 0 _           = split_tails;
        split_pre n::int (x:xs) = add p x (split_pre (n-1) xs);
    end when
        len_pre@_ split_tails   = skip_ahead 0 xs;
    end;
    skip_ahead n::int []        = n ([]:[]);
    skip_ahead n::int xs@(_:_)  = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)
                         = n (add p x (filter p xs&:filter ((~).p) xs&))
                           if thunkp xs;
                         = skip_ahead (n+1) xs;
    skip_ahead n::int xs = n (filter p xs:filter ((~).p) xs);
end;
#! --endif


tail (x:xs)		= xs;


take n::int []		= [];
takewhile p []	= [];
#! --ifnot list-opt
// reverse-based
take n::int xs@(_:_)	= tick n [] xs
with
  tick n::int zs xs	= reverse_onto [] zs if n<=0;
			= reverse_onto (take n xs&) zs if thunkp xs;
			= case xs of
			    []   = reverse_onto [] zs;
			    x:xs = tick (n-1) (x:zs) xs;
			    _    = reverse_onto (take n xs) zs;
			  end;
end;

takewhile p xs@(_:_)	= tick [] xs
with
  tick zs xs		= reverse_onto (takewhile p xs&) zs if thunkp xs;
			= case xs of
			    []   = reverse_onto [] zs;
			    x:xs = tick (x:zs) xs if p x;
			         = reverse_onto [] zs;
			    _    = reverse_onto (takewhile p xs) zs;
			  end;
end;

#! --else
// skip-ahead
take m::int xs@(_:_) = aux m xs with
    aux 0 xs = [];
    aux m::int xs = take_pre len_pre xs with
        take_pre 0      _             = front_tail;
        take_pre n::int (x:xs)        = x:take_pre (n-1) xs;
    end when
        len_pre@_ front_tail          = skip_ahead m 0 xs;
    end;
    skip_ahead m::int n::int xs       = n [] if m <= 0 || xs === [];
    skip_ahead m::int n::int xs@(_:_) = n (aux m xs) if n == __std__::SKIPSIZE;
    skip_ahead m::int n::int (x:xs)   = n (x:aux (m-1) xs&) if thunkp xs;
                                      = skip_ahead (m-1) (n+1) xs;
    skip_ahead m::int n::int xs       = n (take m xs);
end;

takewhile p xs@(_:_) = aux xs with
    aux xs = take_pre len_pre xs with
        take_pre 0      _      = front_tail;
        take_pre n::int (x:xs) = x:take_pre (n-1) xs;
    end when
        len_pre@_ front_tail   = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n [];
    skip_ahead n::int xs@(_:_) = n (aux xs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)
            = if p x then n (x:aux xs&) else n [] if thunkp xs;
            = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (takewhile p xs);
end;
#! --endif


/* Concatenate a list of lists. */

cat []			= [];
#! --ifnot list-opt
// reverse-based
cat xs@(_:_)		= foldr (tick []) [] xs
with
  /* Unfortunately, the global list concatenation operator (+) isn't fully
     lazy in Pure, because it's also used for arithmetic operations. Using it
     here would make foldr (and hence cat) eager. Therefore we use our own
     concatenation operation here, which properly deals with the case that ys
     is an infinite stream when applied recursively. */
  tick zs (x:xs) ys	= reverse_onto (tick [] xs ys&) (x:zs) if thunkp xs;
			= tick (x:zs) xs ys;
  tick zs [] ys		= reverse_onto ys zs;
  tick zs xs ys		= reverse_onto (xs+ys) zs;
  /* We also use a slightly modified foldr function here, so that we can
     handle the case that xs is an improper list more gracefully. */
  foldr f a []		= a;
  foldr f a xs@(_:_)	= tick [] xs
  with
    tick zs (x:xs)	= tack (x:zs) (foldr f a xs&) if thunkp xs;
			= tick (x:zs) xs;
    tick zs []		= tack zs a;
    tick zs xs		= tack zs (foldr f a xs);
    tack (x:xs) y	= tack xs (f x y);
    tack [] y		= y;
  end;
  foldr (tick _) [] x	= cat x;
end;

#! --else
// skip-ahead
cat (xs::list:yss) = aux xs with
    aux xs = cat_pre len_pre xs with
        cat_pre 0 _           = catted_tail;
        cat_pre n::int (x:xs) = x:cat_pre (n-1) xs;
    end when
        len_pre@_ catted_tail  = skip_ahead 0 xs;
    end;
    skip_ahead n::int []       = n (cat yss);
    skip_ahead n::int xs@(_:_) = n (aux xs) if n== __std__::SKIPSIZE;
    skip_ahead n::int (x:xs)   = n (x:aux xs&) if thunkp xs;
    skip_ahead n::int (x:xs)   = skip_ahead (n+1) xs;
    skip_ahead n::int xs       = n (xs+cat yss);
end;
#! --endif


/* Map a function to a list and concatenate the results. This is used by list
   comprehensions. */

catmap f []		= [];
#! --ifnot list-opt
// reverse-based
catmap f xs@(_:_)	= cat (map f xs);
/* NOTE: This definition (from the Haskell prelude) is better, but doesn't
   preserve left-to-right execution order. */
//catmap f xs@(_:_)	= foldr ((+).f) [] xs;

#! --else
// skip-ahead
catmap f xs@(_:_) = aux xs with
    aux xs = map_pre len_pre xs with
        map_pre 0 _              = mapped_tail;
        map_pre n::int (x:xs)    = lazy_cat (f x) (map_pre (n-1) xs);
    end when
        len_pre@_ mapped_tail    = skip_map 0 xs;
    end;
    skip_map n::int []           = n [];
    skip_map n::int xs@(_:_)     = n (aux xs) if n == __std__::SKIPSIZE;
    skip_map n::int (x:xs)       = n (lazy_cat (f x) (aux xs&)) if thunkp xs;
                                 = skip_map (n+1) xs;
    skip_map n::int xs           = n (catmap f xs);
    lazy_cat xs yss              = cat_pre len_pre xs with
        cat_pre 0 _              = catted_tail;
        cat_pre n::int (x:xs)    = x:cat_pre (n-1) xs;
    end when
        len_pre@_ catted_tail    = skip_cat yss 0 xs;
    end;
    skip_cat yss n::int []       = n yss;
    skip_cat yss n::int xs@(_:_) = n (aux xs) if n== __std__::SKIPSIZE;
    skip_cat yss n::int (x:xs)   = n (x:lazy_cat xs yss&) if thunkp xs;
    skip_cat yss n::int (x:xs)   = skip_cat yss (n+1) xs;
    skip_cat yss n::int xs       = n (xs+yss);
end;
#! --endif


/* Map a function to a list, like map, but first promote the argument to a
   list if possible. This is used by list comprehensions. */

listmap f []		= [];
listmap f xs@(_:_)	= map f xs;

/* Search an element in a list. Returns -1 if not found, index of first
   occurrence otherwise. */

index [] _		= -1;
index (x:xs) y		= search 0 (x:xs) with
  search _ []		= -1;
  search n::int (x:xs)	= n if x==?y;
			= search (n+1) xs;
  search _ xs		= index xs y;
end;

member [] y             = 0;
// member xs@(_:_) y    = index xs y+1;
// member xs@(_:_) y    = any (y==?) xs;
member (x:xs) y         = 1 if y==? x;
                        = member xs y;


/* Arithmetic sequences. */

public iterate iterwhile; // see below for these

n1:n2..m	= if nanp n1 || nanp m || double m===-s then []
		  else if double m===s then iterate (+k) n1
		  else iterwhile (p (m+0.5*k)) (+k) n1
		  when s,p = if k>0 then inf,(>=) else -inf,(<=) end
		  if realp k && k~=0 && ~infp n1 && ~infp n2
		  when k = n2-n1 end;
n..m		= if nanp n || nanp m || double m===-inf then []
		  else if double m===inf then iterate (+1) n
		  else iterwhile ((>=) m) (+1) n
		  if ~listp n && ~infp n;


/* ..

   List Generators
   ~~~~~~~~~~~~~~~

   Some useful (infinite) list generators, as well as some finite (and eager)
   variations of these. The latter work like a combination of :func:`take` or
   :func:`takewhile` and the former, but are implemented directly for better
   efficiency.

   .. function:: cycle xs

      cycles through the elements of the nonempty list ``xs``, ad infinitum

   .. function:: cyclen n xs

      eager version of :func:`cycle`, returns the first ``n`` elements of
      ``cycle xs``

   .. function:: iterate f x

      returns the stream containing ``x``, ``f x``, ``f (f x)``, etc.,
      ad infinitum

   .. function:: iteraten n f x

      eager version of :func:`iterate`, returns the first ``n`` elements of
      ``iterate f x``

   .. function:: iterwhile p f x

      another eager version of :func:`iterate`, returns the list of all
      elements from the front of ``iterate f x`` for which the predicate ``p``
      holds

   .. function:: repeat x

      returns an infinite stream of ``x``\ s

   .. function:: repeatn n x

      eager version of :func:`repeat`, returns a list with ``n`` ``x``\ s

*/

/* Some useful (infinite) list generators. */

iterate f x		= x : iterate f (f x)&;
repeat x		= x : repeat x&;
cycle ys@(x:xs)		= x : (xs+cycle ys)&;

/* Some finite (and strict) generators. These work like the a combination of
   takewhile/take and the above, but are implemented directly for maximum
   efficiency. */

// no skip-ahead implentations yet, I'm lazy
iterwhile p f x		= accum [] p f x with
			    accum xs p f x = accum (x:xs) p f (f x) if p x;
				           = reverse xs otherwise;
			  end;

iteraten n::int f x	= [] if n<=0;
			= accum [] n f x
with
  accum xs n::int f x	= reverse (x:xs) if n==1;
			= accum (x:xs) (n-1) f (f x);
end;

repeatn n::int x	= accum [] n x with
  accum xs n::int x	= xs if n<=0;
			= accum (x:xs) (n-1) x;
end;

cyclen n::int (x:xs)	= [] if n<=0;
			= accum [] n with
			    accum ys n::int = cat ys+take n xs if n<=m;
			                    = accum (xs:ys) (n-m) otherwise;
			  end when xs = x:xs; m::int = #xs end if rlistp xs;

/* ..

   Zip and Friends
   ~~~~~~~~~~~~~~~

   .. function:: unzip xys

      takes a list of pairs to a pair of lists of corresponding elements

   .. function:: unzip3 xyzs

      :func:`unzip` with triples

   .. function:: zip xs ys

      return the list of corresponding pairs ``(x,y)`` where ``x`` runs
      through the elements of ``xs`` and ``y`` runs through the elements of
      ``ys``

   .. function:: zip3 xs ys zs

      :func:`zip` with three lists, returns a list of triples

   .. function:: zipwith f xs ys

      apply the binary function ``f`` to corresponding elements of ``xs``
      and ``ys``

   .. function:: zipwith3 f xs ys zs

      apply the ternary function ``f`` to corresponding elements of ``xs``,
      ``ys`` and ``zs``

   Pure also has the following variations of :func:`zipwith` and
   :func:`zipwith3` which throw away all intermediate results and return the
   empty tuple ``()``. That is, these work like :func:`do` but pull arguments
   from two or three lists, respectively:

   .. function:: dowith f xs ys

      apply the binary function ``f`` to corresponding elements of ``xs``
      and ``ys``, return ``()``

   .. function:: dowith3 f xs ys zs

      apply the ternary function ``f`` to corresponding elements of ``xs``,
      ``ys`` and ``zs``, return ``()``

*/


zip [] _		|
zip _ []		= [];
zip3 [] _ _		|
zip3 _ [] _		|
zip3 _ _ []		= [];
zipwith f [] _		|
zipwith f _ []		= [];
zipwith3 f [] _ _		|
zipwith3 f _ [] _		|
zipwith3 f _ _ []		= [];
#! --ifnot list-opt
// reverse-based
zip xs@(_:_) ys@(_:_)	= tick [] xs ys
with
  tick us (x:xs) (y:ys)	= reverse_onto (zip xs ys&) ((x,y):us)
			    if thunkp xs || thunkp ys;
			= tick ((x,y):us) xs ys;
  tick us [] _		|
  tick us _ []		= reverse_onto [] us;
  tick us xs ys		= reverse_onto (zip xs ys) us;
end;

zip3 xs@(_:_) ys@(_:_) zs@(_:_)
			= tick [] xs ys zs
with
  tick us (x:xs) (y:ys) (z:zs)
			= reverse_onto (zip3 xs ys zs&) ((x,y,z):us)
			    if thunkp xs || thunkp ys || thunkp zs;
			= tick ((x,y,z):us) xs ys zs;
  tick us [] _ _	|
  tick us _ [] _	|
  tick us _ _ []	= reverse_onto [] us;
  tick us xs ys zs	= reverse_onto (zip3 xs ys zs) us;
end;

zipwith f xs@(_:_) ys@(_:_)
			= tick [] xs ys
with
  tick us (x:xs) (y:ys)	= reverse_onto (zipwith f xs ys&) (f x y:us)
			    if thunkp xs || thunkp ys;
			= tick (f x y:us) xs ys;
  tick us [] _		|
  tick us _ []		= reverse_onto [] us;
  tick us xs ys		= reverse_onto (zipwith f xs ys) us;
end;

zipwith3 f xs@(_:_) ys@(_:_) zs@(_:_)
			= tick [] xs ys zs
with
  tick us (x:xs) (y:ys) (z:zs)
			= reverse_onto (zipwith3 f xs ys zs&) (f x y z:us)
			    if thunkp xs || thunkp ys || thunkp zs;
			= tick (f x y z:us) xs ys zs;
  tick us [] _ _	|
  tick us _ [] _	|
  tick us _ _ []	= reverse_onto [] us;
  tick us xs ys zs	= reverse_onto (zipwith3 f xs ys zs) us;
end;

#! --else
// skip-ahead
zip xs@(_:_) ys@(_:_) = aux xs ys with
    aux xs ys = zip_pre len_pre xs ys with
        zip_pre 0 _ _ = zipped_tail;
        zip_pre n::int (x:xs) (y:ys) = (x,y):zip_pre (n-1) xs ys;
    end when
        len_pre@_ zipped_tail = skip_ahead 0 xs ys;
    end;
    skip_ahead n::int [] _  |
    skip_ahead n::int _ []  = n [];
    skip_ahead n::int xs@(_:_) ys@(_:_)
                            = n (aux xs ys) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs) (y:ys)
                            = n ((x,y):aux xs ys&)
                              if thunkp xs || thunkp ys;
                            = skip_ahead (n+1) xs ys;
    skip_ahead n::int xs ys = n (zip xs ys);
end;

zip3 xs@(_:_) ys@(_:_) zs@(_:_) = aux xs ys zs with
    aux xs ys zs = zip_pre len_pre xs ys zs with
        zip_pre 0 _ _ _ = zipped_tail;
        zip_pre n::int (x:xs) (y:ys) (z:zs) = (x,y,z):zip_pre (n-1) xs ys zs;
    end when
        len_pre@_ zipped_tail = skip_ahead 0 xs ys zs;
    end;
    skip_ahead n::int [] _ _   |
    skip_ahead n::int _ [] _   |
    skip_ahead n::int _ _ []   = n [];
    skip_ahead n::int xs@(_:_) ys@(_:_) zs@(_:_)
                               = n (aux xs ys zs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs) (y:ys) (z:zs)
                               = n ((x,y,z):aux xs ys zs&)
                                 if thunkp xs || thunkp ys || thunkp zs;
                               = skip_ahead (n+1) xs ys zs;
    skip_ahead n::int xs ys zs = n (zip3 xs ys zs);
end;

zipwith f xs@(_:_) ys@(_:_) = aux xs ys with
    aux xs ys = zip_pre len_pre xs ys with
        zip_pre 0 _ _ = zipped_tail;
        zip_pre n::int (x:xs) (y:ys) = f x y:zip_pre (n-1) xs ys;
    end when
        len_pre@_ zipped_tail = skip_ahead 0 xs ys;
    end;
    skip_ahead n::int [] _  |
    skip_ahead n::int _ []  = n [];
    skip_ahead n::int xs@(_:_) ys@(_:_)
                            = n (aux xs ys) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs) (y:ys)
                            = n (f x y:aux xs ys&)
                              if thunkp xs || thunkp ys;
                            = skip_ahead (n+1) xs ys;
    skip_ahead n::int xs ys = n (zipwith f xs ys);
end;

zipwith3 f xs@(_:_) ys@(_:_) zs@(_:_) = aux xs ys zs with
    aux xs ys zs = zip_pre len_pre xs ys zs with
        zip_pre 0 _ _ _ = zipped_tail;
        zip_pre n::int (x:xs) (y:ys) (z:zs) = f x y z:zip_pre (n-1) xs ys zs;
    end when
        len_pre@_ zipped_tail = skip_ahead 0 xs ys zs;
    end;
    skip_ahead n::int [] _ _   |
    skip_ahead n::int _ [] _   |
    skip_ahead n::int _ _ []   = n [];
    skip_ahead n::int xs@(_:_) ys@(_:_) zs@(_:_)
                               = n (aux xs ys zs) if n == __std__::SKIPSIZE;
    skip_ahead n::int (x:xs) (y:ys) (z:zs)
                               = n (f x y z:aux xs ys zs&)
                                 if thunkp xs || thunkp ys || thunkp zs;
                               = skip_ahead (n+1) xs ys zs;
    skip_ahead n::int xs ys zs = n (zipwith3 f xs ys zs);
end;
#! --endif

unzip []		= [],[];
unzip us@(_:_)		= foldr accum ([],[]) us
with
  accum u@(x,y) us	= x:(xs when xs,_ = check us end)&,
			  y:(ys when _,ys = check us end)& if thunkp us;
			= x:xs,y:ys when xs,ys = check us end;
  accum u _		= throw (bad_tuple_value u);
  check us@(_,_)	= us;
  check (foldr _ _ us)	= throw (bad_list_value us);
  check us		= throw (bad_tuple_value us);
end;

unzip3 []		= [],[],[];
unzip3 us@(_:_)		= foldr accum ([],[],[]) us
with
  accum u@(x,y,z) us	= x:(xs when xs,_,_ = check us end)&,
			  y:(ys when _,ys,_ = check us end)&,
			  z:(zs when _,_,zs = check us end)& if thunkp us;
			= x:xs,y:ys,z:zs when xs,ys,zs = check us end;
  accum u _		= throw (bad_tuple_value u);
  check us@(_,_,_)	= us;
  check (foldr _ _ us)	= throw (bad_list_value us);
  check us		= throw (bad_tuple_value us);
end;

dowith f (x:xs) (y:ys)	= f x y $$ dowith f xs ys;
dowith f _ _		= () otherwise;

dowith3 f (x:xs) (y:ys) (z:zs)
			= f x y z $$ dowith3 f xs ys zs;
dowith3 f _ _ _		= () otherwise;
