
/* Basic list functions. */

/* Copyright (c) 2008-2012 by Albert Graef <Dr.Graef@t-online.de>.
   Copyright (c) 2012 by Dubiousjim <dubiousjim@gmail.com>.

   This file is part of the Pure standard library.

   The Pure standard library is free software: you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
   more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */




/* List reversal. This is a strict operation, of course, so it will loop on
   infinite lists. Also, this is one of the few list operations which throws
   an exception for improper lists, since in that case there really isn't any
   meaningful value to return. */

reverse []	= [];
reverse (x:xs)	= accum [x] xs with
  accum ys (x:xs)	= accum (x:ys) xs;
  accum ys []		= ys;
  accum	ys xs		= throw (bad_list_value xs);
end;


/* List concatenation. For a robust implementation which works with both
   ordinary lists and streams, we want this to be tail-recursive *and*
   non-strict. So we first walk down the list, popping elements from the first
   operand until we find an empty or thunked tail ('tick'), then walk back up
   again, pushing elements in front of the result list ('tack'). */

[]+ys		= ys;
xs@(_:_)+ys	= tick [] xs ys
with
  tick zs (x:xs) ys	= tack (x:zs) ((xs+ys)&) if thunkp xs;
			= tick (x:zs) xs ys;
  tick zs [] ys		= tack zs ys;
  /* Handle an improper list tail (xs+ys is in normal form here). */
  tick zs xs ys		= tack zs (xs+ys);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;


/* ..

   List Functions
   --------------

   This mostly comes straight from the Q prelude which in turn was based on
   the first edition of the Bird/Wadler book, and is very similar to what you
   can find in the Haskell prelude. Some functions have slightly different
   names, though, and of course everything is typed dynamically.

   Common List Functions
   ~~~~~~~~~~~~~~~~~~~~~

   .. function:: any p xs

      test whether the predicate ``p`` holds for any of the members of ``xs``

   .. function:: all p xs

      test whether the predicate ``p`` holds for all of the members of ``xs``

   .. function:: cat xs

      concatenate a list of lists

   .. function:: catmap f xs

      convenience function which combines '\ :func:`cat`\ ' and
      '\ :func:`map`\ '; this is also used to implement list comprehensions

   .. function:: delete xs y

      return ``xs`` without the first member satisfying ``(y==?)``;
      if no member matches ``y``, will just return ``xs``

   .. function:: do f xs

      apply ``f`` to all members of ``xs``, like '\ :func:`map`\ ', but throw
      away all intermediate results and return ``()``

   .. function:: drop n xs

      remove ``n`` elements from the front of ``xs``

   .. function:: dropwhile p xs

      remove elements from the front of ``xs`` while the predicate ``p`` is
      satisfied

   .. function:: filter p xs

      return the list of all members of ``xs`` satisfying the predicate ``p``

   .. function:: foldl f a xs

      accumulate the binary function ``f`` over all members of ``xs``,
      starting from the initial value ``a`` and working from the front of the
      list towards its end

   .. function:: foldl1 f xs

      accumulate the binary function ``f`` over all members of ``xs``,
      starting from the value ``head xs`` and working from the front of the
      list towards its end; ``xs`` must be nonempty

   .. function:: foldr f a xs

      accumulate the binary function ``f`` over all members of ``xs``,
      starting from the initial value ``a`` and working from the end of the
      list towards its front

   .. function:: foldr1 f xs

      accumulate the binary function ``f`` over all members of ``xs``,
      starting from the value ``last xs`` and working from the end of the list
      towards its front; ``xs`` must be nonempty

   .. function:: head xs

      return the first element of ``xs``; ``xs`` must be nonempty

   .. function:: index xs x

      search for an occurrence of ``x`` in ``xs`` and return the index of the
      first occurrence, if any, ``-1`` otherwise

      This uses '\ :func:`==?`\ ' to decide whether a member of ``xs``
      is an occurrence of ``x``.

   .. function:: init xs

      return all but the last element of ``xs``; ``xs`` must be nonempty

   .. function:: last xs

      return the last element of ``xs``; ``xs`` must be nonempty

   .. function:: listmap f xs

      convenience function which works like :func:`map`, but also deals with
      matrix and string arguments while ensuring that the result is always a
      list; this is primarily used to implement list comprehensions

   .. function:: map f xs

      apply ``f`` to each member of ``xs``

   .. function:: member xs x

      return whether ``x`` is a member of ``xs``

      Note: This uses :func:`==?` to decide whether a member of ``xs``
      is an occurrence of ``x``.

   .. function:: scanl f a xs

      accumulate the binary function ``f`` over all members of ``xs``, as with
      :func:`foldl`, but return all intermediate results as a list

   .. function:: scanl1 f xs

      accumulate the binary function ``f`` over all members of ``xs``, as with
      :func:`foldl1`, but return all intermediate results as a list

   .. function:: scanr f a xs

      accumulate the binary function ``f`` over all members of ``xs``, as with
      :func:`foldr`, but return all intermediate results as a list

   .. function:: scanr1 f xs

      accumulate the binary function ``f`` over all members of ``xs``, as with
      :func:`foldr1`, but return all intermediate results as a list

   .. function:: sort p xs

      Sorts the elements of the list ``xs`` in ascending order according to
      the given predicate ``p``, using the C ``qsort`` function. The predicate
      ``p`` is invoked with two arguments and should return a truth value
      indicating whether the first argument is "less than" the second. (An
      exception is raised if the result of a comparison is not a machine
      integer.) ::

        > sort (>) (1..10);
	[10,9,8,7,6,5,4,3,2,1]
	> sort (<) ans;
	[1,2,3,4,5,6,7,8,9,10]

   .. function:: tail xs

      return all but the first element of ``xs``; ``xs`` must be nonempty

   .. function:: take n xs

      take ``n`` elements from the front of ``xs``

   .. function:: takewhile p xs

      take elements from the front of ``xs`` while the predicate ``p`` is
      satisfied

*/

/* Some of the definitions aren't exactly pretty, but they are like that
   because we want them to be both efficient and robust. In particular, we
   require that they do all the necessary argument checking, are
   tail-recursive and handle lazy lists as gracefully as possible. */

all p []		= 1;
all p (x:xs)		= p x && all p xs;

any p []		= 0;
any p (x:xs)		= p x || any p xs;

delete [] y = [];
delete xs@(_:_) y = tick xs [] with
    tick [] _ = xs; // no match
    tick (x:xs) ws      = if y==?x then tack ws xs else tick xs (x:ws);
    tick xs ws          = tack ws (delete xs y);
    tack (x:xs) ys      = tack xs (x:ys);
    tack [] ys          = ys;
end;

do f []			= ();
do f (x:xs)		= f x $$ do f xs;

drop n::int []		= [];
drop n::int ys@(x:xs)	= drop (n-1) xs if n>1;
			= xs if n==1;
			= ys otherwise;

dropwhile p []		= [];
dropwhile p ys@(x:xs)	= dropwhile p xs if p x;
			= ys otherwise;

filter p []		= [];
filter p xs@(_:_)	= tick [] xs
with
  add p x xs		= if p x then x:xs else xs;
  tick zs (x:xs)	= tack (add p x zs) (filter p xs&) if thunkp xs;
			= tick (add p x zs) xs;
  tick zs []		= tack zs [];
  tick _ xs		= throw (bad_list_value xs);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

foldl f a []		= a;
foldl f a (x:xs)	= foldl f (f a x) xs;

foldl1 f (x:xs)		= foldl f x xs;

foldr f a []		= a;
foldr f a xs@(_:_)	= tick [] xs
with
  tick zs (x:xs)	= tack (x:zs) (foldr f a xs&) if thunkp xs;
			= tick (x:zs) xs;
  tick zs []		= tack zs a;
  tick zs xs		= tack zs (foldr f a xs);
  tack (x:xs) y		= tack xs (f x y);
  tack [] y		= y;
end;

foldr1 f [x]		= x;
foldr1 f xs@(_:_)	= tick [] xs
with
  /* Do the thunkp check first, before probing the tail. Note that the first
     foldr1 rule above ensures that the topmost tail is already evaluated, so
     that we always make some progress here. */
  tick zs ys@(_:xs)	= tack zs (foldr1 f ys&) if thunkp xs;
  tick zs xs		= case xs of
			    [x]  = tack zs x;
			    x:xs = tick (x:zs) xs;
			    _    = tack zs (foldr1 f xs);
			  end;
  tack (x:xs) y		= tack xs (f x y);
  tack [] y		= y;
end;

head (x:xs)		= x;

init [x]		= [];
init xs@(_:_)		= tick [] xs
with
  tick zs ys@(_:xs)	= tack zs (init ys&) if thunkp xs;
  tick zs xs		= case xs of
			    [x]  = tack zs [];
			    x:xs = tick (x:zs) xs;
			    _    = tack zs (init xs);
			  end;
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

last [x]		= x;
last (x:xs)		= last xs;

map f []		= [];
map f xs@(_:_)		= tick [] xs
with
  tick zs (x:xs)	= tack (f x:zs) (map f xs&) if thunkp xs;
			= tick (f x:zs) xs;
  tick zs []		= tack zs [];
  tick zs xs		= tack zs (map f xs);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

scanl f a []		= [a];
scanl f a xs@(_:_)	= tick a [] xs
with
  tick a zs (x:xs)	= tack (a:zs) (scanl f (f a x) xs&) if thunkp xs;
			= tick (f a x) (a:zs) xs;
  tick a zs []		= tack zs [a];
  tick a zs xs		= tack zs (scanl f a xs);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

scanl1 f []		= [];
scanl1 f (x:xs)		= scanl f x xs;

scanr f a []		= [a];
scanr f a xs@(_:_)	= tick [] xs
with
  /* Hack around with thunks to make these matches irrefutable. */
  tick zs (x:xs)	= tack zs us when
			    ys = scanr f a xs&;
			    y  = (case ys of
				    y:_ = y;
				    scanr _ _ ys = throw (bad_list_value ys);
				    _ = throw (bad_list_value ys);
				  end)&;
			    us = f x y : ys;
			  end if thunkp xs;
  tick zs (x:xs)	= tack zs (f x (y when y:_ = ys end)&:ys
				   when ys = scanr f a xs& end) if thunkp xs;
			= tick (x:zs) xs;
  tick zs []		= tack zs [a];
  tick zs xs		= throw (bad_list_value xs);
  tack (x:xs) ys	= tack xs (f x y:ys) when y:_ = ys end;
  tack [] ys		= ys;
end;

scanr1 f []		= [];
scanr1 f [x]		= [x];
scanr1 f xs@(_:_)	= tick [] xs
with
  tick zs (x:xs)	= tack zs us when
			    ys = scanr1 f xs&;
			    y  = (case ys of
				    y:_ = y;
				    scanr1 _ ys = throw (bad_list_value ys);
				    _ = throw (bad_list_value ys);
				  end)&;
			    us = f x y : ys;
			  end if thunkp xs;
  tick zs xs		= case xs of
			    [x]  = tack zs [x];
			    x:xs = tick (x:zs) xs;
			    _    = throw (bad_list_value xs);
			  end;
  tack (x:xs) ys	= tack xs (f x y:ys) when y:_ = ys end;
  tack [] ys		= ys;
end;

tail (x:xs)		= xs;

take n::int []		= [];
take n::int xs@(_:_)	= tick n [] xs
with
  tick n::int zs xs	= tack zs [] if n<=0;
			= tack zs (take n xs&) if thunkp xs;
			= case xs of
			    []   = tack zs [];
			    x:xs = tick (n-1) (x:zs) xs;
			    _    = tack zs (take n xs);
			  end;
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

takewhile p []	= [];
takewhile p xs@(_:_)	= tick [] xs
with
  tick zs xs		= tack zs (takewhile p xs&) if thunkp xs;
			= case xs of
			    []   = tack zs [];
			    x:xs = tick (x:zs) xs if p x;
			         = tack zs [];
			    _    = tack zs (takewhile p xs);
			  end;
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

/* Concatenate a list of lists. */

cat []			= [];
cat xs@(_:_)		= foldr (tick []) [] xs
with
  /* Unfortunately, the global list concatenation operator (+) isn't fully
     lazy in Pure, because it's also used for arithmetic operations. Using it
     here would make foldr (and hence cat) eager. Therefore we use our own
     concatenation operation here, which properly deals with the case that ys
     is an infinite stream when applied recursively. */
  tick zs (x:xs) ys	= tack (x:zs) (tick [] xs ys&) if thunkp xs;
			= tick (x:zs) xs ys;
  tick zs [] ys		= tack zs ys;
  tick zs xs ys		= tack zs (xs+ys);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
  /* We also use a slightly modified foldr function here, so that we can
     handle the case that xs is an improper list more gracefully. */
  foldr f a []		= a;
  foldr f a xs@(_:_)	= tick [] xs
  with
    tick zs (x:xs)	= tack (x:zs) (foldr f a xs&) if thunkp xs;
			= tick (x:zs) xs;
    tick zs []		= tack zs a;
    tick zs xs		= tack zs (foldr f a xs);
    tack (x:xs) y	= tack xs (f x y);
    tack [] y		= y;
  end;
  foldr (tick _) [] x	= cat x;
end;

/* Map a function to a list and concatenate the results. This is used by list
   comprehensions. */

catmap f []		= [];
catmap f xs@(_:_)	= cat (map f xs);

/* NOTE: This definition (from the Haskell prelude) is better, but doesn't
   preserve left-to-right execution order. */
//catmap f xs@(_:_)	= foldr ((+).f) [] xs;

/* Map a function to a list, like map, but first promote the argument to a
   list if possible. This is used by list comprehensions. */

listmap f []		= [];
listmap f xs@(_:_)	= map f xs;

/* Search an element in a list. Returns -1 if not found, index of first
   occurrence otherwise. */

index [] _		= -1;
index (x:xs) y		= search 0 (x:xs) with
  search _ []		= -1;
  search n::int (x:xs)	= n if x==?y;
			= search (n+1) xs;
  search _ xs		= index xs y;
end;

member [] y             = 0;
// member xs@(_:_) y    = index xs y+1;
// member xs@(_:_) y    = any (y==?) xs;
member (x:xs) y         = 1 if y==? x;
                        = member xs y;

/* Arithmetic sequences. */

public iterate iterwhile; // see below for these

n1:n2..m	= if nanp n1 || nanp m || double m===-s then []
		  else if double m===s then iterate (+k) n1
		  else iterwhile (p (m+0.5*k)) (+k) n1
		  when s,p = if k>0 then inf,(>=) else -inf,(<=) end
		  if realp k && k~=0 && ~infp n1 && ~infp n2
		  when k = n2-n1 end;
n..m		= if nanp n || nanp m || double m===-inf then []
		  else if double m===inf then iterate (+1) n
		  else iterwhile ((>=) m) (+1) n
		  if ~listp n && ~infp n;


/* ..

   List Generators
   ~~~~~~~~~~~~~~~

   Some useful (infinite) list generators, as well as some finite (and eager)
   variations of these. The latter work like a combination of :func:`take` or
   :func:`takewhile` and the former, but are implemented directly for better
   efficiency.

   .. function:: cycle xs

      cycles through the elements of the nonempty list ``xs``, ad infinitum

   .. function:: cyclen n xs

      eager version of :func:`cycle`, returns the first ``n`` elements of
      ``cycle xs``

   .. function:: iterate f x

      returns the stream containing ``x``, ``f x``, ``f (f x)``, etc.,
      ad infinitum

   .. function:: iteraten n f x

      eager version of :func:`iterate`, returns the first ``n`` elements of
      ``iterate f x``

   .. function:: iterwhile p f x

      another eager version of :func:`iterate`, returns the list of all
      elements from the front of ``iterate f x`` for which the predicate ``p``
      holds

   .. function:: repeat x

      returns an infinite stream of ``x``\ s

   .. function:: repeatn n x

      eager version of :func:`repeat`, returns a list with ``n`` ``x``\ s

*/

/* Some useful (infinite) list generators. */

iterate f x		= x : iterate f (f x)&;
repeat x		= x : repeat x&;
cycle ys@(x:xs)		= x : (xs+cycle ys)&;

/* Some finite (and strict) generators. These work like the a combination of
   takewhile/take and the above, but are implemented directly for maximum
   efficiency. */

iterwhile p f x		= accum [] p f x with
			    accum xs p f x = accum (x:xs) p f (f x) if p x;
				           = reverse xs otherwise;
			  end;

iteraten n::int f x	= [] if n<=0;
			= accum [] n f x
with
  accum xs n::int f x	= reverse (x:xs) if n==1;
			= accum (x:xs) (n-1) f (f x);
end;

repeatn n::int x	= accum [] n x with
  accum xs n::int x	= xs if n<=0;
			= accum (x:xs) (n-1) x;
end;

cyclen n::int (x:xs)	= [] if n<=0;
			= accum [] n with
			    accum ys n::int = cat ys+take n xs if n<=m;
			                    = accum (xs:ys) (n-m) otherwise;
			  end when xs = x:xs; m::int = #xs end if rlistp xs;

/* ..

   Zip and Friends
   ~~~~~~~~~~~~~~~

   .. function:: unzip xys

      takes a list of pairs to a pair of lists of corresponding elements

   .. function:: unzip3 xyzs

      :func:`unzip` with triples

   .. function:: zip xs ys

      return the list of corresponding pairs ``(x,y)`` where ``x`` runs
      through the elements of ``xs`` and ``y`` runs through the elements of
      ``ys``

   .. function:: zip3 xs ys zs

      :func:`zip` with three lists, returns a list of triples

   .. function:: zipwith f xs ys

      apply the binary function ``f`` to corresponding elements of ``xs``
      and ``ys``

   .. function:: zipwith3 f xs ys zs

      apply the ternary function ``f`` to corresponding elements of ``xs``,
      ``ys`` and ``zs``

   Pure also has the following variations of :func:`zipwith` and
   :func:`zipwith3` which throw away all intermediate results and return the
   empty tuple ``()``. That is, these work like :func:`do` but pull arguments
   from two or three lists, respectively:

   .. function:: dowith f xs ys

      apply the binary function ``f`` to corresponding elements of ``xs``
      and ``ys``, return ``()``

   .. function:: dowith3 f xs ys zs

      apply the ternary function ``f`` to corresponding elements of ``xs``,
      ``ys`` and ``zs``, return ``()``

*/

zip [] _		|
zip _ []		= [];
zip xs@(_:_) ys@(_:_)	= tick [] xs ys
with
  tick us (x:xs) (y:ys)	= tack ((x,y):us) (zip xs ys&)
			    if thunkp xs || thunkp ys;
			= tick ((x,y):us) xs ys;
  tick us [] _		|
  tick us _ []		= tack us [];
  tick us xs ys		= tack us (zip xs ys);
  tack (u:us) vs	= tack us (u:vs);
  tack [] vs		= vs;
end;

zip3 [] _ _		|
zip3 _ [] _		|
zip3 _ _ []		= [];
zip3 xs@(_:_) ys@(_:_) zs@(_:_)
			= tick [] xs ys zs
with
  tick us (x:xs) (y:ys) (z:zs)
			= tack ((x,y,z):us) (zip3 xs ys zs&)
			    if thunkp xs || thunkp ys || thunkp zs;
			= tick ((x,y,z):us) xs ys zs;
  tick us [] _ _	|
  tick us _ [] _	|
  tick us _ _ []	= tack us [];
  tick us xs ys zs	= tack us (zip3 xs ys zs);
  tack (u:us) vs	= tack us (u:vs);
  tack [] vs		= vs;
end;

zipwith f [] _		|
zipwith f _ []		= [];
zipwith f xs@(_:_) ys@(_:_)
			= tick [] xs ys
with
  tick us (x:xs) (y:ys)	= tack (f x y:us) (zipwith f xs ys&)
			    if thunkp xs || thunkp ys;
			= tick (f x y:us) xs ys;
  tick us [] _		|
  tick us _ []		= tack us [];
  tick us xs ys		= tack us (zipwith f xs ys);
  tack (u:us) vs	= tack us (u:vs);
  tack [] vs		= vs;
end;

zipwith3 f [] _ _		|
zipwith3 f _ [] _		|
zipwith3 f _ _ []		= [];
zipwith3 f xs@(_:_) ys@(_:_) zs@(_:_)
			= tick [] xs ys zs
with
  tick us (x:xs) (y:ys) (z:zs)
			= tack (f x y z:us) (zipwith3 f xs ys zs&)
			    if thunkp xs || thunkp ys || thunkp zs;
			= tick (f x y z:us) xs ys zs;
  tick us [] _ _	|
  tick us _ [] _	|
  tick us _ _ []	= tack us [];
  tick us xs ys zs	= tack us (zipwith3 f xs ys zs);
  tack (u:us) vs	= tack us (u:vs);
  tack [] vs		= vs;
end;

dowith f (x:xs) (y:ys)	= f x y $$ dowith f xs ys;
dowith f _ _		= () otherwise;

dowith3 f (x:xs) (y:ys) (z:zs)
			= f x y z $$ dowith3 f xs ys zs;
dowith3 f _ _ _		= () otherwise;

unzip []		= [],[];
unzip us@(_:_)		= foldr accum ([],[]) us
with
  accum u@(x,y) us	= x:(xs when xs,_ = check us end)&,
			  y:(ys when _,ys = check us end)& if thunkp us;
			= x:xs,y:ys when xs,ys = check us end;
  accum u _		= throw (bad_tuple_value u);
  check us@(_,_)	= us;
  check (foldr _ _ us)	= throw (bad_list_value us);
  check us		= throw (bad_tuple_value us);
end;

unzip3 []		= [],[],[];
unzip3 us@(_:_)		= foldr accum ([],[],[]) us
with
  accum u@(x,y,z) us	= x:(xs when xs,_,_ = check us end)&,
			  y:(ys when _,ys,_ = check us end)&,
			  z:(zs when _,_,zs = check us end)& if thunkp us;
			= x:xs,y:ys,z:zs when xs,ys,zs = check us end;
  accum u _		= throw (bad_tuple_value u);
  check us@(_,_,_)	= us;
  check (foldr _ _ us)	= throw (bad_list_value us);
  check us		= throw (bad_tuple_value us);
end;
