
/* Pure's standard prelude. */

/* Copyright (c) 2008-2012 by Albert Graef <Dr.Graef@t-online.de>.

   This file is part of the Pure standard library.

   The Pure standard library is free software: you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
   more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* .. We use docutils to produce the documentation. Docstrings are extracted
   .. with pure-doc. Please see the pure-doc documentation for details.

   .. This module is always the first in the library docs, so produce the
   .. title here.

   ===================
   Pure Library Manual
   ===================

   .. role:: dfn(strong)
   .. default-role:: dfn
   .. default-domain:: pure

   .. |GPL| replace:: GNU General Public License
   .. |FDL| replace:: GNU Free Documentation License
   .. _FDL: http://www.gnu.org/copyleft/fdl.html
   .. _GPL: http://www.gnu.org/copyleft/gpl.html

   Version @version@, |today|

   Albert Gräf <Dr.Graef@t-online.de>

   Copyright (c) 2009-2012 by Albert Gräf. This document is available under
   the |FDL|_.

   This manual describes the operations in the standard Pure library,
   including the prelude and the other library modules which come bundled with
   the interpreter.

   There is a companion to this manual, :doc:`pure` which describes the Pure
   language and the operation of the Pure interpreter.

   .. Table of contents, switch on section numbering.

   .. contents::
   .. sectnum::

   .. _Prelude:

   Prelude
   =======

   The prelude defines the basic operations of the Pure language. This
   includes the basic arithmetic and logical operations, string, list and
   matrix functions, as well as the support operations required to implement
   list and matrix comprehensions. The list, string, matrix and record
   operations are in separate modules lists.pure, strings.pure, matrices.pure
   and records.pure, the primitive arithmetic and logical operations can be
   found in primitives.pure. Note that since the prelude module gets imported
   automatically (unless the interpreter is invoked with the ``--no-prelude``
   option), all operations discussed in this section are normally available in
   Pure programs without requiring any explicit import declarations, unless
   explicitly noted otherwise.

   Constants and Operators
   -----------------------

   The prelude also declares a signature of commonly used constant and
   operator symbols. This includes the truth values ``true`` and ``false``.

   .. constant:: true = 1
      		 false = 0

      These are actually just integers in Pure, but sometimes it's convenient
      to refer to them using these symbolic constants. Note that if you also
      want to use these on the left-hand side of equations, you still have to
      declare them as ``nonfix`` symbols yourself, using a declaration like::

        nonfix false true;

   In addition, the following special exception symbols are provided:

   .. constructor:: failed_cond
                    failed_match
                    stack_fault
                    malloc_error

      These are the built-in exception values. ``failed_cond`` denotes a
      failed conditional in guard or if-then-else; ``failed_match`` signals a
      failed pattern match in lambda, ``case`` expression, etc.;
      ``stack_fault`` means not enough stack space (``PURE_STACK`` limit
      exceeded); and ``malloc_error`` indicates a memory allocation error.

   .. constructor:: bad_list_value x
                    bad_tuple_value x
                    bad_string_value x
                    bad_matrix_value x

      These denote value mismatches a.k.a. dynamic typing errors. They are
      thrown by some operations when they fail to find an expected value of
      the corresponding type.

   .. constructor:: out_of_bounds

      This exception is thrown by the index operator ``!`` if a list, tuple or
      matrix index is out of bounds.

*/

nonfix failed_cond failed_match stack_fault out_of_bounds malloc_error;
public bad_matrix_value bad_list_value bad_tuple_value bad_string_value;

/* .. index:: operators
   .. _operators:

   Here's the list of predefined operator symbols. Note that the parser will
   automagically give unary minus the same precedence level as the
   corresponding binary operator. */

// >>>

infixl  1000   $$ ;                // sequence operator
infixr  1100   $ ;                 // right-associative application
infixr  1200   , ;                 // pair (tuple)
infix   1300   => ;                // key=>value pairs ("hash rocket")
infix   1400   .. ;                // arithmetic sequences
infixr  1500   || ;                // logical or (short-circuit)
infixr  1600   && ;                // logical and (short-circuit)
prefix  1700   ~ ;                 // logical negation
infix   1800   < > <= >= == ~= ;   // relations
infix   1800   === ~== ==? ~=? ;   // fine- and coarse-grained equality
infixr  1900   : ;                 // list cons
infix   2000   +: <: ;             // complex numbers (cf. math.pure)
infixl  2100   << >> ;             // bit shifts
infixl  2200   + - or ;            // addition, bitwise or
infixl  2300   * / div mod and ;   // multiplication, bitwise and
infixl  2300   % ;                 // exact division (cf. math.pure)
prefix  2400   not ;               // bitwise not
infixr  2500   ^ ;                 // exponentiation
prefix  2600   # ;                 // size operator
infixl  2700   ! !! ;              // indexing, slicing
infixr  2800   . ;                 // function composition
prefix  2900   ' ;                 // quote
postfix 3000   & ;                 // thunk

// <<<

// Additional operators used to encode quoted specials.
infix  0       --> ;
infixl 0       __if__ __when__ __with__;
infixl 10000   __as__ __type__ ;

const false, true = 0, 1;

/* Synonym for the slicing operator. This must be defined here, before pulling
   in any of the prelude modules which define optimization rules for (!!). */
slice x y = x!!y;

// Disabling this option (--disable all-opt) will disable *all* special
// compile-time optimization rules in the prelude. This isn't recommended.

#! --ifnot all-opt
#!   --disable common-opt
#!   --disable subseq-opt
#!   --disable vectorseq-opt
#!   --disable list-opt
#! --endif // not opt

// We default to using the reverse-based list algorithms, rather than
// the skip-ahead optimizations.

#! --ifndef list-opt
#! --disable list-opt
#! --endif

// We default to using avltrees rather than trees23.

#! --ifndef trees23
#! --disable trees23
#! --endif


/* Pull in the primitives (arithmetic etc.) and the standard string, list,
   matrix and record functions. Note that the math, pointers and system modules
   are *not* included here, so you have to do that yourself if your program
   requires any of those operations. */

using primitives, matrices, records, strings;

/* .. _Prelude Types:

   Prelude Types
   -------------

   Some additional type symbols are provided which can be used as type tags on
   the left-hand side of equations, see :ref:`Type Tags` in the Pure Manual.

   .. type:: number /type
             complex /type
             real /type
             rational /type
             integer /type

      Additional number types.

   These types are defined in a purely syntactic way, by checking the
   builtin-type or the constructor symbol of a number. Some semantic number
   types can be found in the :mod:`math` module, see `Semantic Number
   Predicates and Types`_.

   :type:`integer/type` is the union of Pure's built-in integer types, i.e.,
   it comprises all :type:`int/type` and :type:`bigint/type`
   values. :type:`rational/type` and :type:`complex/type` are the rational and
   complex types, while :type:`real/type` is the union of the
   :type:`double/type`, :type:`integer/type` and :type:`rational/type` types
   (i.e., anything that can represent a real number and be used for the real
   and imaginary parts of a :type:`complex/type` number). Finally,
   :type:`number/type` is the union of all numeric types, i.e., this type can
   be used to match any kind of number.

   Note that the operations of the :type:`rational/type` and
   :type:`complex/type` types are actually defined in the :mod:`math` module
   which isn't part of the prelude, so you have to import this module in order
   to do computations with these types of values. However, the type tags and
   constructors for these types are defined in the prelude so that these kinds
   of values can be parsed and recognized without having the :mod:`math`
   module loaded.

   The prelude also provides a subtype of the built-in :type:`string/type`
   type which represents single-character strings:

   .. type:: char /type

      A single character string. This matches any string value of length 1.

   `Lists and tuples`_ can be matched with the following types:

   .. type:: list /type
             rlist /type

      The list and "proper" (or "recursive") list types. Note that the former
      comprises both the empty list ``[]`` and all list nodes of the form
      ``x:xs`` (no matter whether the tail ``xs`` is a proper list value or
      not), whereas the latter only matches proper list values of the form
      ``x1:...:xn:[]``. Thus the :type:`list/type` type can be checked in O(1)
      time, while the :type:`rlist/type` type is defined recursively and
      requires linear time (with respect to the size of the list) to be
      checked. This should be considered when deciding whether to use one or
      the other in a given situation; see :ref:`Type Rules` for further
      explanation.

   .. type:: tuple /type

      The type of all tuples, comprises the empty tuple ``()`` and all tuples
      ``(x,xs)`` with at least two members. This is analogous to the
      :type:`list/type` type above, but no "proper" tuple type is needed here
      since any tuple of this form is always a proper tuple.

   There are some other, more specialized types representing various kinds of
   applications, function objects and other named entities. These are useful,
   in particular, for the definition of higher-order functions and for
   performing symbolic manipulations on unevaluated symbolic terms.

   .. type:: appl /type

      This type represents all unevaluated function or constructor
      applications of the form ``x y``. This comprises constructor terms and
      quoted or partial function applications.

   .. type:: function /type

      This type represents any term which may be called as a function. This
      may be a closure (global or local function, or a lambda function) which
      takes at least one argument, or a partial application of a closure to
      some arguments which is still "unsaturated", i.e., expects some further
      arguments to be "ready to go".

   .. type:: fun /type

      A named function object (global or local function, but not a partial
      application).

   .. type:: lambda /type

      An anonymous (lambda) function.

   .. type:: closure /type

      Any kind of function object (named function or lambda). This is the
      union of the :type:`fun/type` and :type:`lambda/type` types.

   .. type:: thunk /type

      This is a special kind of unevaluated parameterless function object used
      in lazy evaluation. See :ref:`Lazy Evaluation and Streams` in the Pure
      Manual.

   .. type:: var /type

      A free variable. This can be any kind of symbol that could in principle
      be bound to a value (excluding operator and nonfix symbols).

   .. type:: symbol /type

      Any kind of symbol (this also includes operator and nonfix symbols).

   Corresponding type predicates are provided for all of the above, see
   Predicates_. Some further types and predicates for matrices and records can
   be found under `Matrix Inspection and Manipulation`_ and `Record
   Functions`_.

   Basic Combinators
   -----------------

   .. index:: combinators

   The prelude implements the following important function combinators.

   .. function:: infix $ f g
      		 infix . f g

      Like in Haskell, these denote right-associative application and function
      composition. They are also defined as macros so that saturated calls of
      them are eliminated automatically. Examples::

        > foo $ bar 99;
     	foo (bar 99)
     	> (foo.bar) 99;
     	foo (bar 99)

   .. function:: id x
      		 cst x y

      These are the customary identity and constant combinators from the
      combinatorial calculus::

        > map id (1..5);
     	[1,2,3,4,5]
     	> map (cst 0) (1..5);
     	[0,0,0,0,0]

   .. function:: void x

      This combinator is basically equivalent to ``cst ()``, but with the
      special twist that it is also defined as a macro optimizing the case of
      "throwaway" list and matrix comprehensions. This is useful if a
      comprehension is evaluated solely for its side effects. E.g.::

        > using system;
     	> extern int rand();
     	> foo = void [printf "%d\n" rand | _ = 1..3];
     	> show foo
     	foo = do (\_ -> printf "%d\n" rand) (1..3);
     	> foo;
     	1714636915
     	1957747793
     	424238335
     	()

      Note that the above list comprehension is actually implemented using
      :func:`do` (instead of :func:`map`, which would normally be the case),
      so that the intermediate list value of the comprehension is never
      constructed. This is described in more detail in section
      :ref:`Optimization Rules` of the Pure Manual.

*/

f $ x		= f x;
(f . g) x	= f (g x);

void _		= ();
id x		= x;
cst x y		= x;

/* ..

   In addition, the prelude also provides the following combinators adopted
   from Haskell:

   .. function:: flip f

      Swaps arguments of a binary function ``f``, e.g.::

        > map (flip (/) 2) (1..3);
       	[0.5,1.0,1.5]

      This combinator is also used by the compiler to implement right operator
      sections, which allows you to write the above simply as::

        > map (/2) (1..3);
        [0.5,1.0,1.5]

   .. function:: curry f

      Turns a function ``f`` expecting a pair of values into a curried
      function of two arguments::

        > using system;
        > dowith (curry (printf "%d: %g\n")) (0..2) [0.0,2.718,3.14];
        0: 0
        1: 2.718
        2: 3.14
        ()

   .. function:: uncurry f

      The inverse of :func:`curry`. Turns a curried function ``f`` expecting
      two arguments into a function processing a single pair argument::

        > map (uncurry (*)) [(2,3),(4,5),(6,7)];
        [6,20,42]

   .. function:: curry3 f
      		 uncurry3 f

      These work analogously, but are used to convert between ternary curried
      functions and functions operating on triples.

*/

flip f x y	= f y x;
curry f x y	= f (x,y);
curry3 f x y z	= f (x,y,z);
uncurry f (x,y)	= f x y;
uncurry3 f (x,y,z)
		= f x y z;

/* .. function:: fix f

      This is the (normal order) fixed point combinator which allows you to
      create recursive anonymous functions. It takes another function ``f`` as
      its argument and applies ``f`` to ``fix f`` itself::

        > let fact = fix (\f n -> if n<=0 then 1 else n*f (n-1));
        > map fact (1..5);
        [1,2,6,24,120]

      See |fixpoint|_ at Wikipedia for an explanation of how this magic works.
      Just like in Haskell, :func:`fix` can be used to produce least fixed
      points of arbitrary functions. For instance::

        > fix (cst bar);
        bar
        > let xs = fix (1:);
        > xs;
        1:#<thunk 0x7fe537fe2f90>
        > xs!!(0..10);
        [1,1,1,1,1,1,1,1,1,1,1]

   .. |fixpoint| replace:: Fixed point combinator
   .. _fixpoint: http://en.wikipedia.org/wiki/Fixed_point_combinator

*/

fix f = f (fix f&);

/* Some convenient optimization rules which eliminate saturated calls of the
   function composition combinators. */

#! --if common-opt
def f $ x	= f x;
def (f . g) x	= f (g x);
#! --endif

/* Simplify calls to 'void'. These are also useful in conjunction with the
   optimization rules for "throwaway" list comprehensions (see below). */

#! --if common-opt
def void () | void [] | void {} = ();
def void [x] | void {x} = void x;
#! --endif

/* ..

   Lists and Tuples
   ----------------

   .. index:: lists
   .. index:: tuples

   The prelude defines the list and tuple constructors, as well as equality
   and inequality on these structures. It also provides a number of other
   useful basic operations on lists and tuples. These are all described below.

   .. constructor:: []
		    ()

      Empty list and tuple.

   .. constructor:: infix : x y
                    infix , x y

      List and tuple constructors. These are right-associative in Pure.

   Lists are the usual right-recursive aggregates of the form ``x:xs``, where
   ``x`` denotes the `head` and ``xs`` the `tail` of the list, pretty much the
   same as in Lisp or Prolog except that they use a Haskell-like syntax. In
   contrast to Haskell, list concatenation is denoted '\ :func:`+/list`\ '
   (see below), and lists may contain an arbitrary mixture of arguments, i.e.,
   they are fully polymorphic::

     > 1:2:3:[];
     [1,2,3]
     > [1,2,3]+[u,v,w]+[3.14];
     [1,2,3,u,v,w,3.14]

   Lists are `eager` in Pure by default, but they can also be made `lazy` (in
   the latter case they are also called `streams`). This is accomplished by
   turning the tail of a list into a "thunk" (a.k.a. "future") which defers
   evaluation until the list tail is actually needed, see section :ref:`Lazy
   Evaluation and Streams` in the Pure Manual. For instance, an infinite
   arithmetic sequence (see below) will always produce a list with a thunked
   tail::

     > 1:3..inf;
     1:#<thunk 0x7f696cd2dbd8>

   Pure also distinguishes `proper` and `improper` lists. The former are
   always terminated by an empty list in the final tail and can thus be
   written using the conventional ``[x1,x2,...,xn]`` syntax::

     > 1:2:3:[];
     [1,2,3]

   In contrast, improper lists are terminated with a non-list value and
   can only be represented using the '\ :func:`:`\ ' operator::

     > 1:2:3;
     1:2:3

   These aren't of much use as ordinary list values, but are frequently
   encountered as patterns on the left-hand side of an equation, where the
   final tail is usually a variable. Also note that technically, a lazy list
   is also an improper list (although it may expand to a proper list value as
   it is traversed).

   Tuples work in a similar fashion, but with the special twist that the
   pairing constructor '\ :cons:`,`\ ' is associative (it always produces
   right-recursive pairs) and '\ :cons:`()`\ ' acts as a neutral element on
   these constructs, so that '\ :cons:`,`\ ' and '\ :cons:`()`\ ' define a
   complete monoid structure. Note that this means that '\ :cons:`,`\ ' is
   actually a "constructor with equations" since it obeys the laws
   ``(x,y),z == x,(y,z)`` and ``(),x == x,() == x``. Also note that there
   isn't a separate operation for concatenating tuples, since the pairing
   operator already does this::

     > (1,2,3),(10,9,8);
     1,2,3,10,9,8
     > (),(a,b,c);
     a,b,c
     > (a,b,c),();
     a,b,c

   This also implies that tuples are always flat in Pure and can't be
   nested; if you need this, you should use lists instead.

   Also, tuples are always `eager` in Pure. Adding a thunk to a tuple will
   force it.

   Some important basic operations on lists and tuples are listed below.

   .. index:: list; concatenation

   .. function:: infix + /list x y

      List concatenation. This non-destructively appends the elements of ``y``
      to ``x``. ::

        > [1,2,3]+[u,v,w];
        [1,2,3,u,v,w]

      Note that this operation in fact just recurses into ``x`` and replaces
      the empty list marking the "end" of ``x`` with ``y``, as if defined by
      the following equations (however, the prelude actually defines this
      operation in a tail-recursive fashion)::

        [] + ys = ys;
	(x:xs) + ys = x : xs+ys;

      To make this work, both operands should be proper lists, otherwise you
      may get somewhat surprising (but correct) improper list results like the
      following::

        > [1,2,3]+99;
	1:2:3:99
	> (1:2:3)+33;
	1:2:36

      This happens because Pure is dynamically typed and places no limits on
      ad hoc polymorphism. Note that the latter result is due to the fact
      that '\ :func:`+`\ ' also denotes the addition of numbers, and the
      improper tail of the first operand is a number in this case, as is the
      second operand. Otherwise you might have got an unreduced instance of
      the '\ :func:`+`\ ' operator instead.

   .. index:: list; equality
   .. index:: tuple; equality

   .. function:: infix == /list x y
		 infix ~= /list x y

      Equality and inequality of lists and tuples. These compare two lists or
      tuples by recursively comparing their members, so '\ :func:`==`\ ' must
      be defined on the list or tuple members if you want to use these
      operations. ::

        > reverse [a,b,c] == [c,b,a];
	1
	> (a,b,c) == ();
	0

      '\ :func: `==?`\ ' is another alternative, that checks whether the
      members of the tuples are '\ :func:`==`\ ', or when that's not
      defined, whether they are '\ :func:`===`\ '.

      Note that applying these operations to two infinite lists
      may take an infinite amount of time.

   .. index:: list; size
   .. index:: tuple; size

   .. function:: prefix # x

      List and tuple size. This operation counts the number of elements in a
      list or tuple::

        > #[a,b,c];
	3
        > #(a,b,c);
	3

      Please note that for obvious reasons this operation is inherently eager,
      so trying to compute the size of an infinite list will take forever.

   .. index:: list; indexing
   .. index:: tuple; indexing

   .. function:: infix ! x i

      Indexing of lists and tuples is always zero-based (i.e., indices run
      from ``0`` to ``#x-1``), and an exception will be raised if the index is
      out of bounds::

        > [1,2,3]!2;
        3
	> [1,2,3]!4;
        <stdin>, line 34: unhandled exception 'out_of_bounds' while evaluating
	'[1,2,3]!4'

   .. index:: list; slicing
   .. index:: tuple; slicing

   .. function:: infix !! x is

      The slicing operation takes a list or tuple and a list of indices and
      returns the list or tuple of the corresponding elements, respectively.
      Indices which are out of the valid range are silently ignored::

        > (1..5)!!(3..10);
	[4,5]
     	> (1,2,3,4,5)!!(3..10);
     	4,5

      The case of contiguous index ranges, as shown above, is optimized so
      that it always works in linear time, see Slicing_ below for details. But
      indices can actually be specified in any order, so that you can retrieve
      any permutation of the members, also with duplicates. E.g.::

        > (1..5)!![2,4,4,1];
     	[3,5,5,2]

      This is less efficient than the case of contiguous index ranges, because
      it requires repeated traversals of the list for each index. For larger
      lists you should hence use vectors or matrices instead, to avoid the
      quadratic complexity.

   .. index:: list; arithmetic sequence

   .. function:: infix .. x y

      Arithmetic sequences. Note that the Pure syntax differs from Haskell in
      that there are no brackets around the construct and a step width is
      indicated by specifying the first two elements as ``x:y`` instead of
      ``x,y``. ::

        > 1..5;
	[1,2,3,4,5]
	> 1:3..11;
	[1,3,5,7,9,11]

      To prevent unwanted artifacts due to rounding errors, the upper bound in
      a floating point sequence is always rounded to the nearest grid point::

        > 0.0:0.1..0.29;
	[0.0,0.1,0.2,0.3]
	> 0.0:0.1..0.31;
	[0.0,0.1,0.2,0.3]

      Last but not least, you can specify infinite sequences with an infinite
      upper bound (``inf`` or ``-inf``)::

        > 1:3..inf;
	1:#<thunk 0x7f696cd2dbd8>
	> -1:-3..-inf;
	-1:#<thunk 0x7f696cd2fde8>

      The lower bounds of an arithmetic sequence must always be finite.

   .. function:: null x

      Test for the empty list and tuple. ::

        > null [];
	1
	> null (a,b,c);
	0

   .. function:: reverse x

      Reverse a list or tuple. ::

        > reverse (1..5);
	[5,4,3,2,1]
	> reverse (a,b,c);
	(c,b,a)

   .. function:: reverse_onto base x

      Reverse a list onto a specified base. ::

        > reverse_onto [20,10] (3..5);
        [5, 4, 3, 20, 10]

      Note: This operation and '\ :func:`reverse`\ ' are both inherently eager.

   Conversions
   -----------

   The prelude provides the following conversion operations between lists,
   tuples, and streams.

   .. function:: list x
                 tuple x

      Convert between (finite) lists and tuples. ::

        > tuple (1..5);
     	1,2,3,4,5
     	> list (a,b,c);
     	[a,b,c]

      The ``list`` function can be used to turn a finite lazy list into an
      eager one::

        > list $ take 10 (-1:-3..-inf);
     	[-1,-3,-5,-7,-9,-11,-13,-15,-17,-19]

      You can also achieve the same effect somewhat more conveniently by
      slicing a finite part from a stream::

        > (-1:-3..-inf)!!(0..9);
     	[-1,-3,-5,-7,-9,-11,-13,-15,-17,-19]

   Conversely, it is also possible to convert an (eager) list to a lazy one (a
   stream).

   .. function:: stream x

      Convert a list to a stream. ::

        > stream (1..10);
     	1:#<thunk 0x7fe537fe2b58>

   This might appear a bit useless at first sight, since all elements of the
   stream are in fact already known. However, this operation then allows you
   to apply other functions to the list and have them evaluated in a lazy
   fashion.

   The following gives a different way to build streams from lists.

   .. function:: catstream xs

   It lazily concatenates a list of lists or streams. Note that if all the
   arguments are already streams, then '\ :func:`cat`\ ' gives the same result.
   However, '\ :func:`cat`\ ' handles any list elements eagerly; whereas
   '\ :func:`catstream`\ ' treats everything lazily. It is equivalent to
   ``cat.(map stream)``, but more efficient.

   There is some small overhead that makes '\ :func:`catstream`\ ' an inappropriate
   general replacement for '\ :func:`cat`\ ' or '\ :func:`+`\ ': catstreaming two
   lists and then converting the resulting stream back to a list using the
   '\ :func:`list`\ ' function, above, takes about 3-4x as long as using
   '\ :func:`+`\ ' on those lists in the first place. However, catstreaming two
   lists and then iterating through them (for example, with
   '\ :func:`last`\ ') takes about the same time as if you had used
   '\ :func:`+`\ ' and iterated on the result. For such purposes, and
   especially if you're likely not to need to iterate past the first list,
   '\ :func:`catstream`\ ' may be a good alternative to '\ :func:`cat`\ ' or
   '\ :func:`+`\ '.

   Slicing
   -------

   Indexing and slicing are actually fairly general operations in Pure which
   are used not only in the context of lists and tuples, but for any type of
   container data structure which can be "indexed" in some way. Other examples
   in the standard library are the :mod:`array` and :mod:`dict` containers.

   The prelude therefore implements slicing in a generic way, so that it works
   with any kind of container data structure which defines '\ :func:`\!`\ ' in
   such a manner that it throws an exception when the index is out of bounds.
   It also works with any kind of index container that implements the
   :func:`catmap` operation.

   The prelude also optimizes the case of contiguous integer ranges so that
   slices like ``xs!!(i..j)`` are computed in linear time if possible.  This
   works, in particular, with lists, strings and matrices.

   Moreover, the prelude includes some optimization rules and corresponding
   helper functions to optimize the most common cases at compile time, so that
   the index range is never actually constructed. To these ends, the slicing
   expression ``xs!!(i..j)`` is translated to a call ``subseq xs i j`` of the
   special :func:`subseq` function:

   .. function:: subseq x i j

      If ``x`` is a list, matrix or string, and ``i`` and ``j`` are int
      values, compute the slice ``xs!!(i..j)`` in the most efficient manner
      possible. This generally avoids constructing the index list ``i..j``.
      Otherwise ``i..j`` is computed and :func:`subseq` falls back to the
      :func:`slice` function below to compute the slice in the usual way.

   .. function:: slice x ys

      Compute the slice ``x!!ys`` using the standard slicing operation,
      without any special compile time tricks. (Runtime optimizations are
      still applied if possible.)

   You can readily see the effects of this optimization by running the slicing
   operator against :func:`slice`::

     > let xs = 1..1000000;
     > stats -m
     > #slice xs (100000..299990);
     199991
     0.34s, 999957 cells
     > #xs!!(100000..299990);
     199991
     0.14s, 399984 cells

   Even more drastic improvements in both running time and memory usage can be
   seen in the case of matrix slices::

     > let x = rowvector xs;
     > #slice x (100000..299990);
     199991
     0.19s, 599990 cells
     > #x!!(100000..299990);
     199991
     0s, 10 cells

   Hash Pairs
   ----------

   .. index:: hash pair, hash rocket

   The prelude provides another special kind of pairs called "hash pairs",
   which take the form ``key=>value``. These are used in various contexts to
   denote key-value associations. The only operations on hash pairs provided
   by the prelude are equality testing (which recursively compares the
   components) and the functions :func:`key` and :func:`val`:

   .. constructor:: infix => x y

      The hash pair constructor, also known as the "hash rocket".

   .. function:: infix == /hashpair x y
      		 infix ~= /hashpair x y

      Equality and inequality of hash pairs. ::

        > ("foo"=>99) == ("bar"=>99);
     	0

   .. function:: key (x=>y)
                 val (x=>y)

      Extract the components of a hash pair. ::

     	> key ("foo"=>99), val ("foo"=>99);
     	"foo",99

   Note that in difference to the tuple operator '\ :cons:`,`\ ', the hash
   rocket '\ :cons:`=>`\ ' is non-associative, so nested applications *must*
   be parenthesized, and ``(x=>y)=>z`` is generally *not* the same as
   ``x=>(y=>z)``. Also note that '\ :cons:`,`\ ' has lower precedence than
   '\ :cons:`=>`\ ', so to include a tuple as key or value in a hash pair, the
   tuple must be parenthesized, as in ``"foo"=>(1,2)`` (whereas ``"foo"=>1,2``
   denotes a tuple whose first element happens to be a hash pair).

*/

/* The hash rocket. This constructor is declared here so that it can be used
   in other standard library modules to denote special kinds of pairs which
   map keys to values. Here we only define equality of such pairs, as well as
   the key and val operations for extracting the components of a hash pair. */

(x=>v)==(y=>w)	= x==y && v==w;
(x=>v)~=(y=>w)	= x~=y || v~=w;

key (x=>v)	= x;
val (x=>v)	= v;

/* Poor man's tuples(TM). These are constructed with the pairing operator ',',
   are always flat and associate to the right. The empty tuple, denoted (), is
   neutral with respect to ','. Operations are provided to test for equality/
   inequality and emptiness, to determine the size of a tuple, for zero-based
   indexing and slicing, and to reverse a tuple. */

// Curried nonsplicing constructors, currently undocumented.
tuple2 x y      = 'comma x y when comma = (,) end;
tuple3 x y z    = 'comma x (comma y z) when comma = (,) end;

x,y                 = flatten x y with
    flatten () (x,y) |
    flatten (x,y) () = flatten x y;
    flatten ()    x  |
    flatten x     () = x;
    flatten (x,y) z  = flatten x (flatten y z);
    flatten x  (y,z) = tuple2 x (flatten y z);
    flatten x     z  = tuple2 x z;
end;

()==()		= 1;
(x,xs)==(y,ys)	= x==y && xs==ys;
(x,xs)==_	|
()==_		|
_==(x,xs)	|
_==()		= 0;

()~=()		= 0;
(x,xs)~=(y,ys)	= x~=y || xs~=ys;
(x,xs)~=_	|
()~=_		|
_~=(x,xs)	|
_~=()		= 1;

null ()		= 1;
null (x,xs)	= 0;

#()		= 0;
#(x,xs)		= accum 1 xs with
  accum n::int (x,xs)	= accum (n+1) xs;
  accum n::int x	= n+1;
end;

(x,xs)!n::int	= throw out_of_bounds if n<0;
(x,xs)!0	= x;
(x,y,xs)!n::int	= (y,xs)!(n-1);
(x,y)!1		= y;
(x,y)!n::int	|
()!n::int	= throw out_of_bounds;

xs@()!!ns	|
xs@(_,_)!!ns	= tuple (list xs!!ns);

reverse ()	= ();
reverse (x,xs)	= accum x xs with
  accum ys (x,xs)	= accum (x,ys) xs;
  accum ys x		= x,ys;
end;


/* Lists are the usual "conses" written using the infix ':' operator. '[]'
   denotes the empty list. Moreover, the parser provides the customary sugar
   for proper list values [x] where x is any singleton or tuple (in the latter
   case you'll get a list made from all the elements of x). The usual basic
   operations are provided to test for equality/inequality and emptiness, to
   compute the size of a list, for indexing, slicing and concatenation, and
   for reversing a list. */

[]==[]		= 1;
(x:xs)==[]	= 0;
[]==(x:xs)	= 0;
(x:xs)==(y:ys)	= x==y && xs==ys;

[]~=[]		= 0;
(x:xs)~=[]	= 1;
[]~=(x:xs)	= 1;
(x:xs)~=(y:ys)	= x~=y || xs~=ys;

null []		= 1;
null (x:xs)	= 0;

#[]		= 0;
#(x:xs)		= accum 1 xs with
  accum n::int (x:xs)	= accum (n+1) xs;
  accum n::int []	= n;
  accum	n::int xs	= n+#xs;
end;

[]!n::int	= throw out_of_bounds;
(x:xs)!0	= x;
(x:xs)!n::int	= xs!(n-1) if n>0;
		= throw out_of_bounds otherwise;

// Curried constructor, currently undocumented.
list1 x         = [x];

using lists;


/* Slicing. xs!!ns returns the list of xs!n for all members n of the index
   list ns which are in the valid index range. This is a generic fallback
   definition which works with any kind of container data structure which
   defines (!) in such a manner that it throws an exception when the index is
   out of bounds. It also works with any kind of index container that
   implements the catmap operation. Moreover, the special case of finite
   contiguous list slices is optimized using 'take' and 'drop' so that it
   works in linear time. */

xs!!ns		= ys if ok ys when
		    ys = case ns of
		           ns@(n::int:_) = list $ take (count ns) (drop n xs)
		                             if listp xs && cont ns;
		           _ = catmap (nth xs) ns;
		         end;
		  end with
		    ok (catmap (nth _) _) = 0;
		    ok _ = 1;
		    nth xs n = catch (cst []) [xs!n];
		    count ns = #dropwhile (\n::int->n<0) ns;
		    cont (n::int:ns) = ~thunkp ns &&
		    (case ns of
		       [] = 1;
		       m::int:_ = cont ns if m==n+1;
		       _ = 0 otherwise;
		     end);
		  end;

/* Compile time optimization of contiguous slices. This optimizes the common
   case of a slice x!!(a::int..b::int). The rules below handle the list case,
   and the generic case in which we fall back to the standard slicing
   operation above. Other specialized optimization rules can be found in the
   matrices and strings modules. NOTE: You can run the interpreter with the
   `--disable subseq-opt` option if you need to disable these optimizations for
   some reason.

   Note also that this function will force any stream as far as needed to
   return a list result. `take` on the other hand doesn't force its argument
   past its first element; so you can get a lazy version of `subseq` using
   a combination of `drop` and `take`. */

subseq [] a::int b::int = [];

#! --ifnot list-opt
// reverse-based
subseq xs@(_:_) a::int b::int = take (b-a+1) $ drop a xs with
  // This is a version of take modified to expand thunked tails. It uses the
  // same basic logic to make it tail-recursive.
  take n::int []	= [];
  take n::int xs@(_:_)	= tick n [] xs;
  tick n::int zs xs	= reverse_onto [] zs if n<=0;
			= case xs of
			    []   = reverse_onto [] zs;
			    x:xs = tick (n-1) (x:zs) xs;
			    _    = reverse_onto (take n xs) zs;
			  end;
end;

#! --else
// skip-ahead
subseq xs@(_:_) a::int b::int = take (b-a+1) $ drop a xs with
    take 0 xs = [];
    take m::int xs = take_pre len_pre xs with
        take_pre 0      _             = front_tail;
        take_pre n::int (x:xs)        = x:take_pre (n-1) xs;
    end when
        len_pre@_ front_tail          = skip_ahead m 0 xs;
    end;
    skip_ahead m::int n::int xs       = n [] if m <= 0 || xs === [];
    skip_ahead m::int n::int (x:xs)   = skip_ahead (m-1) (n+1) xs if n < __std__::SKIPSIZE;
    skip_ahead m::int n::int xs       = n (take m xs);
end;
#! --endif

subseq x a b = slice x (a..b);

#! --if subseq-opt
def x!!(a..b) = subseq x a b;
#! --endif


/* Conversions between lists, tuples and streams. */

list ()		= [];
list (x,xs)	= accum [x] xs with
  accum ys (x,xs)	= accum (x:ys) xs;
  accum ys x		= reverse (x:ys);
end;

tuple []	= ();
tuple (x:xs)	= accum (t x) xs with
  accum ys (x:xs)	= accum (t x,ys) xs;
  accum ys []		= t ys;
  accum	ys xs		= throw (bad_list_value xs);
  t x@(_,_)		= reverse x;
  t x			= x;
end;

tuple x@() | tuple x@(_,_) = x;

list []		= [];
list (x:xs)	= accum [x] xs with
  accum ys (x:xs)	= accum (x:ys) xs;
  accum ys []		= reverse ys;
  accum	ys xs		= throw (bad_list_value xs);
end;

stream []	= [];
stream (x:xs)	= x:xs if thunkp xs;
		= x:stream xs& otherwise;

stream ()	= [];
stream xs@(_,_)	= stream (list xs);

/* Lazy version of `cat`. Equivalent to `cat.(map stream)` but more efficient. */

catstream [] = [];
// the stdlib doesn't reduce `xs+[]` or `cat [xs]` when xs isn't a proper list
// so we don't reduce `catstream (xs:[]) = xs` either.
catstream ((x:xs):yss) = x:catstream (xs:yss)&;
catstream ([]:yss) = catstream yss;
catstream (xs:yss) = xs + catstream yss;


/* Coarse-grained equality. We optimize the definitions for native aggregates
   so as not to have to traverse them twice, when `==` isn't defined for all
   members. */

x::smatrix ==? y::matrix |
x::matrix ==? y::smatrix = 0 if dim x ~= dim y;
			 = compare 0 with
			   compare i::int = 1 if i>=n;
			     = 0 if x!i ~=? y!i;
			     = compare (i+1);
			   end when n::int = #x end;

x::smatrix ~=? y::matrix |
x::matrix ~=? y::smatrix = ~(x ==? y);

(x=>v)==?(y=>w)	= x==?y && v==?w;
(x=>v)~=?(y=>w)	= x~=?y || v~=?w;

(x,xs)==?(y,ys)	= x==?y && xs==?ys;
(x,xs)~=?(y,ys)	= x~=?y || xs~=?ys;

(x:xs)==?(y:ys)	= x==?y && xs==?ys;
(x:xs)~=?(y:ys)	= x~=?y || xs~=?ys;

// the general cases

x ==? y = case x == y of
            res::int = res;
            _ = case x:y of
                    (xh@_ xv):(yh@_ yv) = xh ==? yh && xv ==? yv;
                    x:x = true; // same x y
                    _ = false;
                end;
          end;

x ~=? y = case x == y of
            res::int = res == 0;
            _ = case x:y of
                    (xh@_ xv):(yh@_ yv) = xh ~=? yh || xv ~=? yv;
                    x:x = false; // ~same x y
                    _ = true;
                end;
          end;


/* Add below any extra stuff which doesn't belong elsewhere, or needs to be
   defined after all the basic prelude operations have been loaded. */

/* Optimize the case of "throwaway" list and matrix comprehensions (useful if
   a comprehension is evaluated solely for its side effects). */

#! --if common-opt

namespace __std__ with
  public __do__ __voidchk__ __voidchk1__ __voidchk2__ __voidfun__;
end;

using namespace __std__;

// This is needed to make the following rules work.
#! --quoteargs __std__::__do__

// Entry points.
def void (catmap f x) | void (listmap f x) = __do__ f x;
def void (rowcatmap f x) | void (colcatmap f x) = __do__ f x;
def void (rowmap f x) | void (colmap f x) = __do__ f x;

/* Handle the case of an outermost filter clause. We have to go to some
   lengths here since we want to avoid making 'void' quote its argument. But
   we need to get the argument in quoted form so that we can check for a
   conditional expression. The '__voidchk__' macro takes care of that. */

#! --quoteargs __std__::__voidchk__
def void x = __voidchk__ x x;

// Check for an outermost filter clause.
def __voidchk__ (__ifelse__ y z []) | __voidchk__ (__ifelse__ y z {}) =
  __voidchk1__ (__ifelse__ y (void z) ());
def __voidchk1__ x y = x;

// Default case. This is the tricky part. We want '__voidchk2__ x y' to expand
// to just 'void y'. We can't just write 'void y', though, since that would
// make the __voidchk__ macro loop. But since __voidfun__ is a constant, it
// gets substituted only after macro evaluation, so we can use that here.
const __voidfun__ = void;
def __voidchk__ x = __voidchk2__ x;
def __voidchk2__ x y = __voidfun__ y;

/* The '__do__' macro eventually reduces to just a plain 'do' call, but
   applies some optimizations along the way. While the following rules are
   always valid, we use a separate macro here instead of clobbering 'do'
   itself, so that these optimizations do not interfere with ordinary calls
   to 'do'. */

// Recurse into embedded generator clauses.
def __do__ (__lambda__ [x] y@(listmap _ _)) |
    __do__ (__lambda__ [x] y@(rowmap _ _)) |
    __do__ (__lambda__ [x] y@(colmap _ _)) |
    __do__ (__lambda__ [x] y@(catmap _ _)) |
    __do__ (__lambda__ [x] y@(rowcatmap _ _)) |
    __do__ (__lambda__ [x] y@(colcatmap _ _)) =
    __do__ $ (__lambda__ [x] (void y));

// Recurse into embedded filter clauses.
def __do__ (__lambda__ [x] (__ifelse__ y z [])) |
    __do__ (__lambda__ [x] (__ifelse__ y z {})) =
    __do__ $ (__lambda__ [x] (__ifelse__ y (void z) ()));

// Eliminate extra calls to 'void' in generator clauses.
def __do__ (__lambda__ [x] (void y)) |
    __do__ (__lambda__ [x] (__voidfun__ y)) = __do__ (__lambda__ [x] y);

// Eliminate extra calls to 'void' in filter clauses.
def __do__ (__lambda__ [x] (__ifelse__ y (void z) ())) |
    __do__ (__lambda__ [x] (__ifelse__ y (__voidfun__ z) ())) =
    __do__ (__lambda__ [x] (__ifelse__ y z ()));

// Any remaining instances reduce to a plain 'do' (this must come last).
def __do__ f = do f;

#! --endif

/* List defined symbols using evalcmd "show". */

namespace __C;
// These are provided by the runtime.
extern int pure_getsym(char*);
extern expr *pure_quoted_symbol(int);
pure_quoted_symbol s::string = pure_quoted_symbol id if id>0 when
  id::int = pure_getsym s;
end;
namespace;

globsym pat::string level::int = uniq $ catmap descr info when
  res = evalcmd $ "show -gst"+str level+" "+pat;
  stringp res || throw evalcmd;
  info = init $ init $ split "\n" res;
end with
  descr s::string = case filter (~="") $ split " " s of
    sym:_ =
      if any (==sym) ["extern", "private", "infix", "infixl", "infixr",
		      "prefix", "postfix", "outfix", "nonfix"] then []
      else [x | x = [__C::pure_quoted_symbol sym]; symbolp x];
    _ = [] otherwise;
  end;
  uniq (x:xs@(y:_)) = if x===y then uniq xs else x:uniq xs;
  uniq xs = xs otherwise;
end;

/* Clear defined symbols using evalcmd "show". */

clearsym sym::string level::int = () when
  res = evalcmd $ "clear -t"+str level+" "+sym;
  stringp res || throw evalcmd;
end;

// We also allow allow the symbol to be specified directly.
clearsym sym::symbol level::int = clearsym sym level when
  sym = str sym; sym = if sym!0=="(" then substr sym 2 (#sym-2) else sym;
end;
