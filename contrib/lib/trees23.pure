/* Generic 2-3-tree data structure for implementing sets, dictionaries,
   and the like. */

/* NOTE: This module implements just the raw 2-3-tree data structure. The
   provided operations are fairly low-level and not intended to be used
   directly in applications. You'd rather want to use the high-level
   interfaces in dict.pure and set.pure instead. */

/* Copyright (c) 2012 by Dubiousjim <dubiousjim@gmail.com>.
   API and some portions from avltrees.pure
   Copyright (c) 2008-2012 by Albert Graef <Dr.Graef@t-online.de>
   and (c) 2008-2012 by Jiri Spitz <jiri.spitz@bluetone.cz>.

   This file is part of the Pure standard library.

   The Pure standard library is free software: you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
   more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* Based on descriptions of AA-trees, which are binary emulations of
   2-3-trees. See:
   A. Andersson. Balanced search trees made simple. <http://user.it.uu.se/~arnea/abs/simp.html>
   http://eternallyconfuzzled.com/tuts/datastructures/jsw_tut_andersson.aspx
   http://thomaswilburn.net/typedefs/index.php/tree/aa/aa_trees.html
   http://en.wikipedia.org/wiki/AA_tree
   http://demakov.com/snippets/aatree.html */

namespace trees23;

/* Tree constructors: `nil` denotes an empty tree, `bin left x right`
   an interior node with the given left and right subtrees, and
   `tri left y center z right` and interior node with the given subtrees.
   These are shared by all variations of the data structure. Depending on the
   particular type of data structure, the data element may take the form of a
   simple key (set-like), a key=>value pair (dictionary-like), or a
   key=>bucket pair (hash-like). The latter form is also used for multisets
   and multidicts where multiple elements may be stored under a single key.
   For hash trees no order of the key elements is assumed, and keys are only
   compared for syntactical equality. Keys in non-hash trees must be ordered,
   i.e., at least the comparison predicate `<` must be defined in a consistent
   fashion on them. In this case keys a and b are considered equal if neither
   a<b nor b<a holds. Note that in this case, adding b (or b=>value) to a tree
   that already contains a (or a=>the same value) returns the original tree
   unaltered. This reduces needless GC activity, but it might not
   be what you expect if b is nonetheless discernable from a. To work around
   this optimization, use an ordering that counts a<b or b<a---or use an
   unordered tree. */

private nonfix nil fail;
private bin tri;

/* Private helper functions. */

private shrink_left shrink_center shrink_right;
private pop_left pop_right mpop_left mpop_right;
private cmp cmp1 cmp2 cmp3;
private head2 head3 whenfail;
private splitby popl popr; // custom versions of list functions
private spaces center tostring;

private LT EQ GT GE MID LT2 EQ2 GT2 GE2;

const LT = -1; // s1 < s2
const EQ = 0;
const GT = 1; // s1 > s2
const GE = 2; // ~(s1 < s2)
const MID = 3; // s1 >= s2 && s1 < s3
const LT2 = 4; // s1 > s2 && s1 < s3
const EQ2 = 5; // s1 > s2 && s1 == s3
const GT2 = 6; // s1 > s2 && s1 > s3
const GE2 = 7; // s1 >= s2 && ~(s1 < s3)


/* Operations to construct an empty tree, and to check for an empty tree.
   These are the same for all variations of the data structure. */

public emptytree null;

emptytree = nil;

null nil = 1;
null (bin _ _ _) = 0;
null (tri _ _ _ _ _) = 0;

type tree nil | tree (bin _ _ _) | tree (tri _ _ _ _ _);


/* In the following, different operations are provided for the different kinds
   of trees, which are designated by corresponding prefixes: m denotes
   multiple values per key, h stands for hashed trees (m and h may be
   combined). In addition, the suffix k indicates an operation which is only
   available for dictionary (key=>value) trees. */


/* Basic 2-3-tree operations, single value per key. */

public size members keys vals;
public first last rmfirst rmlast popfirst poplast;

// Compute the size of a tree.

size t = size t with
    size nil = 0;
    size (bin l _ r) = size l + size r + 1;
    size (tri l _ c _ r) = size l + size c + size r + 2;
end;

// Get the list of all members

members t = members t [] with
    members nil base = base;
    members (bin l x r) base = members l (x : members r base);
    members (tri l y c z r) base = members l (y : members c (z : members r base));
end;


// Get the list of all keys and values. This requires a dictionary-like
// structure with separate key values.

keys t = keys t [] with
    keys nil base = base;
    keys (bin l (x=>_) r) base = keys l (x : keys r base);
    keys (tri l (y=>_) c (z=>_) r) base = keys l (y : keys c (z : keys r base));
end;

vals t = vals t [] with
    vals nil base = base;
    vals (bin l (_=>x) r) base = vals l (x : vals r base);
    vals (tri l (_=>y) c (_=>z) r) base = vals l (y : vals c (z : vals r base));
end;

// Get the first and the last member of a tree. Like head/tail and init/last
// for [], the following six functions just fail to reduce when applied to
// nil.

first t = first t with
    first (bin nil x _) = x;
    first (bin l _ _) = first l;
    first (tri nil y _ _ _) = y;
    first (tri l _ _ _ _) = first l;
end if t~==nil;

last t = last t with
    last (bin _ x nil) = x;
    last (bin _ _ r) = last r;
    last (tri _ _ _ z nil) = z;
    last (tri _ _ _ _ r) = last r;
end if t~==nil;

// Remove the first and the last member from a tree.

rmfirst t = head3 $ pop_left t if t~==nil;

rmlast t = head3 $ pop_right t if t~==nil;

popfirst t = case pop_left t of
    child@_ _ w = {| w, child |};
end if t~==nil;

poplast t = case pop_right t of
    child@_ _ w = {| w, child |};
end if t~==nil;


/* Basic 2-3-tree operations, multiple values per key. */

public msize mmembers mkeys mvals;
public mfirst mlast mrmfirst mrmlast mpopfirst mpoplast;

msize t = size t with
    size nil = 0;
    size (bin l (_=>xs) r) = size l + size r + #xs;
    size (tri l (_=>ys) c (_=>zs) r) = size l + size c + size r + #ys + #zs;
end;

// For compatibility with avltrees, we return the member list with first-added elements first.

mmembers t = members t [] with
    members nil base = base;
    members (bin l (_=>xs) r) base = members l (reverse_onto (members r base) xs);
    members (tri l (_=>ys) c (_=>zs) r) base = members l (reverse_onto (members c (reverse_onto (members r base) zs)) ys);
end;

mkeys t = keys t [] with
    keys nil base = base;
    keys (bin l (_=>xs) r) base = keys l (reverse_onto (keys r base) [x | x=>_ = xs]);
    keys (tri l (_=>ys) c (_=>zs) r) base = keys l (reverse_onto (keys c (reverse_onto (keys r base) [z | z=>_ = zs])) [y | y=>_ = ys]);
end;

mvals t = vals t [] with
    vals nil base = base;
    vals (bin l (_=>xs) r) base = vals l (reverse_onto (vals r base) [x | _=>x = xs]);
    vals (tri l (_=>ys) c (_=>zs) r) base = vals l (reverse_onto (vals c (reverse_onto (vals r base) [z | _=>z = zs])) [y | _=>y = ys]);
end;

// Get the first and the last mmember of a tree. Like head/tail and init/last
// for [], the following six functions just fail to reduce when applied to
// nil.

mfirst t = first t with
    // first-added element is at the end of the list
    first (bin nil (_=>xs) _) = ::last xs;
    first (bin l _ _) = first l;
    first (tri nil (_=>ys) _ _ _) = ::last ys;
    first (tri l _ _ _ _) = first l;
end if t~==nil;

mlast t = last t with
    // last-added element is at the head of the list
    last (bin _ (_=>xs) nil) = head xs;
    last (bin _ _ r) = last r;
    last (tri _ _ _ (_=>zs) nil) = head zs;
    last (tri _ _ _ _ r) = last r;
end if t~==nil;

mrmfirst t = head3 $ mpop_left t if t~==nil;

mrmlast t = head3 $ mpop_right t if t~==nil;

mpopfirst t = case mpop_left t of
    child@_ _ w = {| w, child |};
end if t~==nil;

mpoplast t = case mpop_right t of
    child@_ _ w = {| w, child |};
end if t~==nil;


/* The above also apply to all kinds of hash trees. For convenience and
   clarity, we define some corresponding synonyms here. */

public hsize hmembers hkeys hvals hfirst hlast hrmfirst hrmlast hpopfirst hpoplast;

hsize t    = msize t;
hmembers t = mmembers t;
hkeys t    = mkeys t;
hvals t    = mvals t;
hfirst t   = mfirst t;
hlast t    = mlast t;
hrmfirst t = mrmfirst t;
hrmlast t  = mrmlast t;
hpopfirst t = mpopfirst t;
hpoplast t  = mpoplast t;


/* Membership test for ordered sets and dictionaries. */

public member memberk;

/* To optimize the number of comparisons, we use cmp1 k x, which may
   only report that k >= x. At that point we save x as a candidate match,
   and continue recursing. We only check whether the most recent
   candidate is itself >= k when we reach the bottom of the tree. This
   can spare us some (possibly-expensive) comparisons, at the expense of
   perhaps recursing deeper in the tree than necessary.

   This technique from http://user.it.uu.se/~arnea/abs/searchproc.html

   We flag that no candidate match is presently available with `fail`. */

member t old = mem old fail t with
    mem old w nil = w~==fail && (case cmp1 w old of
      res::int
        = 1 if res == GE || res == EQ;
        = 0;
    end);
    mem old w (bin l x r) = case cmp1 old x of
      res::int
        = mem old w l if res == LT;
        = 1 if res == EQ;
        = mem old fail r if res == GT;
        = mem old x r if res == GE; // x may be a match
    end;
    mem old w (tri l y c z r) = case cmp3 old y z of
      res::int
        = mem old w l if res == LT;
        = 1 if res == EQ;
        = mem old y c if res == MID; // y may be a match
        = mem old fail c if res == LT2;
        = 1 if res == EQ2;
        = mem old fail r if res == GT2;
        = mem old z r if res == GE2; // z may be a match
    end;
end;

memberk t k = mem k fail t with
    mem k w nil = w~==fail && (case cmp1 w k of
      res::int
        = 1 if res == GE || res == EQ;
        = 0;
    end);
    mem k w (bin l (x=>_) r) = case cmp1 k x of
      res::int
        = mem k w l if res == LT;
        = 1 if res == EQ;
        = mem k fail r if res == GT;
        = mem k x r if res == GE; // x may be a match
    end;
    mem k w (tri l (y=>_) c (z=>_) r) = case cmp3 k y z of
      res::int
        = mem k w l if res == LT;
        = 1 if res == EQ;
        = mem k y c if res == MID; // y may be a match
        = mem k fail c if res == LT2;
        = 1 if res == EQ2;
        = mem k fail r if res == GT2;
        = mem k z r if res == GE2; // z may be a match
    end;
end;


/* Membership test for hashed sets and dictionaries. */

public hmember hmemberk;

hmember t old = mem (hash old) old t with
    mem _ _ nil = 0;
    mem h::int old (bin l (xh::int=>xs) r) = case cmp h xh of
      res::int
        = mem h old l if res == LT;
        = any (same old) xs if res == EQ;
        = mem h old r if res == GT;
    end;
    mem h::int old (tri l (yh::int=>ys) c (zh::int=>zs) r) = case cmp2 h yh zh of
      res::int
        = mem h old l if res == LT;
        = any (same old) ys if res == EQ;
        = mem h old c if res == LT2;
        = any (same old) zs if res == EQ2;
        = mem h old r if res == GT2;
    end;
end;

hmemberk t k = mem (hash k) k t with
    mem _ _ nil = 0;
    mem h::int k (bin l (xh::int=>xs) r) = case cmp h xh of
      res::int
        = mem h k l if res == LT;
        = any (same k.key) xs if res == EQ;
        = mem h k r if res == GT;
    end;
    mem h::int k (tri l (yh::int=>ys) c (zh::int=>zs) r) = case cmp2 h yh zh of
      res::int
        = mem h k l if res == LT;
        = any (same k.key) ys if res == EQ;
        = mem h k c if res == LT2;
        = any (same k.key) zs if res == EQ2;
        = mem h k r if res == GT2;
    end;
end;


/* Indexing for ordered dictionaries. An out_of_bounds exception is thrown if
   the key doesn't exist in the tree. */

public getk;

getk t k = get k fail () t with
    get k w wv nil = if w===fail then throw out_of_bounds
    else case cmp1 w k of
      res::int
        = wv if res == GE || res == EQ;
        = throw out_of_bounds;
    end;
    get k w wv (bin l (x=>xv) r) = case cmp1 k x of
      res::int
        = get k w wv l if res == LT;
        = xv if res == EQ;
        = get k fail () r if res == GT;
        = get k x xv r if res == GE; // x may be a match
    end;
    get k w wv (tri l (y=>yv) c (z=>zv) r) = case cmp3 k y z of
      res::int
        = get k w wv l if res == LT;
        = yv if res == EQ;
        = get k y yv c if res == MID; // y may be a match
        = get k fail () c if res == LT2;
        = zv if res == EQ2;
        = get k fail () r if res == GT2;
        = get k z zv r if res == GE2; // z may be a match
    end;
end;

/* Indexing for ordered multidicts. mgetk always returns the list of all members
   for the given key, which may be empty if the key is not in the tree.
   mgetko returns the "oldest" value for the given k, and mgetkn returns the
   "newest" (most recently added) value. The latter two functions throw an
   out_of_bounds exception if the key doesn't exist in the tree.
 */

public mgetk mgetko mgetkn;

mgetk t k = get k fail [] t with
    get k w ws nil = if ::null ws then []
    else case cmp1 w k of
      res::int
        = match ws if res == GE || res == EQ;
        = [];
    end;
    get k w ws (bin l (x=>xs) r) = case cmp1 k x of
      res::int
        = get k w ws l if res == LT;
        = match xs if res == EQ;
        = get k fail [] r if res == GT;
        = get k x xs r if res == GE; // x may be a match
    end;
    get k w ws (tri l (y=>ys) c (z=>zs) r) = case cmp3 k y z of
      res::int
        = get k w ws l if res == LT;
        = match ys if res == EQ;
        = get k y ys c if res == MID; // y may be a match
        = get k fail [] c if res == LT2;
        = match zs if res == EQ2;
        = get k fail [] r if res == GT2;
        = get k z zs r if res == GE2; // z may be a match
    end;
    // extract values and reverse
    match us = ::foldl (flip((:).val)) [] us;
end;

mgetko t k = get k fail [] t with
    get k w ws nil = if ::null ws then throw out_of_bounds
    else case cmp1 w k of
      res::int
        = ::last ws if res == GE || res == EQ;
        = throw out_of_bounds;
    end;
    get k w ws (bin l (x=>xs) r) = case cmp1 k x of
      res::int
        = get k w ws l if res == LT;
        = ::last xs if res == EQ;
        = get k fail [] r if res == GT;
        = get k x xs r if res == GE; // x may be a match
    end;
    get k w ws (tri l (y=>ys) c (z=>zs) r) = case cmp3 k y z of
      res::int
        = get k w ws l if res == LT;
        = ::last ys if res == EQ;
        = get k y ys c if res == MID; // y may be a match
        = get k fail [] c if res == LT2;
        = ::last zs if res == EQ2;
        = get k fail [] r if res == GT2;
        = get k z zs r if res == GE2; // z may be a match
    end;
end;

mgetkn t k = get k fail [] t with
    get k w ws nil = if ::null ws then throw out_of_bounds
    else case cmp1 w k of
      res::int
        = ::head ws if res == GE || res == EQ;
        = throw out_of_bounds;
    end;
    get k w ws (bin l (x=>xs) r) = case cmp1 k x of
      res::int
        = get k w ws l if res == LT;
        = ::head xs if res == EQ;
        = get k fail [] r if res == GT;
        = get k x xs r if res == GE; // x may be a match
    end;
    get k w ws (tri l (y=>ys) c (z=>zs) r) = case cmp3 k y z of
      res::int
        = get k w ws l if res == LT;
        = ::head zs if res == EQ;
        = get k y ys c if res == MID; // y may be a match
        = get k fail [] c if res == LT2;
        = ::head zs if res == EQ2;
        = get k fail [] r if res == GT2;
        = get k z zs r if res == GE2; // z may be a match
    end;
end;


/* Indexing for hashed (multi-)dicts. */

public hgetk mhgetk mhgetko mhgetkn;

hgetk t k = get (hash k) k t with
    get _ _ nil = throw out_of_bounds;
    get h::int k (bin l (xh::int=>xs) r) = case cmp h xh of
      res::int
        = get h k l if res == LT;
        = match k xs if res == EQ;
        = get h k r if res == GT;
    end;
    get h::int k (tri l (yh::int=>ys) c (zh::int=>zs) r) = case cmp2 h yh zh of
      res::int
        = get h k l if res == LT;
        = match k ys if res == EQ;
        = get h k c if res == LT2;
        = match k zs if res == EQ2;
        = get h k r if res == GT2;
    end;
    match k us = val (findl (same k.key) us); // throw out_of_bounds if no hits
end;

mhgetk t k = get (hash k) k t with
    get _ _ nil = [];
    get h::int k (bin l (xh::int=>xs) r) = case cmp h xh of
      res::int
        = get h k l if res == LT;
        = match k xs if res == EQ;
        = get h k r if res == GT;
    end;
    get h::int k (tri l (yh::int=>ys) c (zh::int=>zs) r) = case cmp2 h yh zh of
      res::int
        = get h k l if res == LT;
        = match k ys if res == EQ;
        = get h k c if res == LT2;
        = match k zs if res == EQ2;
        = get h k r if res == GT2;
    end;
    // reverse [v | u=>v = us; k===u];
    match k us = ::foldl (\vs (uk=>uv) -> if k===uk then uv:vs else vs) [] us;
end;

mhgetko t k = get (hash k) k t with
    get _ _ nil = throw out_of_bounds;
    get h::int k (bin l (xh::int=>xs) r) = case cmp h xh of
      res::int
        = get h k l if res == LT;
        = match k xs if res == EQ;
        = get h k r if res == GT;
    end;
    get h::int k (tri l (yh::int=>ys) c (zh::int=>zs) r) = case cmp2 h yh zh of
      res::int
        = get h k l if res == LT;
        = match k ys if res == EQ;
        = get h k c if res == LT2;
        = match k zs if res == EQ2;
        = get h k r if res == GT2;
    end;
    match k us = val (findr (same k.key) us); // throw out_of_bounds if no hits
end;

mhgetkn t k = get (hash k) k t with
    get _ _ nil = throw out_of_bounds;
    get h::int k (bin l (xh::int=>xs) r) = case cmp h xh of
      res::int
        = get h k l if res == LT;
        = match k xs if res == EQ;
        = get h k r if res == GT;
    end;
    get h::int k (tri l (yh::int=>ys) c (zh::int=>zs) r) = case cmp2 h yh zh of
      res::int
        = get h k l if res == LT;
        = match k ys if res == EQ;
        = get h k c if res == LT2;
        = match k zs if res == EQ2;
        = get h k r if res == GT2;
    end;
    match k us = val (findl (same k.key) us); // throw out_of_bounds if no hits
end;

/* 2-3-tree insertion and deletion. */

/* Ordered case, single value. */

public insert insertk;

insert t new = catch (whenfail t) (head2 $ ins new t) with
    ins new nil = (bin nil new nil) true; // bump height at prev level
    ins new (bin l1 x1 r1) = case cmp new x1 of
      res::int
        = case ins new l1 of
                child@_ 0 = (bin child x1 r1) false;
                (bin l2 x2 r2) 1 = (tri l2 x2 r2 x1 r1) false;
          end if res == LT;
        = throw fail if res == EQ; // keep existing tree
        = case ins new r1 of
                child@_ 0 = (bin l1 x1 child) false;
                (bin l2 x2 r2) 1 = (tri l1 x1 l2 x2 r2) false;
          end if res == GT;
    end;
    ins new (tri l1 y1 c1 z1 r1) = case cmp2 new y1 z1 of
      res::int
        = case ins new l1 of
                child@_ 0 = (tri child y1 c1 z1 r1) false;
                child@_ 1 = (bin child y1 (bin c1 z1 r1)) true; // bump height at prev level
          end if res == LT;
        = throw fail if res == EQ;
        = case ins new c1 of
                child@_ 0 = (tri l1 y1 child z1 r1) false;
                (bin l2 x2 r2) 1 = (bin (bin l1 y1 l2) x2 (bin r2 z1 r1)) true; // bump height at prev level
          end if res == LT2;
        = throw fail if res == EQ2;
        = case ins new r1 of
                child@_ 0 = (tri l1 y1 c1 z1 child) false;
                child@_ 1 = (bin (bin l1 y1 c1) z1 child) true; // bump height at prev level
          end if res == GT2;
    end;
end;

insertk t new@(k=>v) = catch (whenfail t) (head2 $ ins k v new t) with
    ins k v new nil = (bin nil new nil) true; // bump height at prev level
    ins k v new (bin l1 x1@(xk=>xv) r1) = case cmp k xk of
      res::int
        = case ins k v new l1 of
            child@_ 0 = (bin child x1 r1) false;
            (bin l2 x2 r2) 1 = (tri l2 x2 r2 x1 r1) false;
          end if res == LT;
        = if v==?xv then throw fail // keep existing tree
          else (bin l1 new r1) false if res == EQ;
        = case ins k v new r1 of
            child@_ 0 = (bin l1 x1 child) false;
            (bin l2 x2 r2) 1 = (tri l1 x1 l2 x2 r2) false;
          end if res == GT;
    end;
    ins k v new (tri l1 y1@(yk=>yv) c1 z1@(zk=>zv) r1) = case cmp2 k yk zk of
      res::int
        = case ins k v new l1 of
                child@_ 0 = (tri child y1 c1 z1 r1) false;
                child@_ 1 = (bin child y1 (bin c1 z1 r1)) true; // bump height at prev level
          end if res == LT;
        = if v==?yv then throw fail // keep existing tree
          else (tri l1 new c1 z1 r1) false if res == EQ;
        = case ins k v new c1 of
                child@_ 0 = (tri l1 y1 child z1 r1) false;
                (bin l2 x2 r2) 1 = (bin (bin l1 y1 l2) x2 (bin r2 z1 r1)) true; // bump height at prev level
          end if res == LT2;
        = if v==?zv then throw fail // keep existing tree
          else (tri l1 y1 c1 new r1) false if res == EQ2;
        = case ins k v new r1 of
            child@_ 0 = (tri l1 y1 c1 z1 child) false;
            child@_ 1 = (bin (bin l1 y1 c1) z1 child) true; // bump height at prev level
          end if res == GT2;
    end;
end;

public delete deletek popk deletekv popkv;

delete t old = catch (whenfail t) (head3 $ pop old t) with
    pop _ nil = throw fail;
    pop old cur@(bin l x r) = case cmp old x of
      res::int
        = shrink_left (pop old) cur if res == LT;
        = if r===nil then l 1 x
          else (shrink_right (\_ -> child snag x) (bin l w r) when
            child@_ snag w = pop_left r
          end) if res == EQ;
        = shrink_right (pop old) cur if res == GT;
    end;
    pop old cur@(tri l y c z r) = case cmp2 old y z of
      res::int
        = shrink_left (pop old) cur if res == LT;
        = if c===nil then (bin l z r) 0 y
          else (shrink_center (\_ -> child snag y) (tri l w c z r) when
            child@_ snag w = pop_left c
          end) if res == EQ;
        = shrink_center (pop old) cur if res == LT2;
        = if r===nil then (bin l y c) 0 z
          else (shrink_right (\_ -> child snag z) (tri l y c w r) when
            child@_ snag w = pop_left r
          end) if res == EQ2;
        = shrink_right (pop old) cur if res == GT2;
    end;
end;

private base_popk;

deletek t k = catch (whenfail t) (head3 $ base_popk k t fail);

popk t k = {| v, child |} when
    child@_ _ (_=>v) = base_popk k t out_of_bounds;
end;

base_popk k t e = pop k t with
    pop k nil = throw e;
    pop k cur@(bin l x@(xk=>_) r) = case cmp k xk of
      res::int
        = shrink_left (pop k) cur if res == LT;
        = if r===nil then l 1 x
          else (shrink_right (\_ -> child snag x) (bin l w r) when
            child@_ snag w = pop_left r
          end) if res == EQ;
        = shrink_right (pop k) cur if res == GT;
    end;
    pop k cur@(tri l y@(yk=>_) c z@(zk=>_) r) = case cmp2 k yk zk of
      res::int
        = shrink_left (pop k) cur if res == LT;
        = if c===nil then (bin l z r) 0 y
          else (shrink_center (\_ -> child snag y) (tri l w c z r) when
            child@_ snag w = pop_left c
          end) if res == EQ;
        = shrink_center (pop k) cur if res == LT2;
        = if r===nil then (bin l y c) 0 z
          else (shrink_right (\_ -> child snag z) (tri l y c w r) when
            child@_ snag w = pop_left r
          end) if res == EQ2;
        = shrink_right (pop k) cur if res == GT2;
    end;
end;

// Delete one specific key=>val pair.

private base_popkv;

deletekv t (k=>v) = catch (whenfail t) (head3 $ base_popkv k v t fail);

// The popkv methods may seem like overkill: you already know the k=>v so
// why isn't deletekv enough? However we do need these methods for weak-value
// dicts.
popkv t (k=>v) = {| v, child |} when
    child@_ _ (_=>v) = base_popkv k v t out_of_bounds;
end;

base_popkv k v t e = pop k v t with
    pop k v nil = throw e;
    pop k v cur@(bin l x@(xk=>xv) r) = case cmp k xk of
      res::int
        = shrink_left (pop k v) cur if res == LT;
        = if v~=?xv then throw e
          else if r===nil then l 1 x
          else (shrink_right (\_ -> child snag x) (bin l w r) when
            child@_ snag w = pop_left r
          end) if res == EQ;
        = shrink_right (pop k v) cur if res == GT;
    end;
    pop k v cur@(tri l y@(yk=>yv) c z@(zk=>zv) r) = case cmp2 k yk zk of
      res::int
        = shrink_left (pop k v) cur if res == LT;
        = if v~=?yv then throw e
          else if c===nil then (bin l z r) 0 y
          else (shrink_center (\_ -> child snag y) (tri l w c z r) when
            child@_ snag w = pop_left c
          end) if res == EQ;
        = shrink_center (pop k v) cur if res == LT2;
        = if v~=?zv then throw e
          else if r===nil then (bin l y c) 0 z
          else (shrink_right (\_ -> child snag z) (tri l y c w r) when
            child@_ snag w = pop_left r
          end) if res == EQ2;
        = shrink_right (pop k v) cur if res == GT2;
    end;
end;


/* Ordered case, multiple values. */

public minsert minsertk;

minsert t new = head2 $ ins new t with
    ins new nil = (bin nil (new=>[new]) nil) true; // bump height at prev level
    ins new (bin l1 x1@(xk=>xs) r1) = case cmp new xk of
      res::int
        = case ins new l1 of
            child@_ 0 = (bin child x1 r1) false;
            (bin l2 x2 r2) 1 = (tri l2 x2 r2 x1 r1) false;
          end if res == LT;
        = (bin l1 (xk=>new:xs) r1) false if res == EQ;
        = case ins new r1 of
            child@_ 0 = (bin l1 x1 child) false;
            (bin l2 x2 r2) 1 = (tri l1 x1 l2 x2 r2) false;
          end if res == GT;
    end;
    ins new (tri l1 y1@(yk=>ys) c1 z1@(zk=>zs) r1) = case cmp2 new yk zk of
      res::int
        = case ins new l1 of
                child@_ 0 = (tri child y1 c1 z1 r1) false;
                child@_ 1 = (bin child y1 (bin c1 z1 r1)) true; // bump height at prev level
          end if res == LT;
        = (tri l1 (yk=>new:ys) c1 z1 r1) false if res == EQ;
        = case ins new c1 of
                child@_ 0 = (tri l1 y1 child z1 r1) false;
                (bin l2 x2 r2) 1 = (bin (bin l1 y1 l2) x2 (bin r2 z1 r1)) true; // bump height at prev level
          end if res == LT2;
        = (tri l1 y1 c1 (zk=>new:zs) r1) false if res == EQ2;
        = case ins new r1 of
            child@_ 0 = (tri l1 y1 c1 z1 child) false;
            child@_ 1 = (bin (bin l1 y1 c1) z1 child) true; // bump height at prev level
          end if res == GT2;
    end;
end;

minsertk t new@(k=>_) = head2 $ ins k new t with
    ins k new nil = (bin nil (k=>[new]) nil) true; // bump height at prev level
    ins k new (bin l1 x1@(xk=>xs) r1) = case cmp k xk of
      res::int
        = case ins k new l1 of
            child@_ 0 = (bin child x1 r1) false;
            (bin l2 x2 r2) 1 = (tri l2 x2 r2 x1 r1) false;
          end if res == LT;
        = (bin l1 (xk=>new:xs) r1) false if res == EQ;
        = case ins k new r1 of
            child@_ 0 = (bin l1 x1 child) false;
            (bin l2 x2 r2) 1 = (tri l1 x1 l2 x2 r2) false;
          end if res == GT;
    end;
    ins k new (tri l1 y1@(yk=>ys) c1 z1@(zk=>zs) r1) = case cmp2 k yk zk of
      res::int
        = case ins k new l1 of
                child@_ 0 = (tri child y1 c1 z1 r1) false;
                child@_ 1 = (bin child y1 (bin c1 z1 r1)) true; // bump height at prev level
          end if res == LT;
        = (tri l1 (yk=>new:ys) c1 z1 r1) false if res == EQ;
        = case ins k new c1 of
                child@_ 0 = (tri l1 y1 child z1 r1) false;
                (bin l2 x2 r2) 1 = (bin (bin l1 y1 l2) x2 (bin r2 z1 r1)) true; // bump height at prev level
          end if res == LT2;
        = (tri l1 y1 c1 (zk=>new:zs) r1) false if res == EQ2;
        = case ins k new r1 of
            child@_ 0 = (tri l1 y1 c1 z1 child) false;
            child@_ 1 = (bin (bin l1 y1 c1) z1 child) true; // bump height at prev level
          end if res == GT2;
    end;
end;

public mdelete mdeleteko mdeletekn mpopko mpopkn;
public mdeletekvo mdeletekvn mdeletekva mpopkva;

private base_mpopkn base_mpopko;

// If elements are discernable but still EQ, note:
// We delete the element added most recently, which we can do efficiently.
// avltrees on the other hand removes the element added first.
mdelete t old = catch (whenfail t) (head3 $ base_mpopkn old t fail);

mdeleteko t k = catch (whenfail t) (head3 $ base_mpopko k t fail);


mpopko t k = {| v, child |} when
    child@_ _ (_=>v) = base_mpopko k t out_of_bounds;
end;

base_mpopko k t e = pop k t with
    pop k nil = throw e;
    pop k cur@(bin l x@(xk=>xs) r) = case cmp k xk of
      res::int
        = shrink_left (pop k) cur if res == LT;
        = case rotate xs of
            [x]  = if r===nil then l 1 x
                   else (shrink_right (\_ -> child snag x) (bin l w r) when
                        child@_ snag w = pop_left r
                   end);
            x:xs = (bin l (xk=>xs) r) 0 x;
          end if res == EQ;
        = shrink_right (pop k) cur if res == GT;
    end;
    pop k cur@(tri l y@(yk=>ys) c z@(zk=>zs) r) = case cmp2 k yk zk of
      res::int
        = shrink_left (pop k) cur if res == LT;
        = case rotate ys of
            [y]  = if c===nil then (bin l z r) 0 y
                   else (shrink_center (\_ -> child snag y) (tri l w c z r) when
                        child@_ snag w = pop_left c
                   end);
            y:ys = (tri l (yk=>ys) c z r) 0 y;
          end if res == EQ;
        = shrink_center (pop k) cur if res == LT2;
        = case rotate zs of
            [z]  = if r===nil then (bin l y c) 0 z
                   else (shrink_right (\_ -> child snag z) (tri l y c w r) when
                        child@_ snag w = pop_left r
                   end);
            z:zs = (tri l y c (zk=>zs) r) 0 z;
          end if res == EQ2;
        = shrink_right (pop k) cur if res == GT2;
    end;
end;

mdeletekvo t (k=>v) = catch (whenfail t) (head3 $ pop k v t) with
    del v us = popr fail ((v==?).val) us; // throw fail if no hits
    pop k v nil = throw fail;
    pop k v cur@(bin l x@(xk=>xs) r) = case cmp k xk of
      res::int
        = shrink_left (pop k v) cur if res == LT;
        = case del v xs of
            [x]  = if r===nil then l 1 x
                   else (shrink_right (\_ -> child snag x) (bin l w r) when
                        child@_ snag w = pop_left r
                   end);
            x:xs = (bin l (xk=>xs) r) 0 x;
          end if res == EQ;
        = shrink_right (pop k v) cur if res == GT;
    end;
    pop k v cur@(tri l y@(yk=>ys) c z@(zk=>zs) r) = case cmp2 k yk zk of
      res::int
        = shrink_left (pop k v) cur if res == LT;
        = case del v ys of
            [y]  = if c===nil then (bin l z r) 0 y
                   else (shrink_center (\_ -> child snag y) (tri l w c z r) when
                        child@_ snag w = pop_left c
                   end);
            y:ys = (tri l (yk=>ys) c z r) 0 y;
          end if res == EQ;
        = shrink_center (pop k v) cur if res == LT2;
        = case del v zs of
            [z]  = if r===nil then (bin l y c) 0 z
                   else (shrink_right (\_ -> child snag z) (tri l y c w r) when
                        child@_ snag w = pop_left r
                   end);
            z:zs = (tri l y c (zk=>zs) r) 0 z;
          end if res == EQ2;
        = shrink_right (pop k v) cur if res == GT2;
    end;
end;

mdeletekn t k = catch (whenfail t) (head3 $ base_mpopkn k t fail);

mpopkn t k = {| v, child |} when
    child@_ _ (_=>v) = base_mpopkn k t out_of_bounds;
end;

base_mpopkn k t e = pop k t with
    pop k nil = throw e;
    pop k cur@(bin l x@(xk=>xs) r) = case cmp k xk of
      res::int
        = shrink_left (pop k) cur if res == LT;
        = case xs of
            [x]  = if r===nil then l 1 x
                   else (shrink_right (\_ -> child snag x) (bin l w r) when
                        child@_ snag w = pop_left r
                   end);
            x:xs = (bin l (xk=>xs) r) 0 x;
          end if res == EQ;
        = shrink_right (pop k) cur if res == GT;
    end;
    pop k cur@(tri l y@(yk=>ys) c z@(zk=>zs) r) = case cmp2 k yk zk of
      res::int
        = shrink_left (pop k) cur if res == LT;
        = case ys of
            [y]  = if c===nil then (bin l z r) 0 y
                   else (shrink_center (\_ -> child snag y) (tri l w c z r) when
                        child@_ snag w = pop_left c
                   end);
            y:ys = (tri l (yk=>ys) c z r) 0 y;
          end if res == EQ;
        = shrink_center (pop k) cur if res == LT2;
        = case zs of
            [z]  = if r===nil then (bin l y c) 0 z
                   else (shrink_right (\_ -> child snag z) (tri l y c w r) when
                        child@_ snag w = pop_left r
                   end);
            z:zs = (tri l y c (zk=>zs) r) 0 z;
          end if res == EQ2;
        = shrink_right (pop k) cur if res == GT2;
    end;
end;

mdeletekvn t (k=>v) = catch (whenfail t) (head3 $ pop k v t) with
    del v us = popl fail ((v==?).val) us; // throw fail if no hits
    pop k v nil = throw fail;
    pop k v cur@(bin l x@(xk=>xs) r) = case cmp k xk of
      res::int
        = shrink_left (pop k v) cur if res == LT;
        = case del v xs of
            [x]  = if r===nil then l 1 x
                   else (shrink_right (\_ -> child snag x) (bin l w r) when
                       child@_ snag w = pop_left r
                   end);
            x:xs = (bin l (xk=>xs) r) 0 x;
          end if res == EQ;
        = shrink_right (pop k v) cur if res == GT;
    end;
    pop k v cur@(tri l y@(yk=>ys) c z@(zk=>zs) r) = case cmp2 k yk zk of
      res::int
        = shrink_left (pop k v) cur if res == LT;
        = case del v ys of
            [y]  = if c===nil then (bin l z r) 0 y
                   else (shrink_center (\_ -> child snag y) (tri l w c z r) when
                       child@_ snag w = pop_left c
                   end);
            y:ys = (tri l (yk=>ys) c z r) 0 y;
          end if res == EQ;
        = shrink_center (pop k v) cur if res == LT2;
        = case del v zs of
            [z]  = if r===nil then (bin l y c) 0 z
                   else (shrink_right (\_ -> child snag z) (tri l y c w r) when
                       child@_ snag w = pop_left r
                   end);
            z:zs = (tri l y c (zk=>zs) r) 0 z;
          end if res == EQ2;
        = shrink_right (pop k v) cur if res == GT2;
    end;
end;

private base_mpopkva;

mdeletekva t (k=>v) = catch (whenfail t) (head3 $ base_mpopkva k v t fail);

// See comments to popkv on why this is needed.
mpopkva t (k=>v) = {| vs, child |} when
    child@_ _ vs = base_mpopkva k v t out_of_bounds;
    // extract values and reverse
    vs = ::foldl (flip((:).val)) [] vs;
end;

base_mpopkva k v t e = pop k v t with
    del v us = splitby ((v==?).val) us; // rotate reversed list of hits to head
    pop k v nil = throw e;
    pop k v cur@(bin l x@(xk=>xs) r) = case cmp k xk of
      res::int
        = shrink_left (pop k v) cur if res == LT;
        = case del v xs of
            [x]  = if r===nil then l 1 x
                   else (shrink_right (\_ -> child snag x) (bin l w r) when
                        child@_ snag w = pop_left r
                   end);
            x:xs = (bin l (xk=>xs) r) 0 x;
          end if res == EQ;
        = shrink_right (pop k v) cur if res == GT;
    end;
    pop k v cur@(tri l y@(yk=>ys) c z@(zk=>zs) r) = case cmp2 k yk zk of
      res::int
        = shrink_left (pop k v) cur if res == LT;
        = case del v ys of
            [y]  = if c===nil then (bin l z r) 0 y
                   else (shrink_center (\_ -> child snag y) (tri l w c z r) when
                        child@_ snag w = pop_left c
                   end);
            y:ys = (tri l (yk=>ys) c z r) 0 y;
          end if res == EQ;
        = shrink_center (pop k v) cur if res == LT2;
        = case del v zs of
            [z]  = if r===nil then (bin l y c) 0 z
                   else (shrink_right (\_ -> child snag z) (tri l y c w r) when
                        child@_ snag w = pop_left r
                   end);
            z:zs = (tri l y c (zk=>zs) r) 0 z;
          end if res == EQ2;
        = shrink_right (pop k v) cur if res == GT2;
    end;
end;

// for compatibility with avltrees

public mdeletek mdeletekv;
mdeletek t k = mdeleteko t k;
mdeletekv t old = mdeletekvo t old;

// Delete all members for a given key.

public mdeletea mdeleteka;

mdeletea t old = deletek t old;

mdeleteka t k = mdeletea t k;


/* Hashed trees, single value. */

public hinsert hinsertk;

hinsert t new = catch (whenfail t) (head2 $ ins (hash new) new t) with
    add new ws [] = new:ws; // adding new to front of list is less presure on GC
    add new _ (new:_) = throw fail; // keep existing tree
    add new ws (u:us) = add new ws us;
    ins h::int new nil = (bin nil (h=>[new]) nil) true; // bump height at prev level
    ins h::int new (bin l1 x1@(xh::int=>xs) r1) = case cmp h xh of
      res::int
        = case ins h new l1 of
            child@_ 0 = (bin child x1 r1) false;
            (bin l2 x2 r2) 1 = (tri l2 x2 r2 x1 r1) false;
          end if res == LT;
        = (bin l1 (xh=>add new xs xs) r1) false if res == EQ;
        = case ins h new r1 of
            child@_ 0 = (bin l1 x1 child) false;
            (bin l2 x2 r2) 1 = (tri l1 x1 l2 x2 r2) false;
          end if res == GT;
    end;
    ins h::int new (tri l1 y1@(yh::int=>ys) c1 z1@(zh::int=>zs) r1) = case cmp2 h yh zh of
      res::int
        = case ins h new l1 of
                child@_ 0 = (tri child y1 c1 z1 r1) false;
                child@_ 1 = (bin child y1 (bin c1 z1 r1)) true; // bump height at prev level
          end if res == LT;
        = (tri l1 (yh=>add new ys ys) c1 z1 r1) false if res == EQ;
        = case ins h new c1 of
                child@_ 0 = (tri l1 y1 child z1 r1) false;
                (bin l2 x2 r2) 1 = (bin (bin l1 y1 l2) x2 (bin r2 z1 r1)) true; // bump height at prev level
          end if res == LT2;
        = (tri l1 y1 c1 (zh=>add new zs zs) r1) false if res == EQ2;
        = case ins h new r1 of
            child@_ 0 = (tri l1 y1 c1 z1 child) false;
            child@_ 1 = (bin (bin l1 y1 c1) z1 child) true; // bump height at prev level
          end if res == GT2;
    end;
end;

hinsertk t new@(k=>_) = catch (whenfail t) (head2 $ ins (hash k) new t) with
    add new ws [] = new:ws; // adding new to front of list is less pressure on GC
    add new@(u=>v) ws ((u=>uv):us) = if v==?uv then throw fail // keep existing tree
                                     else new:reverse_onto us ws; // update value
    add new ws (u:us) = add new (u:ws) us;
    ins h::int new nil = (bin nil (h=>[new]) nil) true; // bump height at prev level
    ins h::int new (bin l1 x1@(xh::int=>xs) r1) = case cmp h xh of
      res::int
        = case ins h new l1 of
            child@_ 0 = (bin child x1 r1) false;
            (bin l2 x2 r2) 1 = (tri l2 x2 r2 x1 r1) false;
          end if res == LT;
        = (bin l1 (xh=>add new [] xs) r1) false if res == EQ;
        = case ins h new r1 of
            child@_ 0 = (bin l1 x1 child) false;
            (bin l2 x2 r2) 1 = (tri l1 x1 l2 x2 r2) false;
          end if res == GT;
    end;
    ins h::int new (tri l1 y1@(yh::int=>ys) c1 z1@(zh::int=>zs) r1) = case cmp2 h yh zh of
      res::int
        = case ins h new l1 of
                child@_ 0 = (tri child y1 c1 z1 r1) false;
                child@_ 1 = (bin child y1 (bin c1 z1 r1)) true; // bump height at prev level
          end if res == LT;
        = (tri l1 (yh=>add new [] ys) c1 z1 r1) false if res == EQ;
        = case ins h new c1 of
                child@_ 0 = (tri l1 y1 child z1 r1) false;
                (bin l2 x2 r2) 1 = (bin (bin l1 y1 l2) x2 (bin r2 z1 r1)) true; // bump height at prev level
          end if res == LT2;
        = (tri l1 y1 c1 (zh=>add new [] zs) r1) false if res == EQ2;
        = case ins h new r1 of
            child@_ 0 = (tri l1 y1 c1 z1 child) false;
            child@_ 1 = (bin (bin l1 y1 c1) z1 child) true; // bump height at prev level
          end if res == GT2;
    end;
end;

// These are also valid for multi-hashes.

public hdelete hdeletek hpopk;
public hdeletekv hpopkv;

hdelete t old = catch (whenfail t) (head3 $ pop (hash old) old t) with
    // custom version of deletel, that doesn't tolerate failure
    del _ _ [] = throw fail;
    del old ws (old:us) = reverse_onto us ws;
    del old ws (u:us) = del old (u:ws) us;
    pop h::int old nil = throw fail;
    pop h::int old cur@(bin l x@(xh::int=>xs) r) = case cmp h xh of
      res::int
        = shrink_left (pop h old) cur if res == LT;
        = case del old [] xs of
            [] = if r===nil then l 1 x
                 else (shrink_right (\_ -> child snag x) (bin l w r) when
                     child@_ snag w = pop_left r
                 end);
            xs = (bin l (xh=>xs) r) 0 x;
          end if res == EQ;
        = shrink_right (pop h old) cur if res == GT;
    end;
    pop h::int old cur@(tri l y@(yh::int=>ys) c z@(zh::int=>zs) r) = case cmp2 h yh zh of
      res::int
        = shrink_left (pop h old) cur if res == LT;
        = case del old [] ys of
            [] = if c===nil then (bin l z r) 0 y
                 else (shrink_center (\_ -> child snag y) (tri l w c z r) when
                     child@_ snag w = pop_left c
                 end);
            ys = (tri l (yh=>ys) c z r) 0 y;
          end if res == EQ;
        = shrink_center (pop h old) cur if res == LT2;
        = case del old [] zs of
            [] = if r===nil then (bin l y c) 0 z
                 else (shrink_right (\_ -> child snag z) (tri l y c w r) when
                     child@_ snag w = pop_left r
                 end);
            zs = (tri l y c (zh=>zs) r) 0 z;
          end if res == EQ2;
        = shrink_right (pop h old) cur if res == GT2;
    end;
end;

private base_hpopk;

hdeletek t k = catch (whenfail t) (head3 $ base_hpopk k t fail);

hpopk t k = {| v, child |} when
    child@_ _ (_=>v) = base_hpopk k t out_of_bounds;
end;

base_hpopk k t e = pop (hash k) k t with
    del k us = popl e (same k.key) us; // throw e if no hits
    pop h::int k nil = throw fail;
    pop h::int k cur@(bin l x@(xh::int=>xs) r) = case cmp h xh of
      res::int
        = shrink_left (pop h k) cur if res == LT;
        = case del k xs of
            [x]  = if r===nil then l 1 x
                   else (shrink_right (\_ -> child snag x) (bin l w r) when
                       child@_ snag w = pop_left r
                   end);
            x:xs = (bin l (xh=>xs) r) 0 x;
          end if res == EQ;
        = shrink_right (pop h k) cur if res == GT;
    end;
    pop h::int k cur@(tri l y@(yh::int=>ys) c z@(zh::int=>zs) r) = case cmp2 h yh zh of
      res::int
        = shrink_left (pop h k) cur if res == LT;
        = case del k ys of
            [y]  = if c===nil then (bin l z r) 0 y
                   else (shrink_center (\_ -> child snag y) (tri l w c z r) when
                       child@_ snag w = pop_left c
                   end);
            y:ys = (tri l (yh=>ys) c z r) 0 y;
          end if res == EQ;
        = shrink_center (pop h k) cur if res == LT2;
        = case del k zs of
            [z]  = if r===nil then (bin l y c) 0 z
                   else (shrink_right (\_ -> child snag z) (tri l y c w r) when
                       child@_ snag w = pop_left r
                   end);
            z:zs = (tri l y c (zh=>zs) r) 0 z;
          end if res == EQ2;
        = shrink_right (pop h k) cur if res == GT2;
    end;
end;

private base_hpopkv;

hdeletekv t old@(k=>_) = catch (whenfail t) (head3 $ base_hpopkv k old t fail);

// See comments to popkv on why this is needed.
hpopkv t old@(k=>_) = {| v, child |} when
    child@_ _ (_=>v) = base_hpopkv k old t out_of_bounds;
end;

base_hpopkv k old t e = pop (hash k) old t with
    // optimized popl
    del _ _ [] = throw e; // not found
    del (k=>v) ws (u@(k=>uv):us) = if v==?uv then u:reverse_onto us ws else throw e; // (k=>v) not found
    del old ws (u:us) = del old (u:ws) us;
    pop h::int old nil = throw e;
    pop h::int old cur@(bin l x@(xh::int=>xs) r) = case cmp h xh of
      res::int
        = shrink_left (pop h old) cur if res == LT;
        = case del old [] xs of
            [x]  = if r===nil then l 1 x
                   else (shrink_right (\_ -> child snag x) (bin l w r) when
                       child@_ snag w = pop_left r
                   end);
            x:xs = (bin l (xh=>xs) r) 0 x;
          end if res == EQ;
        = shrink_right (pop h old) cur if res == GT;
    end;
    pop h::int old cur@(tri l y@(yh::int=>ys) c z@(zh::int=>zs) r) = case cmp2 h yh zh of
      res::int
        = shrink_left (pop h old) cur if res == LT;
        = case del old [] ys of
            [y]  = if c===nil then (bin l z r) 0 y
                   else (shrink_center (\_ -> child snag y) (tri l w c z r) when
                       child@_ snag w = pop_left c
                   end);
            y:ys = (tri l (yh=>ys) c z r) 0 y;
          end if res == EQ;
        = shrink_center (pop h old) cur if res == LT2;
        = case del old [] zs of
            [z]  = if r===nil then (bin l y c) 0 z
                   else (shrink_right (\_ -> child snag z) (tri l y c w r) when
                       child@_ snag w = pop_left r
                   end);
            z:zs = (tri l y c (zh=>zs) r) 0 z;
          end if res == EQ2;
        = shrink_right (pop h old) cur if res == GT2;
    end;
end;


/* Hashed trees, multiple values. */

public mhinsert mhinsertk;

mhinsert t new = head2 $ ins (hash new) new t with
    ins h::int new nil = (bin nil (h=>[new]) nil) true; // bump height at prev level
    ins h::int new (bin l1 x1@(xh::int=>xs) r1) = case cmp h xh of
      res::int
        = case ins h new l1 of
            child@_ 0 = (bin child x1 r1) false;
            (bin l2 x2 r2) 1 = (tri l2 x2 r2 x1 r1) false;
          end if res == LT;
        = (bin l1 (xh=>new:xs) r1) false if res == EQ;
        = case ins h new r1 of
            child@_ 0 = (bin l1 x1 child) false;
            (bin l2 x2 r2) 1 = (tri l1 x1 l2 x2 r2) false;
          end if res == GT;
    end;
    ins h::int new (tri l1 y1@(yh::int=>ys) c1 z1@(zh::int=>zs) r1) = case cmp2 h yh zh of
      res::int
        = case ins h new l1 of
                child@_ 0 = (tri child y1 c1 z1 r1) false;
                child@_ 1 = (bin child y1 (bin c1 z1 r1)) true; // bump height at prev level
          end if res == LT;
        = (tri l1 (yh=>new:ys) c1 z1 r1) false if res == EQ;
        = case ins h new c1 of
                child@_ 0 = (tri l1 y1 child z1 r1) false;
                (bin l2 x2 r2) 1 = (bin (bin l1 y1 l2) x2 (bin r2 z1 r1)) true; // bump height at prev level
          end if res == LT2;
        = (tri l1 y1 c1 (zh=>new:zs) r1) false if res == EQ2;
        = case ins h new r1 of
            child@_ 0 = (tri l1 y1 c1 z1 child) false;
            child@_ 1 = (bin (bin l1 y1 c1) z1 child) true; // bump height at prev level
          end if res == GT2;
    end;
end;

mhinsertk t new@(k=>_) = head2 $ ins (hash k) new t with
    ins h::int new nil = (bin nil (h=>[new]) nil) true; // bump height at prev level
    ins h::int new (bin l1 x1@(xh::int=>xs) r1) = case cmp h xh of
      res::int
        = case ins h new l1 of
            child@_ 0 = (bin child x1 r1) false;
            (bin l2 x2 r2) 1 = (tri l2 x2 r2 x1 r1) false;
          end if res == LT;
        = (bin l1 (xh=>new:xs) r1) false if res == EQ;
        = case ins h new r1 of
            child@_ 0 = (bin l1 x1 child) false;
            (bin l2 x2 r2) 1 = (tri l1 x1 l2 x2 r2) false;
          end if res == GT;
    end;
    ins h::int new (tri l1 y1@(yh::int=>ys) c1 z1@(zh::int=>zs) r1) = case cmp2 h yh zh of
      res::int
        = case ins h new l1 of
                child@_ 0 = (tri child y1 c1 z1 r1) false;
                child@_ 1 = (bin child y1 (bin c1 z1 r1)) true; // bump height at prev level
          end if res == LT;
        = (tri l1 (yh=>new:ys) c1 z1 r1) false if res == EQ;
        = case ins h new c1 of
                child@_ 0 = (tri l1 y1 child z1 r1) false;
                (bin l2 x2 r2) 1 = (bin (bin l1 y1 l2) x2 (bin r2 z1 r1)) true; // bump height at prev level
          end if res == LT2;
        = (tri l1 y1 c1 (zh=>new:zs) r1) false if res == EQ2;
        = case ins h new r1 of
            child@_ 0 = (tri l1 y1 c1 z1 child) false;
            child@_ 1 = (bin (bin l1 y1 c1) z1 child) true; // bump height at prev level
          end if res == GT2;
    end;
end;

public mhdelete mhdeleteko mhdeletekn mhpopko mhpopkn;
public mhdeletekvo mhdeletekvn mhdeletekva mhpopkva;

// mhdelete deletes the first (newest) match, which will be === old (not merely EQ, as with mdelete).

mhdelete        t old = hdelete   t old;

// The mh*n functions pop the first (newest) match.

mhdeletekn     t k   = hdeletek  t k;
mhpopkn        t k   = hpopk     t k;

mhdeletekvo t old@(k=>_) = catch (whenfail t) (head3 $ pop (hash k) old t) with
    del (k=>v) us = popr fail (\(uk=>uv) -> k===uk && v==?uv) us; // throw fail if no hits
    pop h::int old nil = throw fail;
    pop h::int old cur@(bin l x@(xh::int=>xs) r) = case cmp h xh of
      res::int
        = shrink_left (pop h old) cur if res == LT;
        = case del old xs of
            [x]  = if r===nil then l 1 x
                   else (shrink_right (\_ -> child snag x) (bin l w r) when
                       child@_ snag w = pop_left r
                   end);
            x:xs = (bin l (xh=>xs) r) 0 x;
          end if res == EQ;
        = shrink_right (pop h old) cur if res == GT;
    end;
    pop h::int old cur@(tri l y@(yh::int=>ys) c z@(zh::int=>zs) r) = case cmp2 h yh zh of
      res::int
        = shrink_left (pop h old) cur if res == LT;
        = case del old ys of
            [y]  = if c===nil then (bin l z r) 0 y
                   else (shrink_center (\_ -> child snag y) (tri l w c z r) when
                       child@_ snag w = pop_left c
                   end);
            y:ys = (tri l (yh=>ys) c z r) 0 y;
          end if res == EQ;
        = shrink_center (pop h old) cur if res == LT2;
        = case del old zs of
            [z]  = if r===nil then (bin l y c) 0 z
                   else (shrink_right (\_ -> child snag z) (tri l y c w r) when
                       child@_ snag w = pop_left r
                   end);
            z:zs = (tri l y c (zh=>zs) r) 0 z;
          end if res == EQ2;
        = shrink_right (pop h old) cur if res == GT2;
    end;
end;

mhdeletekvn t old@(k=>_) = catch (whenfail t) (head3 $ pop (hash k) old t) with
    // unlike hdeletekv, we continue searching when keys match but values don't
    del (k=>v) us = popl fail (\(uk=>uv) -> k===uk && v==?uv) us; // throw fail if no hits
    pop h::int old nil = throw fail;
    pop h::int old cur@(bin l x@(xh::int=>xs) r) = case cmp h xh of
      res::int
        = shrink_left (pop h old) cur if res == LT;
        = case del old xs of
            [x]  = if r===nil then l 1 x
                   else (shrink_right (\_ -> child snag x) (bin l w r) when
                       child@_ snag w = pop_left r
                   end);
            x:xs = (bin l (xh=>xs) r) 0 x;
          end if res == EQ;
        = shrink_right (pop h old) cur if res == GT;
    end;
    pop h::int old cur@(tri l y@(yh::int=>ys) c z@(zh::int=>zs) r) = case cmp2 h yh zh of
      res::int
        = shrink_left (pop h old) cur if res == LT;
        = case del old ys of
            [y]  = if c===nil then (bin l z r) 0 y
                   else (shrink_center (\_ -> child snag y) (tri l w c z r) when
                       child@_ snag w = pop_left c
                   end);
            y:ys = (tri l (yh=>ys) c z r) 0 y;
          end if res == EQ;
        = shrink_center (pop h old) cur if res == LT2;
        = case del old zs of
            [z]  = if r===nil then (bin l y c) 0 z
                   else (shrink_right (\_ -> child snag z) (tri l y c w r) when
                       child@_ snag w = pop_left r
                   end);
            z:zs = (tri l y c (zh=>zs) r) 0 z;
          end if res == EQ2;
        = shrink_right (pop h old) cur if res == GT2;
    end;
end;

// The mh*o functions pop the last (oldest) match.

private base_mhpopko;

mhdeleteko t k = catch (whenfail t) (head3 $ base_mhpopko k t fail);

mhpopko t k = {| v, child |} when
    child@_ _ (_=>v) = base_mhpopko k t out_of_bounds;
end;

base_mhpopko k t e = pop (hash k) k t with
    del k us = popr fail (same k.key) us; // throw fail if no hits
    pop h::int k nil = throw e;
    pop h::int k cur@(bin l x@(xh::int=>xs) r) = case cmp h xh of
      res::int
        = shrink_left (pop h k) cur if res == LT;
        = case del k xs of
            [x]  = if r===nil then l 1 x
                   else (shrink_right (\_ -> child snag x) (bin l w r) when
                       child@_ snag w = pop_left r
                   end);
            x:xs = (bin l (xh=>xs) r) 0 x;
          end if res == EQ;
        = shrink_right (pop h k) cur if res == GT;
    end;
    pop h::int k cur@(tri l y@(yh::int=>ys) c z@(zh::int=>zs) r) = case cmp2 h yh zh of
      res::int
        = shrink_left (pop h k) cur if res == LT;
        = case del k ys of
            [y]  = if c===nil then (bin l z r) 0 y
                   else (shrink_center (\_ -> child snag y) (tri l w c z r) when
                       child@_ snag w = pop_left c
                   end);
            y:ys = (tri l (yh=>ys) c z r) 0 y;
          end if res == EQ;
        = shrink_center (pop h k) cur if res == LT2;
        = case del k zs of
            [z]  = if r===nil then (bin l y c) 0 z
                   else (shrink_right (\_ -> child snag z) (tri l y c w r) when
                       child@_ snag w = pop_left r
                   end);
            z:zs = (tri l y c (zh=>zs) r) 0 z;
          end if res == EQ2;
        = shrink_right (pop h k) cur if res == GT2;
    end;
end;

private base_mhpopkva;

mhdeletekva t old@(k=>_) = catch (whenfail t) (head3 $ base_mhpopkva k old t fail);

// See comments to popkv on why this is needed.
mhpopkva t old@(k=>_) = {| vs, child |} when
    child@_ _ vs = base_mhpopkva k old t out_of_bounds;
    // extract values and reverse
    vs = ::foldl (flip((:).val)) [] vs;
end;

base_mhpopkva k old t e = pop (hash k) old t with
    del (k=>v) us = splitby (\(uk=>uv) -> k===uk && v==?uv) us;
    pop h::int old nil = throw e;
    pop h::int old cur@(bin l x@(xh::int=>xs) r) = case cmp h xh of
      res::int
        = shrink_left (pop h old) cur if res == LT;
        = case del old xs of
            [x]  = if r===nil then l 1 x
                   else (shrink_right (\_ -> child snag x) (bin l w r) when
                       child@_ snag w = pop_left r
                   end);
            x:xs = (bin l (xh=>xs) r) 0 x;
          end if res == EQ;
        = shrink_right (pop h old) cur if res == GT;
    end;
    pop h::int old cur@(tri l y@(yh::int=>ys) c z@(zh::int=>zs) r) = case cmp2 h yh zh of
      res::int
        = shrink_left (pop h old) cur if res == LT;
        = case del old ys of
            [y]  = if c===nil then (bin l z r) 0 y
                   else (shrink_center (\_ -> child snag y) (tri l w c z r) when
                       child@_ snag w = pop_left c
                   end);
            y:ys = (tri l (yh=>ys) c z r) 0 y;
          end if res == EQ;
        = shrink_center (pop h old) cur if res == LT2;
        = case del old zs of
            [z]  = if r===nil then (bin l y c) 0 z
                   else (shrink_right (\_ -> child snag z) (tri l y c w r) when
                       child@_ snag w = pop_left r
                   end);
            z:zs = (tri l y c (zh=>zs) r) 0 z;
          end if res == EQ2;
        = shrink_right (pop h old) cur if res == GT2;
    end;
end;

// for compatibility with avltrees

public mhdeletek mhdeletekv;
mhdeletek t k = mhdeleteko t k;
mhdeletekv t old = mhdeletekvo t old;

public mhdeletea mhdeleteka;

mhdeletea t old = catch (whenfail t) (head3 $ pop (hash old) old t) with
    pop h::int old nil = throw fail;
    pop h::int old cur@(bin l x@(xh::int=>xs) r) = case cmp h xh of
      res::int
        = shrink_left (pop h old) cur if res == LT;
        = case filter (~==old) xs of
            [] = if r===nil then l 1 x
                 else (shrink_right (\_ -> child snag x) (bin l w r) when
                     child@_ snag w = pop_left r
                 end);
            xs = (bin l (xh=>xs) r) 0 x;
          end if res == EQ;
        = shrink_right (pop h old) cur if res == GT;
    end;
    pop h::int old cur@(tri l y@(yh::int=>ys) c z@(zh::int=>zs) r) = case cmp2 h yh zh of
      res::int
        = shrink_left (pop h old) cur if res == LT;
        = case filter (~==old) ys of
            [] = if c===nil then (bin l z r) 0 y
                 else (shrink_center (\_ -> child snag y) (tri l w c z r) when
                     child@_ snag w = pop_left c
                 end);
            ys = (tri l (yh=>ys) c z r) 0 y;
          end if res == EQ;
        = shrink_center (pop h old) cur if res == LT2;
        = case filter (~==old) zs of
            [] = if r===nil then (bin l y c) 0 z
                 else (shrink_right (\_ -> child snag z) (tri l y c w r) when
                     child@_ snag w = pop_left r
                 end);
            zs = (tri l y c (zh=>zs) r) 0 z;
          end if res == EQ2;
        = shrink_right (pop h old) cur if res == GT2;
    end;
end;

mhdeleteka t k = catch (whenfail t) (head3 $ pop (hash k) k t) with
    pop h::int k nil = throw fail;
    pop h::int k cur@(bin l x@(xh::int=>xs) r) = case cmp h xh of
      res::int
        = shrink_left (pop h k) cur if res == LT;
        = case filter (\(uk=>_) -> uk~==k) xs of
            [] = if r===nil then l 1 x
                 else (shrink_right (\_ -> child snag x) (bin l w r) when
                     child@_ snag w = pop_left r
                 end);
            xs = (bin l (xh=>xs) r) 0 x;
          end if res == EQ;
        = shrink_right (pop h k) cur if res == GT;
    end;
    pop h::int k cur@(tri l y@(yh::int=>ys) c z@(zh::int=>zs) r) = case cmp2 h yh zh of
      res::int
        = shrink_left (pop h k) cur if res == LT;
        = case filter (\(uk=>_) -> uk~==k) ys of
            [] = if c===nil then (bin l z r) 0 y
                 else (shrink_center (\_ -> child snag y) (tri l w c z r) when
                     child@_ snag w = pop_left c
                 end);
            ys = (tri l (yh=>ys) c z r) 0 y;
          end if res == EQ;
        = shrink_center (pop h k) cur if res == LT2;
        = case filter (\(uk=>_) -> uk~==k) zs of
            [] = if r===nil then (bin l y c) 0 z
                 else (shrink_right (\_ -> child snag z) (tri l y c w r) when
                     child@_ snag w = pop_left r
                 end);
            zs = (tri l y c (zh=>zs) r) 0 z;
          end if res == EQ2;
        = shrink_right (pop h k) cur if res == GT2;
    end;
end;


/* Private helper functions. */

shrink_left aux (bin l1 x1 r1) = case aux l1 of
    child@_ 0 w = (bin child x1 r1) false w;
    child@_ 1 w = case r1 of
        bin l2 x2 r2 = (tri child x1 l2 x2 r2) true w; // pass snag upwards
        tri l2 y2 c2 z2 r2 = (bin (bin child x1 l2) y2 (bin c2 z2 r2)) false w;
    end;
end;

shrink_left aux (tri l1 y1 c1 z1 r1) = case aux l1 of
    child@_ 0 w = (tri child y1 c1 z1 r1) false w;
    child@_ 1 w = case c1 of
        bin l2 x2 r2 = (bin (tri child y1 l2 x2 r2) z1 r1) false w;
        tri l2 y2 c2 z2 r2 = (tri (bin child y1 l2) y2 (bin c2 z2 r2) z1 r1) false w;
    end;
end;

shrink_center aux (tri l1 y1 c1 z1 r1) = case aux c1 of
    child@_ 0 w = (tri l1 y1 child z1 r1) false w;
    child@_ 1 w = case l1 of // we arbitrarily chose to decons the left side
        bin l2 x2 r2 = (bin (tri l2 x2 r2 y1 child) z1 r1) false w;
        tri l2 y2 c2 z2 r2 = (tri (bin l2 y2 c2) z2 (bin r2 y1 child) z1 r1) false w;
    end;
end;

shrink_right aux (bin l1 x1 r1) = case aux r1 of
    child@_ 0 w = (bin l1 x1 child) false w;
    child@_ 1 w = case l1 of
        bin l2 x2 r2 = (tri l2 x2 r2 x1 child) true w; // pass snag upwards
        tri l2 y2 c2 z2 r2 = (bin (bin l2 y2 c2) z2 (bin r2 x1 child)) false w;
    end;
end;

shrink_right aux (tri l1 y1 c1 z1 r1) = case aux r1 of
    child@_ 0 w = (tri l1 y1 c1 z1 child) false w;
    child@_ 1 w = case c1 of
        bin l2 x2 r2 = (bin l1 y1 (tri l2 x2 r2 z1 child)) false w;
        tri l2 y2 c2 z2 r2 = (tri l1 y1 (bin l2 y2 c2) z2 (bin r2 z1 child)) false w;
    end;
end;

pop_left (bin nil x nil) = nil true x; // snag height at prev level

pop_left (tri nil y nil z nil) = (bin nil z nil) false y;

pop_left cur = shrink_left pop_left cur;

pop_right (bin nil x nil) = nil true x; // snag height at prev level

pop_right (tri nil y nil z nil) = (bin nil y nil) false z;

pop_right cur = shrink_right pop_right cur;

mpop_left (bin nil (xk=>xs) nil) = case xs of
    [x] = nil true x; // snag height at prev level
    x:xs = (bin nil (xk=>xs) nil) false x;
end;

mpop_left (tri nil (yk=>ys) nil z nil) = case ys of
    [y] = (bin nil z nil) false y;
    y:ys = (tri nil (yk=>ys) nil z nil) false y;
end;

mpop_left cur = shrink_left mpop_left cur;

mpop_right (bin nil (xk=>xs) nil) = case xs of
    [x] = nil true x; // snag height at prev level
    x:xs = (bin nil (xk=>xs) nil) false x;
end;

mpop_right (tri nil y nil (zk=>zs) nil) = case zs of
    [z] = (bin nil y nil) false z;
    z:zs = (tri nil y nil (zk=>zs) nil) false z;
end;

mpop_right cur = shrink_right mpop_right cur;



// Optimised key comparison.

cmp a::string b::string | cmp1 a::string b::string =
    // from http://graphics.stanford.edu/~seander/bithacks.html
    // sign = (v > 0) - (v < 0); // -1, 0, or +1
    if res<0 then LT else if res>0 then GT else EQ when res = __C::strcmp a b end;
cmp a::bigint b::bigint | cmp1 a::bigint b::bigint = __C::bigint_cmp a b;
cmp a::int b::int | cmp a::double b::double |
cmp1 a::int b::int | cmp1 a::double b::double =
    if a<b then LT else if b<a then GT else EQ;
// Other objects. Undefined orderings will throw failed_cond.
cmp a b = if a<b then LT else if b<a then GT else EQ;
cmp1 a b = if a<b then LT else GE;

cmp2 a::string b::string c::string |
cmp3 a::string b::string c::string =
    if res>0 then
        (if res2>0 then GT2 else if res2<0 then LT2 else EQ2 when
            res2 = __C::strcmp a c
        end)
    else if res<0 then LT else EQ when
            res = __C::strcmp a b
        end;
cmp2 a::bigint b::bigint c::bigint |
cmp3 a::bigint b::bigint c::bigint =
    if res > 0 then EQ2 + __C::bigint_cmp a c else res when res = __C::bigint_cmp a b end;
cmp2 a::int b::int c::int | cmp2 a::double b::double c::double |
cmp3 a::int b::int c::int | cmp3 a::double b::double c::double =
    if a<b then LT else if b<a then (if a<c then LT2 else if c<a then GT2 else EQ2) else EQ;
cmp2 a b c = if a<b then LT else if b<a then (if a<c then LT2 else if c<a then GT2 else EQ2) else EQ;
cmp3 a b c = if a<b then LT else (if a<c then MID else GE2);


// extract head from ins pairs
head2 (t@_ _) = t;

// extract head from the pop/shrink triples
head3 (t@_ _ _) = t;

// catch failures
whenfail v = handle with
    handle fail = v;
    handle e = throw e;
end;

// custom version of popl
// throws e when no hits, else leftmost p is rotated to head
popl e p xs = pop e p xs [] with
    pop e p [] _ = throw e;
    pop e p (x:xs) ws = x:reverse_onto xs ws if p x;
                      = pop e p xs (x:ws);
end;

// custom version of popr
// throws e when no hits, else rightmost p is rotated to head
popr e p xs = pop e p xs [] [] [] with
    pop e p []     _  []     _   = throw e;
    pop e p []     ms (h:hs) hss = h:aux (reverse ms) hs hss;
    pop e p (x:xs) ms hs     hss = pop e p xs [] (x:ms) (hs:hss) if p x;
                                 = pop e p xs (x:ms) hs hss otherwise;
    aux zs []     []       = zs;
    aux zs []     (xs:xss) = aux zs xs xss;
    aux zs (y:ys) xss      = aux (y:zs) ys xss;
end;

// custom version of splitby
splitby p ys = spl p ys [] [] with
    spl p []     _  [] = []:ys; // no hits, use original
    spl p []     ms hs = hs:reverse ms; // push reversed list of hits to front
    spl p (x:xs) ms hs = spl p xs ms (x:hs) if p x;
                       = spl p xs (x:ms) hs otherwise;
end;


// I derived the following display code from someone else, and have since
// ported it a number of times in my personal libraries. I *think* the
// original source is this Scheme display code by Marc Feeley:
// ftp://ftp.cs.indiana.edu/pub/scheme-repository/code/struct/tree.scm

spaces n = string (repeatn n " ");

center s width fill =
    if rem < 1 then s
    else string (repeatn (rem - rem div 2) fill) + s + string (repeatn (rem div 2) fill) when
    rem = width - #s
end;

__show__ t::tree = case t of
    nil = "emptytree";
    _ = (join "\n" (reverse lst)) + "\n";
end when
    lst, _, _ = recurse t true true
end with
    pad_length until width lines = aux (#lines) until lines with
        aux n until lines = if n < until then aux (n+1) until (spaces width : lines)
                            else lines
    end;
    recurse nil _ _ = [], 0, 0;
    recurse (bin left1 k1 right1) istop isleft =
    lines, pos, width when
        label = str k1;
        left_lines, left_pos, left_width = recurse left1 false true;
        right_lines, right_pos, right_width = recurse right1 false false;
        middle = max 2 (max (1 + right_pos + left_width - left_pos) (#label));
        pos = (left_pos + middle) div 2;
        width = (left_pos + middle + right_width) - right_pos;
        left_lines = pad_length (#right_lines) left_width left_lines;
        right_lines = pad_length (#left_lines) right_width right_lines;
        label2 = if 1 == (middle - #label) mod 2 && not istop && isleft &&
                 #label < middle then label + "." else label;
        label3 = center label2 middle ".";
        label3 = if label3!0 == "." then " " + label3!!(1..#label3-1) else label3;
        label3 = if label3!(#label3-1) == "." then label3!!(0..#label3-2) + " " else label3;
        a = spaces left_pos + label3 + spaces (right_width - right_pos);
        d = spaces left_pos + "/" + spaces (middle-2) + "\\" + spaces (right_width - right_pos);
        lines = zip_onto (\left_line right_line ->
                    left_line + spaces (width - left_width - right_width) +
                    right_line)
                [d, a] left_lines right_lines;
    end;
    recurse (tri left2 j2 center2 k2 right2) istop isleft =
    lines, pos, width when
        label = str j2 + "-" + str k2;
        left_lines, left_pos, left_width = recurse left2 false true;
        center_lines, center_pos, center_width = recurse center2 false true;
        right_lines, right_pos, right_width = recurse right2 false false;
        middle = max 2 (max ((2 + right_pos + center_width + left_width) - left_pos) (#label));
        pos = (left_pos + middle) div 2;
        width = (left_pos + middle + right_width) - right_pos;
        center_lines = pad_length (#right_lines) center_width center_lines;
        right_lines = pad_length (#center_lines) right_width right_lines;
        left_lines = pad_length (#center_lines) left_width left_lines;
        center_lines = pad_length (#left_lines) center_width center_lines;
        right_lines = pad_length (#left_lines) right_width right_lines;
        label2 = if 1 == (middle - #label) mod 2 && not istop && isleft &&
                 #label < middle then label + "." else label;
        label3 = center label2 middle ".";
        label3 = if label3!0 == "." then " " + label3!!(1..#label3-1) else label3;
        label3 = if label3!(#label3-1) == "." then label3!!(0..#label3-2) + " " else label3;
        a = spaces left_pos + label3 + spaces (right_width - right_pos);
        totalspace = middle - 3;
        spacer1 = totalspace div 2;
        d = spaces left_pos + "/" + spaces spacer1 + "|" +
            spaces (totalspace - spacer1) + "\\" + spaces (right_width - right_pos);
        totalspace = width - left_width - center_width - right_width;
        spacer1 = totalspace div 2;
        lines = zip3_onto (\left_line center_line right_line ->
                    left_line + spaces spacer1 + center_line +
                    spaces (totalspace - spacer1) + right_line)
                [d, a] left_lines center_lines right_lines;
    end;
end if 0; // disable pretty-printing of trees
