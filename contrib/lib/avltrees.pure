/* Generic AVL tree data structure for implementing sets, dictionaries,
   and the like. */

/* NOTE: This module implements just the raw AVL tree data structure. The
   provided operations are fairly low-level and not intended to be used
   directly in applications. You'd rather want to use the high-level
   interfaces in dict.pure and set.pure instead. */

/* Copyright (c) 2008-2012 by Albert Graef <Dr.Graef@t-online.de>.
   Copyright (c) 2008-2012 by Jiri Spitz <jiri.spitz@bluetone.cz>.
   Copyright (c) 2012 by Dubiousjim <dubiousjim@gmail.com>.

   This file is part of the Pure standard library.

   The Pure standard library is free software: you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
   more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* The used AVL tree algorithm has its origin in the SWI-Prolog implementation
   of association lists. The original implementation was created by
   R. A. O'Keefe and updated for SWI-Prolog by Jan Wielemaker. For the
   original source see http://www.swi-prolog.org. The port from SWI-Prolog and
   the deletion stuff (rmfirst, rmlast, delete) missing in the Prolog
   implementation was provided by Jiri Spitz. The generalization of the code
   to arbitrary combinations of ordered/hashed and single-/multi-valued keys
   was done by Albert Graef. */

#! --if trees23
namespace avl;
#! --else
namespace baltree;
#! --endif

/* Tree constructors: 'nil' denotes an empty tree, 'bin x balance left right'
   an interior node with the given balance factor and left and right subtrees.
   These are shared by all variations of the data structure. Depending on the
   particular type of data structure, the data element may take the form of a
   simple key (set-like), a key=>value pair (dictionary-like), or a
   key=>bucket pair (hash-like). The latter form is also used for multisets
   and multidicts where multiple elements may be stored under a single key.
   For hash trees no order of the key elements is assumed, and keys are only
   compared for syntactical equality. Keys in non-hash trees must be ordered,
   i.e., at least the comparison predicate '<' must be defined in a consistent
   fashion on them. In this case keys a and b are considered equal if neither
   a<b nor b<a holds. */

private nonfix nil fail;
private bin;

/* Private helper functions. */

private adjusti adjustd init rotate cmp;
private replace pickfirstby picklastby partition swap;

/* Operations to construct an empty tree, and to check for an empty tree.
   These are the same for all variations of the data structure. */

public emptytree null;

emptytree = nil;

null nil = 1;
null (bin _ _ _ _) = 0;

/* In the following, different operations are provided for the different kinds
   of trees, which are designated by corresponding prefixes: m denotes
   multiple values per key, h stands for hashed trees (m and h may be
   combined). In addition, the suffix k indicates an operation which is only
   available for dictionary (key=>value) trees. */

/* Basic AVL tree operations, single value per key. */

public foldl foldl1 foldr foldr1 all any;
public streamleft streamright;
public size members keys vals;
public first last rmfirst rmlast popfirst poplast;

// General folds. These take a w argument to wrap incoming elements
// before applying f.

foldl w f a t = tick a t with
    tick a nil = a;
    tick a (bin x _ l r) = tick (f (tick a l) (w x)) r;
end;

foldl1 w f t = tick fail t with
    tick fail (bin x _ nil _) = w x;
    tick a nil = a;
    tick a (bin x _ l r) = tick (f (tick a l) (w x)) r;
end if t~==nil;

foldr w f a t = tick t a with
    tick nil a = a;
    tick (bin x _ l r) a = tick l (f (w x) (tick r a));
end;

foldr1 w f t = tick t fail with
    tick (bin x _ _ nil) fail = w x;
    tick nil a = a;
    tick (bin x _ l r) a = tick l (f (w x) (tick r a));
end if t~==nil;

all p t  = tick t 1 with
    tick _ 0 = 0;
    tick nil a = a;
    tick (bin x _ l r) a = tick r (tick l (a && p x));
end;

any p nil = 0;
any p (bin x _ l r) = p x || any p l || any p r;

streamleft t = tick t with
    tick nil = []&;
    tick (bin x _ l r) = catstream [tick l, x:tick r&];
end;

streamright t = tick t with
    tick nil = []&;
    tick (bin x _ l r) = catstream [tick r, x:tick l&];
end;

// Compute the size of a tree.

size t = size t with
  size nil = 0;
  size (bin _ _ l r) = size l + size r + 1;
end;

// Get the list of all members.

members t = foldr id (:) [] t;

// Get the list of all keys and values. This requires a dictionary-like
// structure with separate key values.

keys t = foldr (::key) (:) [] t;

vals t = foldr (::val) (:) [] t;

// Get the first and the last member of a tree. Like head/last for [],
// the following two functions just fail to reduce when applied to nil.

first t = first t with
  first (bin x _ nil _) = x;
  first (bin _ _ l _) = first l;
end;

last t = last t with
  last (bin x _ _ nil) = x;
  last (bin _ _ _ r) = last r;
end;

// Remove the first and the last member from a tree.

rmfirst t = rmfirst t!0 with
  rmfirst nil = [nil, 0];
  rmfirst (bin _ _ nil r) = [r, 1];
  rmfirst (bin x b l r) = adjustd leftHasChanged (bin x b newl r) (-1)
    when [newl, leftHasChanged] = rmfirst l end;
end;

rmlast t = rmlast t!0 with
  rmlast nil = [nil, 0];
  rmlast (bin _ _ l nil) = [l, 1];
  rmlast (bin x b l r) = adjustd rightHasChanged (bin x b l newr) 1
    when [newr, rightHasChanged] = rmlast r end;
end;

popfirst nil = ();
popfirst t = case popfirst t of
  [y, t, _] = tuple2 y t;
end with
  popfirst (bin x _ nil r) = [x, r, 1];
  popfirst (bin x b l r) = y:adjustd leftHasChanged (bin x b newl r) (-1)
    when [y, newl, leftHasChanged] = popfirst l end;
end;

poplast nil = ();
poplast t = case poplast t of
  [y, t, _] = tuple2 y t;
end with
  poplast (bin x _ l nil) = [x, l, 1];
  poplast (bin x b l r) = y:adjustd rightHasChanged (bin x b l newr) 1
    when [y, newr, rightHasChanged] = poplast r end;
end;


/* Basic AVL tree operations, multiple values per key. */

public hfoldl hfoldl1 hfoldr hfoldr1;
public mfoldl mfoldl1 mfoldr mfoldr1 mall many;
public mstreamleft mstreamright;
public msize mmembers mkeys mvals;
public mfirst mlast mrmfirst mrmlast mpopfirst mpoplast;

mfoldl  f a t = hfoldl  id f a t;
mfoldl1 f   t = hfoldl1 id f   t;
mfoldr  f a t = hfoldr  id f a t;
mfoldr1 f   t = hfoldr1 id f   t;

mall p t  = tick t 1 with
    tick _ 0 = 0;
    tick nil a = a;
    tick (bin (_=>xs) _ l r) a = tick r (tick l (a && ::all p xs));
end;

many p nil = 0;
many p (bin (_=>xs) _ l r) = ::any p xs || many p l || many p r;

mstreamleft t = tick t with
    tick nil = []&;
    tick (bin (_=>xs) _ l r) = catstream [tick l, xs, tick r&];
end;

mstreamright t = tick t with
    tick nil = []&;
    tick (bin (_=>xs) _ l r) = catstream [tick r, reverse xs&, tick l&];
end;

msize t = size t with
  size nil = 0;
  size (bin (k=>xs) _ l r) = size l + size r + #xs;
end;

mmembers t = mfoldr (:) [] t;

mkeys t = foldr ::val (flip (map_onto ::key)) [] t;

mvals t = foldr ::val (flip (map_onto ::val)) [] t;

// Get the first and the last mmember of a tree. Like head/last for [],
// the following two functions just fail to reduce when applied to nil.

mfirst t = first t with
  first (bin (k=>xs) _ nil _) = head xs;
  first (bin _ _ l _) = first l;
end;

mlast t = last t with
  last (bin (k=>xs) _ _ nil) = ::last xs;
  last (bin _ _ _ r) = last r;
end;

// Remove the first and the last mmember from a tree.

mrmfirst t = rmfirst t!0 with
  rmfirst nil = [nil, 0];
  rmfirst (bin (k=>xs) b nil r)
    = if ::null newxs then [r, 1]
      else [bin (k=>newxs) b nil r, 0]
      when newxs = tail xs end;
  rmfirst (bin x b l r) = adjustd leftHasChanged (bin x b newl r) (-1)
    when [newl, leftHasChanged] = rmfirst l end;
end;

mrmlast t = rmlast t!0 with
  rmlast nil = [nil, 0];
  rmlast (bin (k=>xs) b l nil)
    = if ::null newxs then [l, 1]
      else [bin (k=>newxs) b l nil, 0]
      when newxs = ::init xs end;
  rmlast (bin x b l r) = adjustd rightHasChanged (bin x b l newr) 1
    when [newr, rightHasChanged] = rmlast r end;
end;

mpopfirst nil = ();
mpopfirst t = case popfirst t of
  [y, t, _] = tuple2 y t;
end with
  popfirst (bin (k=>xs) b nil r)
    = if ::null newxs then [x, r, 1]
      else [x, bin (k=>newxs) b nil r, 0]
      when x:newxs = xs end;
  popfirst (bin x b l r) = y:adjustd leftHasChanged (bin x b newl r) (-1)
    when [y, newl, leftHasChanged] = popfirst l end;
end;

mpoplast nil = ();
mpoplast t = case poplast t of
  [y, t, _] = tuple2 y t;
end with
  poplast (bin (k=>xs) b l nil)
    = if ::null newxs then [x, l, 1]
      else [x, bin (k=>newxs) b l nil, 0]
      when x:newxs = (::rotate 1) xs end;
  poplast (bin x b l r) = y:adjustd rightHasChanged (bin x b l newr) 1
    when [y, newr, rightHasChanged] = poplast r end;
end;


hfoldl w f a t = tick a t with
    tick a nil = a;
    tick a (bin (_=>xs) _ l r) = tick (::foldl fw (tick a l) xs) r;
    fw a x = f a (w x);
end;

hfoldl1 w f t = tick fail t with
    tick fail (bin (_=>(x:xs)) _ nil _) = ::foldl fw (w x) xs;
    tick a nil = a;
    tick a (bin (_=>xs) _ l r) = tick (::foldl fw (tick a l) xs) r;
    fw a x = f a (w x);
end if t~==nil;

hfoldr w f a t = tick t a with
    tick nil a = a;
    tick (bin (_=>xs) _ l r) a = tick l (::foldr fw (tick r a) xs);
    fw x a = f (w x) a;
end;

hfoldr1 w f t = tick t fail with
    tick (bin (_=>xs) _ _ nil) fail = ::foldr1 f (map w xs);
    tick nil a = a;
    tick (bin (_=>xs) _ l r) a = tick l (::foldr fw (tick r a) xs);
    fw x a = f (w x) a;
end if t~==nil;


/* The mtree functions also apply to all kinds of hash trees. For convenience and
   clarity, we define some corresponding synonyms here. */

public hall hany hstreamleft hstreamright;
public hsize hmembers hkeys hvals;
public hfirst hlast hrmfirst hrmlast hpopfirst hpoplast;

hall p t     = mall p t;
hany p t     = many p t;
hstreamleft t  = mstreamleft t;
hstreamright t = mstreamright t;
hsize t     = msize t;
hmembers t  = mmembers t;
hkeys t     = mkeys t;
hvals t     = mvals t;
hfirst t    = mfirst t;
hlast t     = mlast t;
hrmfirst t  = mrmfirst t;
hrmlast t   = mrmlast t;
hpopfirst t = mpopfirst t;
hpoplast t  = mpoplast t;

public mhfoldl mhfoldl1 mhfoldr mhfoldr1 mhall mhany;
public mhstreamleft mhstreamright;
public mhfoldlk mhfoldl1k mhfoldrk mhfoldr1k mhallk mhanyk;
public mhstreamleftk mhstreamrightk;

// for mtrees, one can use `all (p.(::val))` to test
// equal-keyed values all together; for mhtrees, special treatment is needed

mhfoldl f a t = tick a t with
    tick a nil = a;
    tick a (bin (_=>xs) _ l r) = tick (aux f (tick a l) xs) r;
    aux f a [] = a;
    aux f a (x:xs) = aux f (f a (x:xvs)) xs when
        xvs, xs = ::partition (x==?) xs;
    end;
end;

mhfoldl1 f t = tick fail t with
    tick fail (bin (_=>(x:xs)) _ nil r) = tick (aux f (x:xvs) xs) r when
        xvs, xs = ::partition (x==?) xs;
    end;
    tick a nil = a;
    tick a (bin (_=>xs) _ l r) = tick (aux f (tick a l) xs) r;
    aux f a [] = a;
    aux f a (x:xs) = aux f (f a (x:xvs)) xs when
        xvs, xs = ::partition (x==?) xs;
    end;
end if t~==nil;

mhfoldr f a t = tick t a with
    tick nil a = a;
    tick (bin (_=>xs) _ l r) a = tick l (aux f (tick r a) xs);
    aux f a [] = a;
    aux f a (x:xs) = f (x:xvs) (aux f a xs) when
        xvs, xs = ::partition (x==?) xs;
    end;
end;

mhfoldr1 f t = tick t fail with
    tick (bin (_=>xs) _ l nil) fail = tick l (aux1 f xs);
    tick nil a = a;
    tick (bin (_=>xs) _ l r) a = tick l (aux f (tick r a) xs);
    aux1 f (x:xs) = case xs of
        [] = x:xvs;
        _ = f (x:xvs) (aux1 f xs);
    end when
        xvs, xs = ::partition (x==?) xs;
    end;
    aux f a [] = a;
    aux f a (x:xs) = f (x:xvs) (aux f a xs) when
        xvs, xs = ::partition (x==?) xs;
    end;
end if t~==nil;

mhall p t  = tick t 1 with
    tick _ 0 = 0;
    tick nil a = a;
    tick (bin (_=>xs) _ l r) a = tick r (tick l (a && aux xs 1));
    aux _ 0 = 0;
    aux [] a = a;
    aux (x:xs) a = aux xs (a && p (x:xvs)) when
        xvs, xs = ::partition (x==?) xs;
    end;
end;

mhany p t = tick t with
    tick nil = 0;
    tick (bin (_=>xs) _ l r) = aux xs || tick l || tick r;
    aux [] = 0;
    aux (x:xs) = p (x:xvs) || aux xs when
        xvs, xs = ::partition (x==?) xs;
    end;
end;

mhstreamleft t = tick t with
    tick nil = []&;
    tick (bin (_=>xs) _ l r) = cat [tick l, aux xs&, tick r&];
    aux [] = [];
    aux (x:xs) = (x:xvs):aux xs& when
        xvs, xs = ::partition (x==?) xs;
    end;
end;

mhstreamright t = tick t with
    tick nil = []&;
    tick (bin (_=>xs) _ l r) = cat [tick r, aux (reverse xs)&, tick l&];
    aux [] = [];
    aux (x:xs) = (x:xvs):aux xs& when
        xvs, xs = ::partition (x==?) xs;
    end;
end;

// mhfold*s for dictionaries

mhfoldlk f a t = tick a t with
    tick a nil = a;
    tick a (bin (_=>xs) _ l r) = tick (aux f (tick a l) xs) r;
    aux f a [] = a;
    aux f a ((xk=>xv):xs) = aux f (f a (xk=>xvs)) xs when
        xvs, xs = ::partition (same xk.(::key)) xs;
        xvs = xv:map ::val xvs;
    end;
end;

mhfoldl1k f t = tick fail t with
    tick fail (bin (_=>((xk=>xv):xs)) _ nil r) = tick (aux f (xk=>xvs) xs) r when
        xvs, xs = ::partition (same xk.(::key)) xs;
        xvs = xv:map ::val xvs;
    end;
    tick a nil = a;
    tick a (bin (_=>xs) _ l r) = tick (aux f (tick a l) xs) r;
    aux f a [] = a;
    aux f a ((xk=>xv):xs) = aux f (f a (xk=>xvs)) xs when
        xvs, xs = ::partition (same xk.(::key)) xs;
        xvs = xv:map ::val xvs;
    end;
end if t~==nil;

mhfoldrk f a t = tick t a with
    tick nil a = a;
    tick (bin (_=>xs) _ l r) a = tick l (aux f (tick r a) xs);
    aux f a [] = a;
    aux f a ((xk=>xv):xs) = f (xk=>xvs) (aux f a xs) when
        xvs, xs = ::partition (same xk.(::key)) xs;
        xvs = xv:map ::val xvs;
    end;
end;

mhfoldr1k f t = tick t fail with
    tick (bin (_=>xs) _ l nil) fail = tick l (aux1 f xs);
    tick nil a = a;
    tick (bin (_=>xs) _ l r) a = tick l (aux f (tick r a) xs);
    aux1 f ((xk=>xv):xs) = case xs of
        [] = xk=>xvs;
        _ = f (xk=>xvs) (aux1 f xs);
    end when
        xvs, xs = ::partition (same xk.(::key)) xs;
        xvs = xv:map ::val xvs;
    end;
    aux f a [] = a;
    aux f a ((xk=>xv):xs) = f (xk=>xvs) (aux f a xs) when
        xvs, xs = ::partition (same xk.(::key)) xs;
        xvs = xv:map ::val xvs;
    end;
end if t~==nil;

mhallk p t  = tick t 1 with
    tick _ 0 = 0;
    tick nil a = a;
    tick (bin (_=>xs) _ l r) a = tick r (tick l (a && aux xs 1));
    aux _ 0 = 0;
    aux [] a = a;
    aux ((xk=>xv):xs) a = aux xs (a && p (xk=>xvs)) when
        xvs, xs = ::partition (same xk.(::key)) xs;
        xvs = xv:map ::val xvs;
    end;
end;

mhanyk p t = tick t with
    tick nil = 0;
    tick (bin (_=>xs) _ l r) = aux xs || tick l || tick r;
    aux [] = 0;
    aux ((xk=>xv):xs) = p (xk=>xvs) || aux xs when
        xvs, xs = ::partition (same xk.(::key)) xs;
        xvs = xv:map ::val xvs;
    end;
end;

mhstreamleftk t = tick t with
    tick nil = []&;
    tick (bin (_=>xs) _ l r) = cat [tick l, aux xs&, tick r&];
    aux [] = [];
    aux ((xk=>xv):xs) = (xk=>xvs):aux xs& when
        xvs, xs = ::partition (same xk.(::key)) xs;
        xvs = xv:map ::val xvs;
    end;
end;

mhstreamrightk t = tick t with
    tick nil = []&;
    tick (bin (_=>xs) _ l r) = cat [tick r, aux (reverse xs)&, tick l&];
    aux [] = [];
    aux ((xk=>xv):xs) = (xk=>xvs):aux xs& when
        xvs, xs = ::partition (same xk.(::key)) xs;
        xvs = xv:map ::val xvs;
    end;
end;

/* Membership test for ordered sets and dictionaries. */

public member memberk;

member t y = member t y with
  member nil _ = 0;
  member (bin x _ l r) y
    = case cmp x y of
        res::int
          = member l y if res>0;
          = member r y if res<0;
          = 1;
      end;
end;

memberk t y = member t y with
  member nil _ = 0;
  member (bin (x=>v) _ l r) y
    = case cmp x y of
        res::int
          = member l y if res>0;
          = member r y if res<0;
          = 1;
      end;
end;

/* Membership test for hashed sets and dictionaries. */

public hmember hmemberk;

hmember t y = member t (hash y) y with
  member nil _ _ = 0;
  member (bin (k::int=>xs) _ l r) key::int y
    = member l key y if k > key;
    = member r key y if k < key;
    = ::any (same y) xs;
end;

hmemberk t y = member t (hash y) y with
  member nil _ _ = 0;
  member (bin (k::int=>xs) _ l r) key::int y
    = member l key y if k > key;
    = member r key y if k < key;
    = ::any (same y.(::key)) xs;
end;

/* Indexing for ordered dictionaries. An out_of_bounds exception is thrown if
   the key doesn't exist in the tree. */

public getk;

getk t y = get t y with
  get nil _ = throw out_of_bounds;
  get (bin (x=>v) _ l r) y
    = case cmp x y of
        res::int
          = get l y if res>0;
          = get r y if res<0;
          = v;
      end;
end;

/* Indexing for ordered multidicts. mgetka always returns the list of all
   members for the given key, which may be empty if the key is not in the
   tree. mgetko returns the "oldest" value for the given k, and mgetkn
   returns the "newest" (most recently added) value. The latter two
   functions throw an out_of_bounds exception if the key doesn't exist
   in the tree.
*/

public mgetka mgetko mgetkn;

mgetka t y = get t y with
  get nil _ = [];
  get (bin (x=>xs) _ l r) y
    = case cmp x y of
        res::int
          = get l y if res>0;
          = get r y if res<0;
          = map ::val xs;
      end;
end;

mgetko t y = get t y with
  get nil _ = throw out_of_bounds;
  get (bin (x=>xs) _ l r) y
    = case cmp x y of
        res::int
          = get l y if res>0;
          = get r y if res<0;
          = ::val (head xs);
      end;
end;

mgetkn t y = get t y with
  get nil _ = throw out_of_bounds;
  get (bin (x=>xs) _ l r) y
    = case cmp x y of
        res::int
          = get l y if res>0;
          = get r y if res<0;
          = ::val (::last xs);
      end;
end;

/* Indexing for hashed (multi-)dicts. */

public hgetk mhgetka mhgetko mhgetkn;

hgetk t y = get t (hash y) y with
  get nil _ _ = throw out_of_bounds;
  get (bin (k::int=>xs) _ l r) key::int y
    = get l key y if k > key;
    = get r key y if k < key;
    = case dropwhile (\(x=>_) -> x~==y) xs of
        (x=>v):_ = v; _ = throw out_of_bounds;
      end;
end;

mhgetka t y = get t (hash y) y with
  get nil _ _ = [];
  get (bin (k::int=>xs) _ l r) key::int y
    = get l key y if k > key;
    = get r key y if k < key;
    = [v | x=>v = xs; x===y];
end;

mhgetko t y = get t (hash y) y with
  get nil _ _ = throw out_of_bounds;
  get (bin (k::int=>xs) _ l r) key::int y
    = get l key y if k > key;
    = get r key y if k < key;
    = case ::firstby (same y.(::key)) fail xs of
        fail = throw out_of_bounds;
        _=>v = v;
      end;
end;

mhgetkn t y = get t (hash y) y with
  get nil _ _ = throw out_of_bounds;
  get (bin (k::int=>xs) _ l r) key::int y
    = get l key y if k > key;
    = get r key y if k < key;
    = case ::lastby (same y.(::key)) fail xs of
        fail = throw out_of_bounds;
        _=>v = v;
      end;
end;

/* AVL tree insertion and deletion. */

/* Ordered case, single value. */

public insert insertk;

insert t y = insert t y!0 with
  insert nil y = [bin y 0 nil nil, 1];
  insert (bin x@k b l r) y@key
    = case cmp key k of
        res::int
	  = adjusti leftHasChanged (bin x b newl r) (-1)
            when [newl, leftHasChanged] = insert l y end if res < 0;
          = adjusti rightHasChanged (bin x b l newr) 1
            when [newr, rightHasChanged] = insert r y end if res > 0;
          = [bin y b l r, 0];
      end;
end;

insertk t y@(key=>val) = insert t y!0 with
  insert nil y = [bin y 0 nil nil, 1];
  insert (bin x@(k=>v) b l r) y@(key=>val)
    = case cmp key k of
        res::int
          = adjusti leftHasChanged (bin x b newl r) (-1)
            when [newl, leftHasChanged] = insert l y end if res < 0;
          = adjusti rightHasChanged (bin x b l newr) 1
            when [newr, rightHasChanged] = insert r y end if res > 0;
          = [bin y b l r, 0];
      end;
end;

public delete deletek deletekv popk popkv;

delete t y = delete t y!0 with
  delete nil _ = [nil, 0];
  delete (bin x@k b l r) y@key
    = case cmp key k of
        res::int
          = adjustd leftHasChanged (bin x b newl r) (-1)
            when [newl, leftHasChanged] = delete l y end if res < 0;
          = adjustd rightHasChanged (bin x b l newr) 1
            when [newr, rightHasChanged] = delete r y end if res > 0;
          = if l===nil then [r, 1]
            else if r===nil then [l, 1]
            else (adjustd leftHasChanged (bin (last l) b newl r) (-1)
      	    	  when [newl, leftHasChanged] = init l end);
      end;
end;

deletek t y = delete t y!0 with
  delete nil _ = [nil, 0];
  delete (bin x@(k=>_) b l r) y@key
    = case cmp key k of
        res::int
          = adjustd leftHasChanged (bin x b newl r) (-1)
            when [newl, leftHasChanged] = delete l y end if res < 0;
          = adjustd rightHasChanged (bin x b l newr) 1
            when [newr, rightHasChanged] = delete r y end if res > 0;
          = if l===nil then [r, 1]
            else if r===nil then [l, 1]
            else (adjustd leftHasChanged (bin (last l) b newl r) (-1)
      	    	  when [newl, leftHasChanged] = init l end);
      end;
end;

popk t y = case pop t y of
  [fail, _, _] = ();
  [v, t, _] = tuple2 v t;
end with
  pop nil _ = [fail, nil, 0];
  pop (bin x@(k=>v) b l r) y@key
    = case cmp key k of
        res::int
          = v:adjustd leftHasChanged (bin x b newl r) (-1)
            when [v, newl, leftHasChanged] = pop l y end if res < 0;
          = v:adjustd rightHasChanged (bin x b l newr) 1
            when [v, newr, rightHasChanged] = pop r y end if res > 0;
          = if l===nil then [v, r, 1]
            else if r===nil then [v, l, 1]
            else (v:adjustd leftHasChanged (bin (last l) b newl r) (-1)
                when [newl, leftHasChanged] = init l end);
      end;
end;


// Delete one specific key=>val pair.
deletekv t y@(key=>val) = delete t y!0 with
  delete nil _ = [nil, 0];
  delete t@(bin x@(k=>v) b l r) y@(key=>val)
    = case cmp key k of
        res::int
          = adjustd leftHasChanged (bin x b newl r) (-1)
            when [newl, leftHasChanged] = delete l y end if res < 0;
          = adjustd rightHasChanged (bin x b l newr) 1
            when [newr, rightHasChanged] = delete r y end if res > 0;
          = if val~=?v then [t, 0]
            else if l===nil then [r, 1]
            else if r===nil then [l, 1]
            else (adjustd leftHasChanged (bin (last l) b newl r) (-1)
		  when [newl, leftHasChanged] = init l end);
      end;
end;

// The popkv methods may seem like overkill: you already know the k=>v so
// why isn't deletekv enough? However we do need these methods for weak-value
// dicts.
popkv t y@(key=>val) = case pop t y of
  [fail, _, _] = ();
  [v, t, _] = tuple2 v t;
end with
  pop nil _ = [fail, nil, 0];
  pop t@(bin x@(k=>v) b l r) y@(key=>val)
    = case cmp key k of
        res::int
          = v:adjustd leftHasChanged (bin x b newl r) (-1)
            when [v, newl, leftHasChanged] = pop l y end if res < 0;
          = v:adjustd rightHasChanged (bin x b l newr) 1
            when [v, newr, rightHasChanged] = pop r y end if res > 0;
          = if val~=?v then [fail, nil, 0]
            else if l===nil then [v, r, 1]
            else if r===nil then [v, l, 1]
            else (v:adjustd leftHasChanged (bin (last l) b newl r) (-1)
		  when [newl, leftHasChanged] = init l end);
      end;
end;

/* Ordered case, multiple values. */

public minsert minsertk;

minsert t y = insert t y!0 with
  insert nil y@k = [bin (k=>[y]) 0 nil nil, 1];
  insert (bin x@(k=>xs) b l r) y@key
    = case cmp key k of
        res::int
          = adjusti leftHasChanged (bin x b newl r) (-1)
            when [newl, leftHasChanged] = insert l y end if res < 0;
          = adjusti rightHasChanged (bin x b l newr) 1
            when [newr, rightHasChanged] = insert r y end if res > 0;
          = [bin (k=>xs+[y]) b l r, 0];
      end;
end;

minsertk t y@(key=>val) = insert t y!0 with
  insert nil y@(k=>v) = [bin (k=>[y]) 0 nil nil, 1];
  insert (bin x@(k=>xs) b l r) y@(key=>val)
    = case cmp key k of
        res::int
          = adjusti leftHasChanged (bin x b newl r) (-1)
            when [newl, leftHasChanged] = insert l y end if res < 0;
          = adjusti rightHasChanged (bin x b l newr) 1
            when [newr, rightHasChanged] = insert r y end if res > 0;
          = [bin (k=>xs+[y]) b l r, 0];
      end;
end;

public mdelete mdeleteko mdeletekn mpopko mpopkn;
public mdeletekvo mdeletekvn mdeletekva mpopkva;

mdelete t y = delete t y!0 with
  delete nil _ = [nil, 0];
  delete (bin x@(k=>xs) b l r) y@key
    = case cmp key k of
        res::int
          = adjustd leftHasChanged (bin x b newl r) (-1)
            when [newl, leftHasChanged] = delete l y end if res < 0;
          = adjustd rightHasChanged (bin x b l newr) 1
            when [newr, rightHasChanged] = delete r y end if res > 0;
          = if ~::null newxs then [bin (k=>newxs) b l r, 0]
            else if l===nil then [r, 1]
            else if r===nil then [l, 1]
            else (adjustd leftHasChanged (bin (last l) b newl r) (-1)
      	          when [newl, leftHasChanged] = init l end)
            when newxs = tail xs end;
      end;
end;

mdeleteko t y = mdelete t y;

mpopko t y = case pop t y of
  [fail, _, _] = ();
  [v, t, _] = tuple2 v t;
end with
  pop nil _ = [fail, nil, 0];
  pop (bin x@(k=>xs) b l r) y@key
    = case cmp key k of
        res::int
          = v:adjustd leftHasChanged (bin x b newl r) (-1)
            when [v, newl, leftHasChanged] = pop l y end if res < 0;
          = v:adjustd rightHasChanged (bin x b l newr) 1
            when [v, newr, rightHasChanged] = pop r y end if res > 0;
          = if ~::null newxs then [v, bin (k=>newxs) b l r, 0]
            else if l===nil then [v, r, 1]
            else if r===nil then [v, l, 1]
            else (v:adjustd leftHasChanged (bin (last l) b newl r) (-1)
                  when [newl, leftHasChanged] = init l end)
            when v:newxs = xs end;
      end;
end;

mdeletekn t y = delete t y!0 with
  delete nil _ = [nil, 0];
  delete (bin x@(k=>xs) b l r) y@key
    = case cmp key k of
        res::int
          = adjustd leftHasChanged (bin x b newl r) (-1)
            when [newl, leftHasChanged] = delete l y end if res < 0;
          = adjustd rightHasChanged (bin x b l newr) 1
            when [newr, rightHasChanged] = delete r y end if res > 0;
          = if ~::null newxs then [bin (k=>newxs) b l r, 0]
            else if l===nil then [r, 1]
            else if r===nil then [l, 1]
            else (adjustd leftHasChanged (bin (last l) b newl r) (-1)
                  when [newl, leftHasChanged] = init l end)
            when newxs = ::init xs end;
      end;
end;

mpopkn t y = case pop t y of
  [fail, _, _] = ();
  [v, t, _] = tuple2 v t;
end with
  pop nil _ = [fail, nil, 0];
  pop (bin x@(k=>xs) b l r) y@key
    = case cmp key k of
        res::int
          = v:adjustd leftHasChanged (bin x b newl r) (-1)
            when [v, newl, leftHasChanged] = pop l y end if res < 0;
          = v:adjustd rightHasChanged (bin x b l newr) 1
            when [v, newr, rightHasChanged] = pop r y end if res > 0;
          = if ~::null newxs then [v, bin (k=>newxs) b l r, 0]
            else if l===nil then [v, r, 1]
            else if r===nil then [v, l, 1]
            else (v:adjustd leftHasChanged (bin (last l) b newl r) (-1)
                  when [newl, leftHasChanged] = init l end)
            when v:newxs = (::rotate 1) xs end;
      end;
end;

mdeletekvo t y@(key=>val) = delete t y!0 with
  delete nil _ = [nil, 0];
  delete (bin x@(k=>xs) b l r) y@(key=>val)
    = case cmp key k of
        res::int
          = adjustd leftHasChanged (bin x b newl r) (-1)
            when [newl, leftHasChanged] = delete l y end if res < 0;
          = adjustd rightHasChanged (bin x b l newr) 1
            when [newr, rightHasChanged] = delete r y end if res > 0;
          = if ~::null newxs then [bin (k=>newxs) b l r, 0]
            else if l===nil then [r, 1]
            else if r===nil then [l, 1]
            else (adjustd leftHasChanged (bin (last l) b newl r) (-1)
      	          when [newl, leftHasChanged] = init l end)
            when
                newxs = ::rmfirstby (\(k=>v) -> cmp k key == 0 && v==?val) xs
            end;
      end;
end;

mdeletekvn t y@(key=>val) = delete t y!0 with
  delete nil _ = [nil, 0];
  delete (bin x@(k=>xs) b l r) y@(key=>val)
    = case cmp key k of
        res::int
          = adjustd leftHasChanged (bin x b newl r) (-1)
            when [newl, leftHasChanged] = delete l y end if res < 0;
          = adjustd rightHasChanged (bin x b l newr) 1
            when [newr, rightHasChanged] = delete r y end if res > 0;
          = if ~::null newxs then [bin (k=>newxs) b l r, 0]
            else if l===nil then [r, 1]
            else if r===nil then [l, 1]
            else (adjustd leftHasChanged (bin (last l) b newl r) (-1)
                  when [newl, leftHasChanged] = init l end)
            when
                newxs = ::rmlastby (\(k=>v) -> cmp k key == 0 && v==?val) xs
            end;
      end;
end;

mdeletekva t y@(key=>val) = delete t y!0 with
  delete nil _ = [nil, 0];
  delete (bin x@(k=>xs) b l r) y@(key=>val)
    = case cmp key k of
        res::int
          = adjustd leftHasChanged (bin x b newl r) (-1)
            when [newl, leftHasChanged] = delete l y end if res < 0;
          = adjustd rightHasChanged (bin x b l newr) 1
            when [newr, rightHasChanged] = delete r y end if res > 0;
          = if ~::null newxs then [bin (k=>newxs) b l r, 0]
            else if l===nil then [r, 1]
            else if r===nil then [l, 1]
            else (adjustd leftHasChanged (bin (last l) b newl r) (-1)
                  when [newl, leftHasChanged] = init l end)
            when
                newxs = filter (\(k=>v) -> ~(cmp k key == 0 && v==?val)) xs
            end;
      end;
end;

mpopkva t y@(key=>val) = tuple2 vs t when
  [vs, t, _] = pop t y;
  vs = revmap ::val vs;
end with
  pop nil _ = [[], nil, 0];
  pop (bin x@(k=>xs) b l r) y@(key=>val)
    = case cmp key k of
        res::int
          = vs:adjustd leftHasChanged (bin x b newl r) (-1)
            when [vs, newl, leftHasChanged] = pop l y end if res < 0;
          = vs:adjustd rightHasChanged (bin x b l newr) 1
            when [vs, newr, rightHasChanged] = pop r y end if res > 0;
          = if ~::null newxs then [vs, bin (k=>newxs) b l r, 0]
            else if l===nil then [vs, r, 1]
            else if r===nil then [vs, l, 1]
            else (vs:adjustd leftHasChanged (bin (last l) b newl r) (-1)
                  when [newl, leftHasChanged] = init l end)
            when
                vs:newxs = partition (\(k=>v) -> cmp k key == 0 && v==?val) xs
            end;
      end;
end;

// Delete all members for a given key.
public mdeletea mdeleteka mpopka;

mdeletea t y = deletek t y;

mdeleteka t y = mdeletea t y;
mpopka t y = popk t y;

/* Hashed trees, single value. */

public hinsert hinsertk;

hinsert t y = insert t (hash y) y!0 with
  insert nil k::int y = [bin (k=>[y]) 0 nil nil, 1];
  insert (bin x@(k::int=>xs) b l r) key::int y
    = adjusti leftHasChanged (bin x b newl r) (-1)
      when [newl, leftHasChanged] = insert l key y end if key < k;
    = adjusti rightHasChanged (bin x b l newr) 1
      when [newr, rightHasChanged] = insert r key y end if key > k;
    = [bin (k=>replace xs (same y) y) b l r, 0];
end;

hinsertk t y@(rawkey=>_) = insert t (hash rawkey) y!0 with
  insert nil k::int y = [bin (k=>[y]) 0 nil nil, 1];
  insert (bin x@(k::int=>xs) b l r) key::int y
    = adjusti leftHasChanged (bin x b newl r) (-1)
      when [newl, leftHasChanged] = insert l key y end if key < k;
    = adjusti rightHasChanged (bin x b l newr) 1
      when [newr, rightHasChanged] = insert r key y end if key > k;
    = [bin (k=>replace xs (same rawkey.(::key)) y) b l r, 0];
end;

// These are also valid for multi-hashes.
public hdelete hdeletek hpopk;
public hdeletekv hpopkv;

hdelete t y = delete t (hash y) y!0 with
  delete nil _ _ = [nil, 0];
  delete (bin x@(k::int=>xs) b l r) key::int y
    = adjustd leftHasChanged (bin x b newl r) (-1)
      when [newl, leftHasChanged] = delete l key y end if key < k;
    = adjustd rightHasChanged (bin x b l newr) 1
      when [newr, rightHasChanged] = delete r key y end if key > k;
    = if ~::null newxs then [bin (k=>newxs) b l r, 0]
      else if l===nil then [r, 1]
      else if r===nil then [l, 1]
      else (adjustd leftHasChanged (bin (last l) b newl r) (-1)
            when [newl, leftHasChanged] = init l end)
      when newxs = ::rmfirstby (same y) xs end;
end;

hdeletek t y = delete t (hash y) y!0 with
  delete nil _ _ = [nil, 0];
  delete (bin x@(k::int=>xs) b l r) key::int y
    = adjustd leftHasChanged (bin x b newl r) (-1)
      when [newl, leftHasChanged] = delete l key y end if key < k;
    = adjustd rightHasChanged (bin x b l newr) 1
      when [newr, rightHasChanged] = delete r key y end if key > k;
    = if ~::null newxs then [bin (k=>newxs) b l r, 0]
      else if l===nil then [r, 1]
      else if r===nil then [l, 1]
      else (adjustd leftHasChanged (bin (last l) b newl r) (-1)
            when [newl, leftHasChanged] = init l end)
      when newxs = ::rmfirstby (same y.(::key)) xs end;
end;

hpopk t y = case pop t (hash y) y of
  [fail, _, _] = ();
  [v, t, _] = tuple2 v t;
end with
  pop nil _ _ = [fail, nil, 0];
  pop (bin x@(k::int=>xs) b l r) key::int y
    = v:adjustd leftHasChanged (bin x b newl r) (-1)
      when [v, newl, leftHasChanged] = pop l key y end if key < k;
    = v:adjustd rightHasChanged (bin x b l newr) 1
      when [v, newr, rightHasChanged] = pop r key y end if key > k;
    = case pickfirstby (same y.(::key)) xs of
        [] = [fail, nil, 0];
        (_=>v):newxs = if ~::null newxs then [v, bin (k=>newxs) b l r, 0]
                  else if l===nil then [v, r, 1]
                  else if r===nil then [v, l, 1]
                  else (v:adjustd leftHasChanged (bin (last l) b newl r) (-1)
                        when [newl, leftHasChanged] = init l end)
      end;
end;

hdeletekv t y@(key=>val) = delete t (hash key) y!0 with
  delete nil _ _ = [nil, 0];
  delete (bin x@(k::int=>xs) b l r) key::int y
    = adjustd leftHasChanged (bin x b newl r) (-1)
      when [newl, leftHasChanged] = delete l key y end if key < k;
    = adjustd rightHasChanged (bin x b l newr) 1
      when [newr, rightHasChanged] = delete r key y end if key > k;
    = if ~::null newxs then [bin (k=>newxs) b l r, 0]
      else if l===nil then [r, 1]
      else if r===nil then [l, 1]
      else (adjustd leftHasChanged (bin (last l) b newl r) (-1)
            when [newl, leftHasChanged] = init l end)
      when newxs = deleteb xs y end;
  deleteb [] y = [];
  // once keys match, we can stop traversing
  deleteb xx@(x@(k=>v):xs) y@(k=>val) = if v==?val then xs else xx;
  deleteb (x:xs) y = x:deleteb xs y;
end;

// See comments to popkv on why this is needed.
hpopkv t y@(key=>val) = case pop t (hash key) y of
  [fail, _, _] = ();
  [v, t, _] = tuple2 v t;
end with
  pop nil _ _ = [fail, nil, 0];
  pop (bin x@(k::int=>xs) b l r) key::int y
    = v:adjustd leftHasChanged (bin x b newl r) (-1)
      when [v, newl, leftHasChanged] = pop l key y end if key < k;
    = v:adjustd rightHasChanged (bin x b l newr) 1
      when [v, newr, rightHasChanged] = pop r key y end if key > k;
    = case popb xs y of
        [] = [fail, nil, 0];
        v:newxs = if ~::null newxs then [v, bin (k=>newxs) b l r, 0]
                  else if l===nil then [v, r, 1]
                  else if r===nil then [v, l, 1]
                  else (v:adjustd leftHasChanged (bin (last l) b newl r) (-1)
                        when [newl, leftHasChanged] = init l end)
      end;
  popb [] y = [];
  // once keys match, we can stop traversing
  popb (x@(k=>v):xs) y@(k=>val) = if v==?val then v:xs else [];
  popb (x:xs) y = swap x (popb xs y) [];
end;

/* Hashed trees, multiple values. */

public mhinsert mhinsertk;

mhinsert t y = insert t (hash y) y!0 with
  insert nil k::int y = [bin (k=>[y]) 0 nil nil, 1];
  insert (bin x@(k::int=>xs) b l r) key::int y
    = adjusti leftHasChanged (bin x b newl r) (-1)
      when [newl, leftHasChanged] = insert l key y end if key < k;
    = adjusti rightHasChanged (bin x b l newr) 1
      when [newr, rightHasChanged] = insert r key y end if key > k;
    = [bin (k=>xs+[y]) b l r, 0];
end;

mhinsertk t y@(key=>val) = insert t (hash key) y!0 with
  insert nil k::int y = [bin (k=>[y]) 0 nil nil, 1];
  insert (bin x@(k::int=>xs) b l r) key::int y
    = adjusti leftHasChanged (bin x b newl r) (-1)
      when [newl, leftHasChanged] = insert l key y end if key < k;
    = adjusti rightHasChanged (bin x b l newr) 1
      when [newr, rightHasChanged] = insert r key y end if key > k;
    = [bin (k=>xs+[y]) b l r, 0];
end;

public mhdelete mhdeleteko mhdeletekn mhpopko mhpopkn;
public mhdeletekvo mhdeletekvn mhdeletekva mhpopkva;

mhdelete    t y = hdelete   t y;
mhdeleteko  t y = hdeletek  t y;
mhpopko     t y = hpopk     t y;

mhdeletekn t y = delete t (hash y) y!0 with
  delete nil _ _ = [nil, 0];
  delete (bin x@(k::int=>xs) b l r) key::int y
    = adjustd leftHasChanged (bin x b newl r) (-1)
      when [newl, leftHasChanged] = delete l key y end if key < k;
    = adjustd rightHasChanged (bin x b l newr) 1
      when [newr, rightHasChanged] = delete r key y end if key > k;
    = if ~::null newxs then [bin (k=>newxs) b l r, 0]
      else if l===nil then [r, 1]
      else if r===nil then [l, 1]
      else (adjustd leftHasChanged (bin (last l) b newl r) (-1)
            when [newl, leftHasChanged] = init l end)
      when newxs = ::rmlastby (same y.(::key)) xs end;
end;

mhpopkn t y = case pop t (hash y) y of
  [fail, _, _] = ();
  [v, t, _] = tuple2 v t;
end with
  pop nil _ _ = [fail, nil, 0];
  pop (bin x@(k::int=>xs) b l r) key::int y
    = v:adjustd leftHasChanged (bin x b newl r) (-1)
      when [v, newl, leftHasChanged] = pop l key y end if key < k;
    = v:adjustd rightHasChanged (bin x b l newr) 1
      when [v, newr, rightHasChanged] = pop r key y end if key > k;
    = case picklastby (same y.(::key)) xs of
        [] = [fail, nil, 0];
        (_=>v):newxs = if ~::null newxs then [v, bin (k=>newxs) b l r, 0]
                  else if l===nil then [v, r, 1]
                  else if r===nil then [v, l, 1]
                  else (v:adjustd leftHasChanged (bin (last l) b newl r) (-1)
                        when [newl, leftHasChanged] = init l end)
      end;
end;

mhdeletekvo t y@(rawkey=>val) = delete t (hash rawkey) y!0 with
  delete nil _ _ = [nil, 0];
  delete (bin x@(k::int=>xs) b l r) key::int y
    = adjustd leftHasChanged (bin x b newl r) (-1)
      when [newl, leftHasChanged] = delete l key y end if key < k;
    = adjustd rightHasChanged (bin x b l newr) 1
      when [newr, rightHasChanged] = delete r key y end if key > k;
    = if ~::null newxs then [bin (k=>newxs) b l r, 0]
      else if l===nil then [r, 1]
      else if r===nil then [l, 1]
      else (adjustd leftHasChanged (bin (last l) b newl r) (-1)
           when [newl, leftHasChanged] = init l end)
      when newxs = ::rmfirstby (\(k=>v) -> k===rawkey && v==?val) xs end;
end;

mhdeletekvn t y@(rawkey=>val) = delete t (hash rawkey) y!0 with
  delete nil _ _ = [nil, 0];
  delete (bin x@(k::int=>xs) b l r) key::int y
    = adjustd leftHasChanged (bin x b newl r) (-1)
      when [newl, leftHasChanged] = delete l key y end if key < k;
    = adjustd rightHasChanged (bin x b l newr) 1
      when [newr, rightHasChanged] = delete r key y end if key > k;
    = if ~::null newxs then [bin (k=>newxs) b l r, 0]
      else if l===nil then [r, 1]
      else if r===nil then [l, 1]
      else (adjustd leftHasChanged (bin (last l) b newl r) (-1)
           when [newl, leftHasChanged] = init l end)
      when newxs = ::rmlastby (\(k=>v) -> k===rawkey && v==?val) xs end;
end;

mhdeletekva t y@(rawkey=>val) = delete t (hash rawkey) y!0 with
  delete nil _ _ = [nil, 0];
  delete (bin x@(k::int=>xs) b l r) key::int y
    = adjustd leftHasChanged (bin x b newl r) (-1)
      when [newl, leftHasChanged] = delete l key y end if key < k;
    = adjustd rightHasChanged (bin x b l newr) 1
      when [newr, rightHasChanged] = delete r key y end if key > k;
    = if ~::null newxs then [bin (k=>newxs) b l r, 0]
      else if l===nil then [r, 1]
      else if r===nil then [l, 1]
      else (adjustd leftHasChanged (bin (last l) b newl r) (-1)
           when [newl, leftHasChanged] = init l end)
      when newxs = filter (\(k=>v) -> ~(k===rawkey && v==?val)) xs end;
end;

mhpopkva t y@(rawkey=>val) = tuple2 vs t when
  [vs, t, _] = pop t (hash rawkey) y;
  vs = revmap ::val vs;
end with
  pop nil _ _ = [[], nil, 0];
  pop (bin x@(k::int=>xs) b l r) key::int y
    = vs:adjustd leftHasChanged (bin x b newl r) (-1)
      when [vs, newl, leftHasChanged] = pop l key y end if key < k;
    = vs:adjustd rightHasChanged (bin x b l newr) 1
      when [vs, newr, rightHasChanged] = pop r key y end if key > k;
    = if ~::null newxs then [vs, bin (k=>newxs) b l r, 0]
      else if l===nil then [vs, r, 1]
      else if r===nil then [vs, l, 1]
      else (vs:adjustd leftHasChanged (bin (last l) b newl r) (-1)
            when [newl, leftHasChanged] = init l end)
      when vs:newxs = partition (\(k=>v) -> k===rawkey && v==?val) xs end;
end;

public mhdeletea mhdeleteka mhpopka;

mhdeletea t y = delete t (hash y) y!0 with
  delete nil _ _ = [nil, 0];
  delete (bin x@(k::int=>xs) b l r) key::int y
    = adjustd leftHasChanged (bin x b newl r) (-1)
      when [newl, leftHasChanged] = delete l key y end if key < k;
    = adjustd rightHasChanged (bin x b l newr) 1
      when [newr, rightHasChanged] = delete r key y end if key > k;
    = if ~::null newxs then [bin (k=>newxs) b l r, 0]
      else if l===nil then [r, 1]
      else if r===nil then [l, 1]
      else (adjustd leftHasChanged (bin (last l) b newl r) (-1)
            when [newl, leftHasChanged] = init l end)
      when newxs = filter (~==y) xs end;
end;

mhdeleteka t y = delete t (hash y) y!0 with
  delete nil _ _ = [nil, 0];
  delete (bin x@(k::int=>xs) b l r) key::int y
    = adjustd leftHasChanged (bin x b newl r) (-1)
      when [newl, leftHasChanged] = delete l key y end if key < k;
    = adjustd rightHasChanged (bin x b l newr) 1
      when [newr, rightHasChanged] = delete r key y end if key > k;
    = if ~::null newxs then [bin (k=>newxs) b l r, 0]
      else if l===nil then [r, 1]
      else if r===nil then [l, 1]
      else (adjustd leftHasChanged (bin (last l) b newl r) (-1)
            when [newl, leftHasChanged] = init l end)
      when newxs = filter (\(k=>v) -> k~==y) xs end;
end;

mhpopka t y = case pop t (hash y) y!0 of
  [fail, _, _] = ();
  [vs, t, _] = vs, t;
end with
  pop nil _ _ = [fail, nil, 0];
  pop (bin x@(k::int=>xs) b l r) key::int y
    = vs:adjustd leftHasChanged (bin x b newl r) (-1)
      when [vs, newl, leftHasChanged] = pop l key y end if key < k;
    = vs:adjustd rightHasChanged (bin x b l newr) 1
      when [vs, newr, rightHasChanged] = pop r key y end if key > k;
    = case partition (same y.(::key)) xs of
      [],_ = [fail, nil, 0];
      (_=>vs), newxs = if ~::null newxs then [vs, bin (k=>newxs) b l r, 0]
      else if l===nil then [vs, r, 1]
      else if r===nil then [vs, l, 1]
      else (vs:adjustd leftHasChanged (bin (last l) b newl r) (-1)
            when [newl, leftHasChanged] = init l end);
      end;
end;

/* Private helper functions. */

// Adjust after insertions.

adjusti 0 oldTree _ = [oldTree, 0];

adjusti 1 t@(bin x b0 l r) LoR = [rebal toBeRebalanced t b1, whatHasChanged]
when
  [b1, whatHasChanged, toBeRebalanced] = table b0 LoR
end with
  rebal 0 (bin x _ l r) b = bin x b l r;
  rebal 1 oldTree _ = (rotate oldTree)!0;
  /*
  Balance rules for insertions
  	balance	where		balance	  whole tree	to be
  	before	inserted	after	  increased	rebalanced
  table	( 0)	(-1)		= [( 1), 	1,		0;
  table	( 0)	( 1)		= [(-1),  	1,		0];
  table	( 1)	(-1)		= [( 0),  	0,		1];
  table	( 1)	( 1)		= [( 0),  	0,		0];
  table	(-1)	(-1)		= [( 0),  	0,		0];
  table	(-1)	( 1)		= [( 0),  	0,		1]
  */
  table bb::int wi::int = [ba, wti, tbr] when
      ba  = if bb == 0 then -wi else 0;
      wti = bb == 0;
      tbr = (bb + wi) == 0;
  end;
end;

// Adjust after deletions.

adjustd 0 oldTree _ = [oldTree, 0];

adjustd 1 t@(bin _ b0 l r) LoR = rebal toBeRebalanced t b1 whatHasChanged
when
  [b1, whatHasChanged, toBeRebalanced] = table b0 LoR;
end with
  rebal 0 (bin x _ l r) b whatHasChanged
    = [bin x b l r, whatHasChanged];
  rebal 1 oldTree _ _ = rotate oldTree;
  /*
  Balance rules for deletions
	balance	where		balance	  whole tree	to be
	before	deleted		after	  decreased	rebalanced
  table	( 0)	( 1)		= [( 1),  0,		0];
  table	( 0)	(-1)		= [(-1),  0,		0];
  table	( 1)	( 1)		= [( 0),  1,		1];
					  ^^^^
  It depends on the tree pattern in rotate whether it really decreases.

  table	( 1)	(-1)		= [( 0),  1, 		0];
  table	(-1)	( 1)		= [( 0),  1,		0];
  table	(-1)	(-1)		= [( 0),  1,		1];
					  ^^^^
  It depends on the tree pattern in rotate whether it really decreases.
  */
  table bb wd = [ba, wtd, tbr] when
    ba	= if bb == 0 then wd else 0;
    wtd	= abs bb;
    tbr	= bb == wd;
  end;
end;

// Delete the last element of a tree.

init nil = [nil, 0];
init (bin _ _ l nil) = [l, 1];
init (bin x b::int l r)
  = adjustd rightHasChanged (bin x b l newr) 1
    when [newr, rightHasChanged] = init r end;

// Single and double tree rotations - these are common for insert and delete.

/* The patterns (-1)-(-1), (-1)-( 1), ( 1)-( 1) and ( 1)-(-1) on the LHS
   always change the tree height and these are the only patterns which can
   happen after an insertion. That's the reason why we can use tablei only to
   decide the needed changes.

   The patterns (-1)-( 0) and ( 1)-( 0) do not change the tree height. After a
   deletion any pattern can occur and so we return 1 or 0 as a flag of a
   height change. */

rotate d = rotate d
with
  rotate (bin x (-1) alpha (bin y (-1) beta gamma))
    = [bin y ( 0) (bin x ( 0) alpha beta) gamma, 1];
  rotate (bin x (-1) alpha (bin y ( 0) beta gamma))
    = [bin y ( 1) (bin x (-1) alpha beta) gamma, 0];
      // the tree doesn't decrease with this pattern
  rotate (bin x (-1) alpha (bin y ( 1) (bin z b1 beta gamma) delta))
    = [bin z ( 0) (bin x b2 alpha beta) (bin y b3 gamma delta), 1]
      when [b2, b3] = table b1 end;
  rotate (bin y ( 1) (bin x ( 1) alpha beta) gamma)
    = [bin x ( 0) alpha (bin y ( 0) beta  gamma), 1];
  rotate (bin y ( 1) (bin x ( 0) alpha beta) gamma)
    = [bin x (-1) alpha (bin y ( 1) beta  gamma), 0];
      // the tree doesn't decrease with this pattern
  rotate (bin y ( 1) (bin x (-1) alpha (bin z b1 beta gamma)) delta)
    = [bin z ( 0) (bin x b2 alpha beta) (bin y b3 gamma delta), 1]
      when [b2, b3] = table b1 end;
  /*
  table ( 1)			= [( 0), (-1)];
  table (-1)			= [( 1), ( 0)];
  table ( 0)			= [( 0), ( 0)]
  */
  table bal = [b1, b2] when
    b1 =   bal == (-1);
    b2 = -(bal ==   1);
  end;
end;

// Optimised key comparison. This must return an int.
cmp a::string b::string = __C::strcmp a b;
cmp a::bigint b::bigint = __C::bigint_cmp a b;
cmp a::int b::int | cmp a::double b::double |
cmp a b = if a<b then -1 else b<a;

// replace first x satisfying p with y, else add y at end
replace [] p y = [y];
replace (x:xs) p y = if p x then y:xs else x:replace xs p y;

swap y (x:xs) default = x:y:xs;
swap _ []     default = default;

// [] when no hits, else leftmost p is rotated to head
pickfirstby p xs = tick xs with
    tick [] = [];
    tick (x:xs) = if p x then x:xs
                     else swap x (tick xs) [];
end;

// [] when no hits, else rightmost p is rotated to head
picklastby p xs = tick xs [] [] [] with
    tick []     _  []     _   = [];
    tick []     ms (h:hs) hss = h:tack (reverse ms) hs hss;
    tick (x:xs) ms hs     hss = if p x
                                then tick xs [] (x:ms) (hs:hss)
                                else tick xs (x:ms) hs hss;
    tack zs []     []         = zs;
    tack zs []     (xs:xss)   = tack zs xs xss;
    tack zs (y:ys) xss        = tack (y:zs) ys xss;
end;

// custom version of partition
partition p ys = spl p ys [] [] with
    spl p []     _  [] = []:ys; // no hits, use original
    spl p []     ms hs = hs:reverse ms; // push reversed list of hits to front
    spl p (x:xs) ms hs = spl p xs ms (x:hs) if p x;
                       = spl p xs (x:ms) hs otherwise;
end;
